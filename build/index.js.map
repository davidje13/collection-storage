{"version":3,"sources":["webpack://websocket-express/webpack/universalModuleDefinition","webpack://websocket-express/webpack/bootstrap","webpack://websocket-express/external \"crypto\"","webpack://websocket-express/external \"mongodb\"","webpack://websocket-express/external \"url\"","webpack://websocket-express/external \"ioredis\"","webpack://websocket-express/./src/helpers/serialiser.ts","webpack://websocket-express/./src/memory/MemoryCollection.ts","webpack://websocket-express/./src/memory/MemoryDb.ts","webpack://websocket-express/./src/mongo/MongoCollection.ts","webpack://websocket-express/./src/mongo/MongoDb.ts","webpack://websocket-express/./src/redis/RedisCollection.ts","webpack://websocket-express/./src/redis/RedisDb.ts","webpack://websocket-express/./src/wrappers/WrappedCollection.ts","webpack://websocket-express/./src/helpers/LruCache.ts","webpack://websocket-express/./src/wrappers/encryption/nodeEncryptionSync.ts","webpack://websocket-express/./src/wrappers/encrypted.ts","webpack://websocket-express/./src/index.ts","webpack://websocket-express/./src/CollectionStorage.ts"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","serialiseValue","Buffer","toString","JSON","stringify","deserialiseValue","type","data","substr","from","parse","Error","sleep","millis","Promise","resolve","setTimeout","serialiseRecord","record","result","keys","forEach","k","deserialiseRecord","MemoryCollection","constructor","simulatedLatency","this","Map","map","options","serialised","internalCheckDuplicates","set","id","internalPopulateIndices","keyName","upsert","undefined","sId","internalGetSerialisedIds","add","assign","oldSerialised","oldValue","newValue","newSerialised","internalRemoveIndices","e","fields","all","getAll","length","sIds","field","applyFilter","delete","sKey","has","keyInfo","serialisedValue","checkId","entries","unique","v","Set","size","globalDbs","initial","existing","getGlobal","MemoryDb","url","parsedUrl","URL","hostname","params","searchParams","Number","db","getCollection","mapTables","MONGO_ID","ID","convertToMongo","converted","rest","MBinary","_bsontype","convertFromMongo","buffer","makeMongoFields","names","fieldName","fieldNameToMongo","MongoCollection","collection","createIndex","insertOne","updateOne","$set","findOne","projection","cursor","mFields","find","raw","push","deleteMany","deletedCount","MongoDb","MongoClient","client","connect","useNewUrlParser","useUnifiedTopology","RedisCollection","prefix","keyPrefix","keyPrefixes","uniqueKeys","exists","makeKey","internalCheckKeyDuplicates","runMulti","setByKey","internalMigrateIndices","patchSerialised","internalGetPossibleSerialisedIds","readByKey","cut","readByKeys","indexedKeys","items","item","flatMap","serialisedId","flat","getByKey","serialisedIds","results","f","filter","values","some","smembers","partialSerialisedValue","partialOldSerialisedValue","partialNewSerialisedValue","commands","filtered","multi","exec","RedisDb","default","RedisStatic","lazyConnect","hasAnyField","WrappedCollection","baseCollection","wrapper","entry","wrapAll","includes","unwrapAll","extra","update","preRemove","remove","async","processed","preWrap","allFields","wrap","preUnwrap","unwrap","LruCache","capacity","storage","flush","next","ALG","ALG_BUF","nodeEncryptionSync","encrypt","iv","crypto","randomBytes","cipher","createCipheriv","part","final","concat","decrypt","slice","equals","encrypted","decipher","createDecipheriv","decrypted","generateKey","createSecretKey","serialiseKey","export","deserialiseKey","makeEncrypter","encryptByKey","cr","encryptByRecord","keyCollection","cacheSize","cache","loadKey","generateIfNeeded","cached","removeKey","encryptByRecordWithMasterKey","sMasterKey","keyEnc","CollectionStorage","dbClass","startsWith","message"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"websocket-express\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"websocket-express\"] = factory();\n\telse\n\t\troot[\"websocket-express\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","module.exports = require(\"crypto\");","module.exports = require(\"mongodb\");","module.exports = require(\"url\");","module.exports = require(\"ioredis\");","export function serialiseValue(\n  value: unknown,\n): string {\n  if (value instanceof Buffer) {\n    return `B${value.toString('base64')}`;\n  }\n  return `J${JSON.stringify(value)}`;\n}\n\nexport function deserialiseValue(\n  value: string,\n): unknown {\n  const type = value[0];\n  const data = value.substr(1);\n  if (type === 'B') {\n    return Buffer.from(data, 'base64');\n  }\n  if (type === 'J') {\n    return JSON.parse(data);\n  }\n  throw new Error(`Unknown data type ${type}`);\n}\n","import Collection, { KeyOptions } from '../interfaces/Collection';\nimport IDable from '../interfaces/IDable';\nimport { DBKeys } from '../interfaces/DB';\nimport { serialiseValue, deserialiseValue } from '../helpers/serialiser';\n\nfunction sleep(millis: number): Promise<void> | null {\n  if (!millis) {\n    return null;\n  }\n\n  // Simulate data access delays to ensure non-flakey e2e tests, etc.\n  return new Promise((resolve): any => setTimeout(resolve, millis));\n}\n\nfunction applyFilter<T, F extends readonly (keyof T)[]>(\n  data: T,\n  fields?: F,\n): Pick<T, F[-1]> {\n  if (!fields) {\n    return data;\n  }\n  const result: Pick<T, F[-1]> = {} as any;\n  fields.forEach((field) => {\n    result[field] = data[field];\n  });\n  return result;\n}\n\ninterface KeyInfo {\n  map: Map<string, Set<string>>;\n  options: KeyOptions;\n}\n\nfunction serialiseRecord<T>(\n  record: T,\n): Record<string, string> {\n  const result: Record<string, string> = {};\n  Object.keys(record).forEach((k) => {\n    result[k] = serialiseValue((record as any)[k]);\n  });\n  return result;\n}\n\nfunction deserialiseRecord(\n  record: Record<string, string>,\n): Record<string, unknown> {\n  const result: Record<string, any> = {};\n  Object.keys(record).forEach((k) => {\n    result[k] = deserialiseValue(record[k]);\n  });\n  return result;\n}\n\nexport default class MemoryCollection<T extends IDable> implements Collection<T> {\n  private readonly data: Map<string, Record<string, string>>;\n\n  private readonly keys: { [K in keyof T]?: KeyInfo } = {};\n\n  public constructor(\n    keys: DBKeys<T> = {},\n    private readonly simulatedLatency = 0,\n  ) {\n    this.data = new Map();\n\n    Object.keys(keys).forEach((k) => {\n      const key = k as keyof DBKeys<T>;\n      this.keys[key] = { map: new Map(), options: keys[key]! };\n    });\n  }\n\n  public async add(value: T): Promise<void> {\n    await sleep(this.simulatedLatency);\n\n    const serialised = serialiseRecord(value);\n    this.internalCheckDuplicates(serialised, true);\n    this.data.set(serialised.id, serialised);\n    this.internalPopulateIndices(serialised);\n  }\n\n  public async update<K extends keyof T & string>(\n    keyName: K,\n    key: T[K],\n    value: Partial<T>,\n    { upsert = false } = {},\n  ): Promise<void> {\n    if (upsert && keyName !== 'id' && value.id === undefined) {\n      throw new Error('Cannot upsert without ID');\n    }\n\n    await sleep(this.simulatedLatency);\n\n    const sId = this.internalGetSerialisedIds(keyName, key)[0];\n    if (sId === undefined) {\n      if (upsert) {\n        await this.add(Object.assign({ [keyName]: key }, value as T));\n      }\n      return;\n    }\n    const oldSerialised = this.data.get(sId)!;\n    const oldValue = deserialiseRecord(oldSerialised) as T;\n    const newValue = Object.assign({}, oldValue, value);\n    if (newValue.id !== oldValue.id) {\n      throw new Error('Cannot update id');\n    }\n    const newSerialised = serialiseRecord(newValue);\n    this.internalRemoveIndices(oldSerialised);\n    try {\n      this.internalCheckDuplicates(newSerialised, false);\n    } catch (e) {\n      this.internalPopulateIndices(oldSerialised);\n      throw e;\n    }\n    this.data.set(newSerialised.id, newSerialised);\n    this.internalPopulateIndices(newSerialised);\n  }\n\n  public async get<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    keyName: K,\n    key: T[K],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    const all = await this.getAll(keyName, key, fields);\n    if (!all.length) {\n      return null;\n    }\n    return all[0];\n  }\n\n  public async getAll<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    keyName?: K,\n    key?: T[K],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    await sleep(this.simulatedLatency);\n\n    let sIds: string[];\n    if (keyName) {\n      sIds = this.internalGetSerialisedIds(keyName, key!);\n    } else {\n      sIds = [...this.data.keys()];\n    }\n    return sIds.map((sId) => applyFilter(\n      deserialiseRecord(this.data.get(sId)!) as T,\n      fields,\n    ));\n  }\n\n  public async remove<K extends keyof T & string>(\n    key: K,\n    value: T[K],\n  ): Promise<number> {\n    await sleep(this.simulatedLatency);\n\n    const sIds = this.internalGetSerialisedIds(key, value);\n    sIds.forEach((sId) => {\n      const oldSerialised = this.data.get(sId)!;\n      this.internalRemoveIndices(oldSerialised);\n      this.data.delete(sId);\n    });\n\n    return sIds.length;\n  }\n\n  private internalGetSerialisedIds<K extends keyof T>(\n    keyName: K,\n    key: T[K],\n  ): string[] {\n    const sKey = serialiseValue(key);\n    if (keyName === 'id') {\n      return this.data.has(sKey) ? [sKey] : [];\n    }\n    const keyInfo = this.keys[keyName];\n    if (!keyInfo) {\n      throw new Error(`Requested key ${keyName} not indexed`);\n    }\n    const sIds = keyInfo.map.get(sKey);\n    return sIds ? [...sIds] : []; // convert set to array\n  }\n\n  private internalCheckDuplicates(\n    serialisedValue: Record<string, string>,\n    checkId: boolean,\n  ): void {\n    if (checkId && this.data.has(serialisedValue.id)) {\n      throw new Error('duplicate');\n    }\n    Object.entries(this.keys).forEach(([key, keyInfo]) => {\n      const { map, options } = keyInfo!;\n      if (options.unique && map.has(serialisedValue[key])) {\n        throw new Error('duplicate');\n      }\n    });\n  }\n\n  private internalPopulateIndices(\n    serialisedValue: Record<string, string>,\n  ): void {\n    Object.entries(this.keys).forEach(([key, keyInfo]) => {\n      const { map } = keyInfo!;\n      const v = serialisedValue[key];\n      let o = map.get(v);\n      if (!o) {\n        o = new Set<string>();\n        map.set(v, o);\n      }\n      o.add(serialisedValue.id);\n    });\n  }\n\n  private internalRemoveIndices(\n    serialisedValue: Record<string, string>,\n  ): void {\n    Object.entries(this.keys).forEach(([key, keyInfo]) => {\n      const { map } = keyInfo!;\n      const v = serialisedValue[key];\n      const o = map.get(v)!;\n      o.delete(serialisedValue.id);\n      if (!o.size) {\n        map.delete(v);\n      }\n    });\n  }\n}\n","import { URL } from 'url';\nimport MemoryCollection from './MemoryCollection';\nimport DB, { DBKeys } from '../interfaces/DB';\nimport IDable from '../interfaces/IDable';\n\nfunction getGlobal<T>(name: string, initial: T): T {\n  const existing = (global as any)[name];\n  if (existing) {\n    return existing;\n  }\n\n  (global as any)[name] = initial;\n  return initial;\n}\n\nconst globalDbs = getGlobal(\n  'collectionStorageInMemory',\n  new Map<string, MemoryDb>(),\n);\n\nexport default class MemoryDb implements DB {\n  private readonly simulatedLatency: number;\n\n  private readonly mapTables = new Map<string, MemoryCollection<any>>();\n\n  public constructor({ simulatedLatency = 0 } = {}) {\n    this.simulatedLatency = simulatedLatency;\n  }\n\n  public static connect(url: string): MemoryDb {\n    const parsedUrl = new URL(url);\n    const name = parsedUrl.hostname;\n    if (name && globalDbs.has(name)) {\n      return globalDbs.get(name)!;\n    }\n    const params = parsedUrl.searchParams;\n    const simulatedLatency = Number(params.get('simulatedLatency'));\n    const db = new MemoryDb({ simulatedLatency });\n    if (name) {\n      globalDbs.set(name, db);\n    }\n    return db;\n  }\n\n  public getCollection<T extends IDable>(\n    name: string,\n    keys?: DBKeys<T>,\n  ): MemoryCollection<T> {\n    if (!this.mapTables.has(name)) {\n      this.mapTables.set(name, new MemoryCollection(\n        keys,\n        this.simulatedLatency,\n      ));\n    }\n    return this.mapTables.get(name)! as MemoryCollection<T>;\n  }\n}\n","import {\n  Collection as MCollection,\n  Cursor as MCursor,\n  Binary as MBinary,\n} from 'mongodb';\nimport IDable from '../interfaces/IDable';\nimport Collection from '../interfaces/Collection';\nimport { DBKeys } from '../interfaces/DB';\n\nconst MONGO_ID = '_id';\nconst ID = 'id';\n\ntype MongoT<T extends Partial<IDable>> = Omit<T, 'id'> & { _id?: T['id'] };\n\nfunction fieldNameToMongo(name: string): string {\n  if (name === ID) {\n    return MONGO_ID;\n  }\n  return name;\n}\n\nfunction convertToMongo<T extends Partial<IDable>>(value: T): MongoT<T> {\n  let converted: MongoT<T>;\n  // keys\n  if (value[ID] === undefined) {\n    converted = Object.assign({}, value);\n  } else {\n    const { [ID]: id, ...rest } = value;\n    converted = { [MONGO_ID]: id, ...rest };\n  }\n  // values\n  Object.keys(converted).forEach((k) => {\n    const v = (converted as any)[k];\n    if (v instanceof Buffer) {\n      (converted as any)[k] = new MBinary(v);\n    }\n    // eslint-disable-next-line no-underscore-dangle\n    if (typeof v === 'object' && v._bsontype) {\n      throw new Error('Must use Buffer to provide binary data');\n    }\n  });\n  return converted;\n}\n\nfunction convertFromMongo<T extends Partial<IDable>>(\n  value: MongoT<T> | null,\n): T | null {\n  if (!value) {\n    return null;\n  }\n  let converted: T;\n  // keys\n  if (value[MONGO_ID] === undefined) {\n    converted = Object.assign({}, value) as T;\n  } else {\n    const { [MONGO_ID]: id, ...rest } = value;\n    converted = { [ID]: id, ...rest } as any;\n  }\n  // values\n  Object.keys(converted).forEach((k) => {\n    const v = (converted as any)[k];\n    // eslint-disable-next-line no-underscore-dangle\n    if (typeof v === 'object' && v._bsontype === 'Binary') {\n      (converted as any)[k] = v.buffer;\n    }\n  });\n  return converted;\n}\n\nfunction makeMongoFields(names?: readonly string[]): Record<string, boolean> {\n  const fields: Record<string, boolean> = {};\n  if (names) {\n    fields[MONGO_ID] = false;\n    names.forEach((fieldName) => {\n      fields[fieldNameToMongo(fieldName)] = true;\n    });\n  }\n  return fields;\n}\n\nexport default class MongoCollection<T extends IDable> implements Collection<T> {\n  public constructor(\n    private readonly collection: MCollection,\n    keys: DBKeys<T> = {},\n  ) {\n    Object.keys(keys).forEach((k) => {\n      const keyName = k as keyof DBKeys<T>;\n      const options = keys[keyName];\n      if (options && options.unique) {\n        collection.createIndex({ [keyName]: 1 }, { unique: true });\n      } else {\n        collection.createIndex({ [keyName]: 'hashed' });\n      }\n    });\n  }\n\n  public async add(value: T): Promise<void> {\n    await this.collection.insertOne(convertToMongo(value));\n  }\n\n  public async update<K extends keyof T & string>(\n    keyName: K,\n    key: T[K],\n    value: Partial<T>,\n    { upsert = false } = {},\n  ): Promise<void> {\n    if (upsert && keyName !== 'id' && value.id === undefined) {\n      throw new Error('Cannot upsert without ID');\n    }\n\n    await this.collection.updateOne(\n      convertToMongo({ [keyName]: key }),\n      { $set: convertToMongo(value) },\n      { upsert },\n    );\n  }\n\n  public async get<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    keyName: K,\n    key: T[K],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    const raw = await this.collection.findOne<T>(\n      convertToMongo({ [keyName]: key }),\n      { projection: makeMongoFields(fields) },\n    );\n    return convertFromMongo<T>(raw);\n  }\n\n  public async getAll<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    keyName?: K,\n    key?: T[K],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    const result: Pick<T, F[-1]>[] = [];\n\n    let cursor: MCursor<T>;\n    const mFields = makeMongoFields(fields);\n    if (keyName) {\n      cursor = this.collection.find<T>(\n        convertToMongo({ [keyName]: key }),\n        { projection: mFields },\n      );\n    } else {\n      cursor = this.collection.find<T>({}, { projection: mFields });\n    }\n    await cursor.forEach((raw) => result.push(convertFromMongo<T>(raw)!));\n\n    return result;\n  }\n\n  public async remove<K extends keyof T & string>(\n    key: K,\n    value: T[K],\n  ): Promise<number> {\n    const result = await this.collection.deleteMany(\n      convertToMongo({ [key]: value }),\n    );\n    return result.deletedCount || 0;\n  }\n}\n","import { Db as MDb } from 'mongodb';\nimport MongoCollection from './MongoCollection';\nimport DB, { DBKeys } from '../interfaces/DB';\nimport IDable from '../interfaces/IDable';\n\nexport default class MongoDb implements DB {\n  private constructor(\n    private readonly db: MDb,\n  ) {}\n\n  public static async connect(url: string): Promise<MongoDb> {\n    const { MongoClient } = await import('mongodb');\n    const client = await MongoClient.connect(url, {\n      useNewUrlParser: true,\n      useUnifiedTopology: true,\n    });\n    return new MongoDb(client.db());\n  }\n\n  public getCollection<T extends IDable>(\n    name: string,\n    keys?: DBKeys<T>,\n  ): MongoCollection<T> {\n    const collection = this.db.collection(name);\n    return new MongoCollection(collection, keys);\n  }\n}\n","import { Redis } from 'ioredis';\nimport IDable from '../interfaces/IDable';\nimport Collection from '../interfaces/Collection';\nimport { DBKeys } from '../interfaces/DB';\nimport { serialiseValue, deserialiseValue } from '../helpers/serialiser';\n\nfunction serialiseRecord<T>(\n  record: T,\n): Record<string, string> {\n  const result: Record<string, string> = {};\n  Object.keys(record).forEach((k) => {\n    result[k] = serialiseValue((record as any)[k]);\n  });\n  return result;\n}\n\nfunction deserialiseRecord(\n  record: Record<string, string>,\n): Record<string, unknown> {\n  const result: Record<string, any> = {};\n  Object.keys(record).forEach((k) => {\n    result[k] = deserialiseValue(record[k]);\n  });\n  return result;\n}\n\ninterface Key {\n  key: string;\n  prefix: string;\n}\n\nexport default class RedisCollection<T extends IDable> implements Collection<T> {\n  private readonly keyPrefixes: { [K in keyof T]?: string } = {};\n\n  private readonly keys: Key[] = [];\n\n  private readonly uniqueKeys: Key[] = [];\n\n  public constructor(\n    private readonly client: Redis,\n    private readonly prefix: string,\n    keys: DBKeys<T> = {},\n  ) {\n    Object.keys(keys).forEach((k) => {\n      const key = k as keyof DBKeys<T>;\n      const keyPrefix = `${prefix}-${key}`;\n      this.keyPrefixes[key] = keyPrefix;\n      const keyInfo = { key, prefix: keyPrefix };\n      this.keys.push(keyInfo);\n      if (keys[key]!.unique) {\n        this.uniqueKeys.push(keyInfo);\n      }\n    });\n  }\n\n  public async add(value: T): Promise<void> {\n    const serialised = serialiseRecord(value);\n    if (await this.client.exists(this.makeKey(serialised.id))) {\n      throw new Error('duplicate');\n    }\n    await this.internalCheckKeyDuplicates(serialised.id, serialised);\n    await this.runMulti([\n      this.setByKey(serialised.id, serialised),\n      ...this.internalMigrateIndices(serialised.id, {}, serialised),\n    ]);\n  }\n\n  public async update<K extends keyof T & string>(\n    keyName: K,\n    key: T[K],\n    value: Partial<T>,\n    { upsert = false } = {},\n  ): Promise<void> {\n    if (upsert && keyName !== 'id' && value.id === undefined) {\n      throw new Error('Cannot upsert without ID');\n    }\n\n    const patchSerialised = serialiseRecord(value);\n    const sId = (await this.internalGetPossibleSerialisedIds(keyName, key))[0];\n    if (sId && patchSerialised.id && patchSerialised.id !== sId) {\n      throw new Error('Cannot update id');\n    }\n    const oldSerialised = await this.readByKey(sId, Object.keys(value) as any[]);\n    if (!oldSerialised) {\n      if (upsert) {\n        await this.add(Object.assign({ [keyName]: key }, value as T));\n      }\n      return;\n    }\n    await this.internalCheckKeyDuplicates(sId, patchSerialised);\n    await this.runMulti([\n      this.setByKey(sId, patchSerialised),\n      ...this.internalMigrateIndices(sId, oldSerialised, patchSerialised),\n    ]);\n  }\n\n  public async get<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    keyName: K,\n    key: T[K],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    const sId = (await this.internalGetPossibleSerialisedIds(keyName, key))[0];\n    const value = await this.readByKey(sId, fields);\n    if (!value) {\n      return null;\n    }\n    return deserialiseRecord(value) as T;\n  }\n\n  public async getAll<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    keyName?: K,\n    key?: T[K],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    let sIds: string[];\n    if (keyName) {\n      sIds = await this.internalGetPossibleSerialisedIds(keyName, key!);\n    } else {\n      sIds = await this.client.keys(this.makeKey('*'));\n      const cut = this.prefix.length + 1;\n      sIds = sIds.map((v) => v.substr(cut));\n    }\n    const items = await this.readByKeys(sIds, fields);\n    return items.map(deserialiseRecord) as T[];\n  }\n\n  public async remove<K extends keyof T & string>(\n    key: K,\n    value: T[K],\n  ): Promise<number> {\n    const indexedKeys = Object.keys(this.keyPrefixes) as any[];\n    indexedKeys.push('id');\n\n    const sIds = await this.internalGetPossibleSerialisedIds(key, value);\n    const items = await this.readByKeys(sIds, indexedKeys);\n    if (items.length === 0) {\n      return 0;\n    }\n\n    await this.runMulti([\n      ['del', ...items.map((item) => this.makeKey(item.id))],\n      ...items.flatMap((item) => this.internalMigrateIndices(item.id, item, {})),\n    ]);\n    return items.length;\n  }\n\n  private makeKey(serialisedId: string): string {\n    return `${this.prefix}:${serialisedId}`;\n  }\n\n  private setByKey(\n    serialisedId: string,\n    serialised: Record<string, string>,\n  ): string[] {\n    return [\n      'hmset',\n      this.makeKey(serialisedId),\n      ...Object.entries(serialised).flat(),\n    ];\n  }\n\n  private getByKey<F extends readonly (keyof T & string)[]>(\n    serialisedId: string,\n    fields?: F,\n  ): string[] {\n    const key = this.makeKey(serialisedId);\n    if (!fields) {\n      return ['hgetall', key];\n    }\n    return ['hmget', key, ...fields];\n  }\n\n  private async readByKey<F extends readonly (keyof T & string)[]>(\n    serialisedId?: string,\n    fields?: F,\n  ): Promise<Record<string, string> | undefined> {\n    if (serialisedId === undefined) {\n      return undefined;\n    }\n    const items = await this.readByKeys([serialisedId], fields);\n    return items[0];\n  }\n\n  private async readByKeys<F extends readonly (keyof T & string)[]>(\n    serialisedIds: string[],\n    fields?: F,\n  ): Promise<Record<string, string>[]> {\n    const results = await this.runMulti(serialisedIds.map((sId) => this.getByKey(sId, fields)));\n    let items;\n    if (fields) {\n      items = results.map(([, item]) => {\n        const result: any = {};\n        for (let f = 0; f < fields.length; f += 1) {\n          result[fields[f]] = item[f];\n        }\n        return result;\n      });\n    } else {\n      items = results.map(([, item]) => item);\n    }\n    return items.filter((item) => Object.values(item).some((v) => (v !== null)));\n  }\n\n  private async internalGetPossibleSerialisedIds<K extends keyof T>(\n    keyName: K,\n    key: T[K],\n  ): Promise<string[]> {\n    const sKey = serialiseValue(key);\n    if (keyName === 'id') {\n      return [sKey];\n    }\n    const keyPrefix = this.keyPrefixes[keyName];\n    if (!keyPrefix) {\n      throw new Error(`Requested key ${keyName} not indexed`);\n    }\n    return this.client.smembers(`${keyPrefix}:${sKey}`);\n  }\n\n  private async internalCheckKeyDuplicates(\n    serialisedId: string,\n    partialSerialisedValue: Record<string, string>,\n  ): Promise<void> {\n    const records = await this.runMulti(\n      this.uniqueKeys\n        .filter(({ key }) => partialSerialisedValue[key])\n        .map(({ key, prefix }) => (['smembers', `${prefix}:${partialSerialisedValue[key]}`])),\n    );\n    if (records.some(([, r]) => (r.length > 0 && r[0] !== serialisedId))) {\n      throw new Error('duplicate');\n    }\n  }\n\n  private internalMigrateIndices(\n    serialisedId: string,\n    partialOldSerialisedValue: Record<string, string>,\n    partialNewSerialisedValue: Record<string, string>,\n  ): (string[] | null)[] {\n    return this.keys.map(({ key, prefix }) => {\n      if (!partialNewSerialisedValue[key]) {\n        if (!partialOldSerialisedValue[key]) {\n          return null;\n        }\n        return [\n          'srem',\n          `${prefix}:${partialOldSerialisedValue[key]}`,\n          serialisedId,\n        ];\n      }\n      if (!partialOldSerialisedValue[key]) {\n        return [\n          'sadd',\n          `${prefix}:${partialNewSerialisedValue[key]}`,\n          serialisedId,\n        ];\n      }\n      return [\n        'smove',\n        `${prefix}:${partialOldSerialisedValue[key]}`,\n        `${prefix}:${partialNewSerialisedValue[key]}`,\n        serialisedId,\n      ];\n    });\n  }\n\n  // returned values are [error, result] for each command\n  private async runMulti(commands: (string[] | null)[]): Promise<[unknown, any][]> {\n    const filtered = commands.filter(<T>(c: T | null): c is T => (c !== null));\n    if (!filtered.length) {\n      return [];\n    }\n    return this.client.multi(filtered).exec();\n  }\n}\n","import { Redis } from 'ioredis';\nimport RedisCollection from './RedisCollection';\nimport DB, { DBKeys } from '../interfaces/DB';\nimport IDable from '../interfaces/IDable';\n\nexport default class RedisDb implements DB {\n  private constructor(\n    private readonly client: Redis,\n  ) {}\n\n  public static async connect(url: string): Promise<RedisDb> {\n    const { default: RedisStatic } = await import('ioredis');\n    const client = new RedisStatic(url, { lazyConnect: true });\n    await client.connect();\n    return new RedisDb(client);\n  }\n\n  public getCollection<T extends IDable>(\n    name: string,\n    keys?: DBKeys<T>,\n  ): RedisCollection<T> {\n    return new RedisCollection(this.client, name, keys);\n  }\n}\n","import IDable from '../interfaces/IDable';\nimport Collection, { UpdateOptions } from '../interfaces/Collection';\n\nexport type Wrapped<T extends IDable, WF extends keyof T, W> = {\n  [K in keyof T]: K extends 'id' ? T[K] : K extends WF ? W : T[K];\n};\n\nexport interface Wrapper<T extends IDable, K extends keyof T, W, E> {\n  wrap: (\n    key: K,\n    value: T[K],\n    processed: E,\n  ) => Promise<W> | W;\n\n  unwrap: (\n    key: K,\n    value: W,\n    processed: E,\n  ) => Promise<T[K]> | T[K];\n\n  preWrap?: (\n    record: Readonly<Partial<T>>,\n  ) => Promise<E> | E;\n\n  preUnwrap?: (\n    record: Readonly<Partial<Wrapped<T, K, W>>>,\n  ) => Promise<E> | E;\n\n  preRemove?: (\n    record: Readonly<Pick<Wrapped<T, K, W>, 'id'>>,\n  ) => Promise<void> | void;\n}\n\nfunction hasAnyField(value: object, fields: readonly string[]): boolean {\n  return fields\n    .some((field) => Object.prototype.hasOwnProperty.call(value, field));\n}\n\nexport default class WrappedCollection<\n  T extends IDable,\n  WF extends readonly (keyof Omit<T, 'id'> & string)[],\n  W,\n  E,\n  Inner extends Wrapped<T, WF[-1], W> = Wrapped<T, WF[-1], W>\n> implements Collection<T> {\n  public constructor(\n    private readonly baseCollection: Collection<Inner>,\n    private readonly fields: WF,\n    private readonly wrapper: Wrapper<T, WF[-1], W, E>,\n  ) {}\n\n  public async add(entry: T): Promise<void> {\n    return this.baseCollection.add(await this.wrapAll(entry));\n  }\n\n  public async get<\n    K extends keyof T & keyof Inner & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    key: K,\n    value: T[K] & Inner[K],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    if (this.fields.includes(key as any)) {\n      throw new Error('Cannot get by encrypted value');\n    }\n    const raw = await this.baseCollection.get(key, value, fields!);\n    return raw ? this.unwrapAll(raw, { [key]: value }) : null;\n  }\n\n  public async getAll<\n    K extends keyof T & keyof Inner & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    key?: K,\n    value?: T[K] & Inner[NonNullable<K>],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    if (key !== undefined && this.fields.includes(key as any)) {\n      throw new Error('Cannot get by encrypted value');\n    }\n    const raw = await this.baseCollection.getAll(key!, value!, fields!);\n    const extra = (key !== undefined) ? { [key]: value } : undefined;\n    return Promise.all(raw.map((v) => this.unwrapAll(v, extra)));\n  }\n\n  public async update<K extends keyof T & keyof Inner & string>(\n    key: K,\n    value: T[K] & Inner[K],\n    update: Partial<T>,\n    options?: UpdateOptions,\n  ): Promise<void> {\n    if (this.fields.includes(key as any)) {\n      throw new Error('Cannot update by encrypted value');\n    }\n    const converted = await this.wrapAll(update, { [key]: value });\n    return this.baseCollection.update(key, value, converted, options);\n  }\n\n  public async remove<K extends keyof T & string>(\n    key: K,\n    value: T[K] & Inner[K],\n  ): Promise<number> {\n    if (this.fields.includes(key as any)) {\n      throw new Error('Cannot remove by encrypted value');\n    }\n    if (!this.wrapper.preRemove) {\n      return this.baseCollection.remove(key, value);\n    }\n\n    const items = await this.baseCollection.getAll(key, value, ['id']);\n    await Promise.all(items.map(async (item) => {\n      await this.wrapper.preRemove!(item);\n      await this.baseCollection.remove('id', item.id);\n    }));\n    return items.length;\n  }\n\n  private async wrapAll(\n    v: Readonly<T>,\n    extra?: object,\n  ): Promise<Inner>;\n\n  private async wrapAll(\n    v: Readonly<Partial<T>>,\n    extra?: object,\n  ): Promise<Partial<Inner>>;\n\n  private async wrapAll(\n    v: Readonly<Partial<T>>,\n    extra?: object,\n  ): Promise<Partial<Inner>> {\n    let processed: E;\n    if (this.wrapper.preWrap && hasAnyField(v, this.fields)) {\n      const allFields = extra ? Object.assign({}, extra, v) : v;\n      processed = await this.wrapper.preWrap(allFields);\n    }\n    const converted = Object.assign({}, v) as any;\n    await Promise.all(this.fields.map(async (k) => {\n      if (Object.prototype.hasOwnProperty.call(v, k)) {\n        converted[k] = await this.wrapper.wrap(k, (v as any)[k], processed);\n      }\n    }));\n    return converted;\n  }\n\n  private async unwrapAll(\n    v: Readonly<Inner>,\n    extra?: object,\n  ): Promise<T>;\n\n  private async unwrapAll<K extends keyof T>(\n    v: Readonly<Pick<Inner, K>>,\n    extra?: object,\n  ): Promise<Pick<T, K>>;\n\n  private async unwrapAll<K extends keyof T>(\n    v: Readonly<Pick<Inner, K>>,\n    extra?: object,\n  ): Promise<Pick<T, K>> {\n    let processed: E;\n    if (this.wrapper.preUnwrap && hasAnyField(v, this.fields)) {\n      const allFields = extra ? Object.assign({}, extra, v) : v;\n      processed = await this.wrapper.preUnwrap(allFields as any);\n    }\n    const converted = Object.assign({}, v) as any;\n    await Promise.all(this.fields.map(async (k) => {\n      if (Object.prototype.hasOwnProperty.call(v, k)) {\n        converted[k] = await this.wrapper.unwrap(k, (v as any)[k], processed);\n      }\n    }));\n    return converted;\n  }\n}\n","export default class LruCache<K, V> {\n  private readonly storage = new Map<K, V>();\n\n  public constructor(\n    private readonly capacity: number,\n  ) {}\n\n  public set(key: K, value: V): void {\n    this.storage.delete(key);\n    this.storage.set(key, value);\n    this.flush();\n  }\n\n  public get(key: K): V | undefined {\n    const value = this.storage.get(key);\n    if (this.storage.delete(key)) {\n      this.storage.set(key, value!);\n    }\n    return value;\n  }\n\n  public remove(key: K): void {\n    this.storage.delete(key);\n  }\n\n  private flush(): void {\n    while (this.storage.size > this.capacity) {\n      this.storage.delete(this.storage.keys().next().value);\n    }\n  }\n}\n","import crypto, { KeyObject } from 'crypto';\nimport Encryption from './Encryption';\n\nconst ALG = 'aes-256-cbc';\nconst ALG_BUF = Buffer.from(`${ALG}:`, 'utf8');\nconst IV_LEN = 16;\n\nconst nodeEncryptionSync: Encryption<Buffer, KeyObject, Buffer> = {\n  encrypt: (key: KeyObject, v: string): Buffer => {\n    const iv = crypto.randomBytes(IV_LEN);\n    const cipher = crypto.createCipheriv(ALG, key, iv);\n    const part = cipher.update(v, 'utf8');\n    const final = cipher.final();\n    return Buffer.concat([ALG_BUF, iv, part, final]);\n  },\n\n  decrypt: (key: KeyObject, v: Buffer): string => {\n    if (!v.slice(0, ALG_BUF.length).equals(ALG_BUF)) {\n      throw new Error('Unknown encryption algorithm');\n    }\n\n    const iv = v.slice(ALG_BUF.length, ALG_BUF.length + IV_LEN);\n    const encrypted = v.slice(ALG_BUF.length + IV_LEN);\n\n    const decipher = crypto.createDecipheriv(ALG, key as any, iv);\n    let decrypted = decipher.update(encrypted, undefined, 'utf8');\n    decrypted += decipher.final('utf8');\n\n    return decrypted;\n  },\n\n  generateKey: (): KeyObject => crypto\n    .createSecretKey(crypto.randomBytes(32)),\n\n  serialiseKey: (key: KeyObject): Buffer => key.export(),\n\n  deserialiseKey: (data: Buffer): KeyObject => crypto.createSecretKey(data),\n};\n\nexport default nodeEncryptionSync;\n","import IDable, { IDableBy, IDType } from '../interfaces/IDable';\nimport Collection from '../interfaces/Collection';\nimport LruCache from '../helpers/LruCache';\nimport { serialiseValue, deserialiseValue } from '../helpers/serialiser';\nimport WrappedCollection, { Wrapped } from './WrappedCollection';\nimport Encryption from './encryption/Encryption';\nimport nodeEncryptionSync from './encryption/nodeEncryptionSync';\n\nexport interface KeyRecord<ID extends IDType, KeyT> {\n  id: ID;\n  key: KeyT;\n}\n\ntype EncryptableKeys<T> = readonly (keyof Omit<T, 'id'> & string)[];\n\ntype Encrypter<EncT, ID extends IDType> = <T extends IDableBy<ID>>(\n) => <F extends EncryptableKeys<T>>(\n  fields: F,\n  baseCollection: Collection<Wrapped<T, F[-1], EncT>>,\n) => Collection<T>;\n\n// makeEncrypter provides optional 2-tier function call due to\n// https://github.com/Microsoft/TypeScript/issues/26242\n\nfunction makeEncrypter<EncT, ID extends IDType>(\n  wrapper: <T extends IDableBy<ID>, F extends EncryptableKeys<T>>(\n    fields: F,\n    baseCollection: Collection<Wrapped<T, F[-1], EncT>>,\n  ) => Collection<T>,\n): Encrypter<EncT, ID> {\n  return (fields?: any, baseCollection?: Collection<any>): any => {\n    if (fields && baseCollection) {\n      // non-typescript API (remove need for extra ())\n      return wrapper(fields, baseCollection) as any;\n    }\n    return wrapper;\n  };\n}\n\nfunction encryptByKey(sKey: Buffer): Encrypter<Buffer, IDType>;\n\nfunction encryptByKey<EncT, KeyT, SerialisedKeyT>(\n  sKey: SerialisedKeyT,\n  cr: Encryption<EncT, KeyT, SerialisedKeyT>,\n): Encrypter<EncT, IDType>;\n\nfunction encryptByKey<EncT, KeyT, SerialisedKeyT>(\n  sKey: SerialisedKeyT,\n  cr: Encryption<EncT, KeyT, SerialisedKeyT> = nodeEncryptionSync as any,\n): Encrypter<EncT, IDType> {\n  const key = cr.deserialiseKey(sKey);\n\n  return makeEncrypter(<T extends IDable, F extends EncryptableKeys<T>>(\n    fields: F,\n    baseCollection: Collection<Wrapped<T, F[-1], EncT>>,\n  ) => new WrappedCollection<T, F, EncT, never>(baseCollection, fields, {\n    wrap: (k, v): Promise<EncT> | EncT => cr.encrypt(key, serialiseValue(v)),\n    unwrap: async (k, v): Promise<any> => deserialiseValue(await cr.decrypt(key, v)),\n  }));\n}\n\nfunction encryptByRecord<ID extends IDType>(\n  keyCollection: Collection<KeyRecord<ID, Buffer>>,\n  cacheSize?: number,\n): Encrypter<Buffer, ID>;\n\nfunction encryptByRecord<ID extends IDType, EncT, KeyT, SerialisedKeyT>(\n  keyCollection: Collection<KeyRecord<ID, SerialisedKeyT>>,\n  cacheSize: number,\n  cr: Encryption<EncT, KeyT, SerialisedKeyT>,\n): Encrypter<EncT, ID>;\n\nfunction encryptByRecord<ID extends IDType, EncT, KeyT, SerialisedKeyT>(\n  keyCollection: Collection<KeyRecord<ID, SerialisedKeyT>>,\n  cacheSize: number = 0,\n  cr: Encryption<EncT, KeyT, SerialisedKeyT> = nodeEncryptionSync as any,\n): Encrypter<EncT, ID> {\n  const cache = new LruCache<ID, KeyT>(cacheSize);\n\n  const loadKey = async (\n    generateIfNeeded: boolean,\n    record: { id?: ID },\n  ): Promise<KeyT> => {\n    const { id } = record;\n\n    if (id === undefined) {\n      throw new Error('Must provide ID for encryption');\n    }\n\n    const cached = cache.get(id);\n    if (cached) {\n      return cached;\n    }\n    let key: KeyT;\n    const item = await keyCollection.get('id', id, ['key']);\n    if (item) {\n      key = cr.deserialiseKey(item.key);\n    } else {\n      if (!generateIfNeeded) {\n        throw new Error('No encryption key found for record');\n      }\n      key = await cr.generateKey();\n      await keyCollection.add({ id, key: cr.serialiseKey(key) });\n    }\n    cache.set(id, key);\n    return key;\n  };\n\n  const removeKey = async ({ id }: { id: ID }): Promise<void> => {\n    await keyCollection.remove('id', id);\n    cache.remove(id);\n  };\n\n  return makeEncrypter(<T extends IDableBy<ID>, F extends EncryptableKeys<T>>(\n    fields: F,\n    baseCollection: Collection<Wrapped<T, F[-1], EncT>>,\n  ) => new WrappedCollection<T, F, EncT, KeyT>(baseCollection, fields, {\n    wrap: (k, v, key): Promise<EncT> | EncT => cr.encrypt(key, JSON.stringify(v)),\n    unwrap: async (k, v, key): Promise<any> => JSON.parse(await cr.decrypt(key, v)),\n    preWrap: loadKey.bind(null, true),\n    preUnwrap: loadKey.bind(null, false),\n    preRemove: removeKey,\n  }));\n}\n\nfunction encryptByRecordWithMasterKey<ID extends IDType>(\n  sMasterKey: Buffer,\n  keyCollection: Collection<KeyRecord<ID, Buffer>>,\n  cacheSize?: number,\n): Encrypter<Buffer, ID>;\n\nfunction encryptByRecordWithMasterKey<ID extends IDType, EncT, KeyT, SerialisedKeyT>(\n  sMasterKey: SerialisedKeyT,\n  keyCollection: Collection<KeyRecord<ID, EncT>>,\n  cacheSize: number,\n  cr: Encryption<EncT, KeyT, SerialisedKeyT>,\n): Encrypter<EncT, ID>;\n\nfunction encryptByRecordWithMasterKey<ID extends IDType, EncT, KeyT, SerialisedKeyT>(\n  sMasterKey: SerialisedKeyT,\n  keyCollection: Collection<KeyRecord<ID, EncT>>,\n  cacheSize: number = 0,\n  cr: Encryption<EncT, KeyT, SerialisedKeyT> = nodeEncryptionSync as any,\n): Encrypter<EncT, ID> {\n  const keyEnc = encryptByKey(sMasterKey, cr);\n  const encKeyCollection = keyEnc<KeyRecord<ID, SerialisedKeyT>>()(\n    ['key'],\n    keyCollection,\n  );\n  return encryptByRecord(encKeyCollection, cacheSize, cr);\n}\n\nexport {\n  encryptByKey,\n  encryptByRecord,\n  encryptByRecordWithMasterKey,\n};\n","import CollectionStorage from './CollectionStorage';\nimport WrappedCollection, { Wrapped } from './wrappers/WrappedCollection';\nimport Encryption from './wrappers/encryption/Encryption';\nimport {\n  encryptByKey,\n  encryptByRecord,\n  encryptByRecordWithMasterKey,\n} from './wrappers/encrypted';\nimport DB from './interfaces/DB';\nimport Collection from './interfaces/Collection';\nimport IDable from './interfaces/IDable';\n\nexport type DB = DB;\nexport type Collection<T extends IDable> = Collection<T>;\nexport type Wrapped<T extends IDable, WF extends keyof T, W> =\n  Wrapped<T, WF, W>;\nexport type Encrypted<T extends IDable, WF extends keyof T> =\n  Wrapped<T, WF, Buffer>;\nexport type Encryption<EncT, KeyT, SerialisedKeyT> =\n  Encryption<EncT, KeyT, SerialisedKeyT>;\n\nexport { default as MemoryDb } from './memory/MemoryDb';\nexport { default as MongoDb } from './mongo/MongoDb';\nexport { default as RedisDb } from './redis/RedisDb';\nexport { default as LruCache } from './helpers/LruCache';\nexport {\n  WrappedCollection,\n  encryptByKey,\n  encryptByRecord,\n  encryptByRecordWithMasterKey,\n};\nexport {\n  default as nodeEncryptionSync,\n} from './wrappers/encryption/nodeEncryptionSync';\nexport default CollectionStorage;\n","import MemoryDb from './memory/MemoryDb';\nimport MongoDb from './mongo/MongoDb';\nimport RedisDb from './redis/RedisDb';\nimport DB from './interfaces/DB';\n\nexport default class CollectionStorage {\n  public static async connect(url: string): Promise<DB> {\n    let dbClass;\n    if (url.startsWith('memory')) {\n      dbClass = MemoryDb;\n    } else if (url.startsWith('mongodb')) {\n      dbClass = MongoDb;\n    } else if (url.startsWith('redis')) {\n      dbClass = RedisDb;\n    } else {\n      throw new Error(`Unsupported database connection string: ${url}`);\n    }\n\n    try {\n      return await dbClass.connect(url);\n    } catch (e) {\n      throw new Error(`Failed to connect to database \"${url}\": ${e.message}`);\n    }\n  }\n}\n"],"sourceRoot":""}