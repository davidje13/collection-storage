{"version":3,"sources":["webpack://websocket-express/webpack/universalModuleDefinition","webpack://websocket-express/webpack/bootstrap","webpack://websocket-express/external \"crypto\"","webpack://websocket-express/external \"url\"","webpack://websocket-express/external \"mongodb\"","webpack://websocket-express/./src/memory/MemoryCollection.ts","webpack://websocket-express/./src/memory/MemoryDb.ts","webpack://websocket-express/./src/mongo/MongoCollection.ts","webpack://websocket-express/./src/mongo/MongoDb.ts","webpack://websocket-express/./src/wrappers/WrappedCollection.ts","webpack://websocket-express/./src/helpers/LruCache.ts","webpack://websocket-express/./src/wrappers/encryption/nodeEncryptionSync.ts","webpack://websocket-express/./src/wrappers/encrypted.ts","webpack://websocket-express/./src/index.ts","webpack://websocket-express/./src/CollectionStorage.ts"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","sleep","millis","Promise","resolve","setTimeout","MemoryCollection","constructor","keys","simulatedLatency","this","data","Map","forEach","k","keyList","push","map","options","internalCheckDuplicates","set","id","JSON","stringify","internalPopulateIndices","keyName","upsert","internalGetIds","undefined","add","assign","oldValue","parse","newValue","Error","internalRemoveIndices","e","fields","all","getAll","length","ids","result","field","applyFilter","delete","idKey","has","keyInfo","checkId","unique","v","Set","size","globalDbs","initial","existing","getGlobal","MemoryDb","url","parsedUrl","URL","hostname","params","searchParams","Number","db","getCollection","mapTables","MONGO_ID","ID","fieldNameToMongo","convertToMongo","rest","convertFromMongo","makeMongoFields","names","fieldName","MongoCollection","collection","createIndex","insertOne","updateOne","$set","findOne","projection","cursor","mFields","find","raw","deleteMany","deletedCount","MongoDb","MongoClient","client","connect","useNewUrlParser","useUnifiedTopology","hasAnyField","some","WrappedCollection","baseCollection","wrapper","entry","wrapAll","includes","unwrapAll","update","converted","preRemove","remove","items","async","item","processed","preWrap","wrap","preUnwrap","unwrap","LruCache","capacity","storage","flush","next","ALG","nodeEncryptionSync","encrypt","iv","crypto","randomBytes","cipher","createCipheriv","part","toString","final","decrypt","alg","encrypted","split","decipher","createDecipheriv","Buffer","from","decrypted","generateKey","createSecretKey","serialiseKey","export","deserialiseKey","encryptByKey","sKey","cr","encryptByRecord","keyCollection","cacheSize","cache","loadKey","generateIfNeeded","record","cached","encryptByRecordWithMasterKey","sMasterKey","CollectionStorage","dbClass","startsWith","message"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,oBAAqB,GAAIH,GACN,iBAAZC,QACdA,QAAQ,qBAAuBD,IAE/BD,EAAK,qBAAuBC,IAR9B,CASGK,OAAQ,WACX,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUP,QAGnC,IAAIC,EAASI,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHT,QAAS,IAUV,OANAU,EAAQH,GAAUI,KAAKV,EAAOD,QAASC,EAAQA,EAAOD,QAASM,GAG/DL,EAAOQ,GAAI,EAGJR,EAAOD,QA0Df,OArDAM,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASd,EAASe,EAAMC,GAC3CV,EAAoBW,EAAEjB,EAASe,IAClCG,OAAOC,eAAenB,EAASe,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAAStB,GACX,oBAAXuB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAenB,EAASuB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAenB,EAAS,aAAc,CAAEyB,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAAShC,GAChC,IAAIe,EAASf,GAAUA,EAAO2B,WAC7B,WAAwB,OAAO3B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAK,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,GAIjBhC,EAAoBA,EAAoBiC,EAAI,G,gBClFrDtC,EAAOD,QAAUwC,QAAQ,W,cCAzBvC,EAAOD,QAAUwC,QAAQ,Q,8CCAzBvC,EAAOD,QAAUwC,QAAQ,Y,uNCIzB,SAASC,EAAMC,GACb,OAAKA,EAKE,IAAIC,QAASC,GAAiBC,WAAWD,EAASF,IAJhD,KA0BI,MAAMI,EAOZC,YACLC,EAAkB,GACDC,EAAmB,GACpC,KADiBA,mBACjB,uCAPsC,IAOtC,cALmE,IAMnEC,KAAKC,KAAO,IAAIC,IAEhBlC,OAAO8B,KAAKA,GAAMK,QAASC,IACzB,MAAMvB,EAAMuB,EACZJ,KAAKK,QAAQC,KAAKzB,GAClBmB,KAAKF,KAAKjB,GAAO,CAAE0B,IAAK,IAAIL,IAAOM,QAASV,EAAKjB,MAIrD,UAAiBN,SACTgB,EAAMS,KAAKD,kBAEjBC,KAAKS,wBAAwBlC,GAAO,GACpCyB,KAAKC,KAAKS,IAAInC,EAAMoC,GAAIC,KAAKC,UAAUtC,IACvCyB,KAAKc,wBAAwBvC,GAG/B,aACEwC,EACAlC,EACAN,GACA,OAAEyC,GAAS,GAAU,UAEfzB,EAAMS,KAAKD,kBAEjB,MAAMY,EAAKX,KAAKiB,eAAeF,EAASlC,GAAK,GAC7C,QAAWqC,IAAPP,EAIF,YAHIK,SACIhB,KAAKmB,IAAInD,OAAOoD,OAAO,CAAE,CAACL,GAAUlC,GAAON,KAIrD,MAAM8C,EAAWT,KAAKU,MAAMtB,KAAKC,KAAK9B,IAAIwC,IACpCY,EAAWvD,OAAOoD,OAAO,GAAIC,EAAU9C,GAC7C,GAAIgD,EAASZ,KAAOU,EAASV,GAC3B,MAAM,IAAIa,MAAM,oBAElBxB,KAAKyB,sBAAsBJ,GAC3B,IACErB,KAAKS,wBAAwBc,GAAU,GACvC,MAAOG,GAEP,MADA1B,KAAKc,wBAAwBO,GACvBK,EAER1B,KAAKC,KAAKS,IAAIa,EAASZ,GAAIC,KAAKC,UAAUU,IAC1CvB,KAAKc,wBAAwBS,GAG/B,UAIER,EACAlC,EACA8C,GAEA,MAAMC,QAAY5B,KAAK6B,OAAOd,EAASlC,EAAK8C,GAC5C,OAAKC,EAAIE,OAGFF,EAAI,GAFF,KAKX,aAIEb,EACAlC,EACA8C,GAIA,IAAII,EAMJ,aARMxC,EAAMS,KAAKD,mBAIfgC,EADEhB,EACIf,KAAKiB,eAAeF,EAASlC,GAE7B,IAAImB,KAAKC,KAAKH,SAEXS,IAAKI,IA7GpB,SACEV,EACA0B,GAEA,IAAKA,EACH,OAAO1B,EAET,MAAM+B,EAAyB,GAI/B,OAHAL,EAAOxB,QAAS8B,IACdD,EAAOC,GAAShC,EAAKgC,KAEhBD,GAkGkBE,CACrBtB,KAAKU,MAAMtB,KAAKC,KAAK9B,IAAIwC,IACzBgB,IAIJ,aACE9C,EACAN,SAEMgB,EAAMS,KAAKD,kBAEjB,MAAMgC,EAAM/B,KAAKiB,eAAepC,EAAKN,GAOrC,OANAwD,EAAI5B,QAASQ,IACX,MAAMU,EAAWT,KAAKU,MAAMtB,KAAKC,KAAK9B,IAAIwC,IAC1CX,KAAKyB,sBAAsBJ,GAC3BrB,KAAKC,KAAKkC,OAAOxB,KAGZoB,EAAID,OAGLb,eACNF,EACAlC,GAEA,GAAgB,OAAZkC,EAAkB,CACpB,MAAMqB,EAAQvD,EACd,OAAOmB,KAAKC,KAAKoC,IAAID,GAAS,CAACA,GAAS,GAE1C,MAAME,EAAUtC,KAAKF,KAAKiB,GAC1B,IAAKuB,EACH,MAAM,IAAId,uBAAuBT,iBAEnC,MAAMgB,EAAMO,EAAQ/B,IAAIpC,IAAIU,GAC5B,OAAOkD,EAAM,IAAIA,GAAO,GAGlBtB,wBAAwBlC,EAAUgE,GACxC,GAAIA,GAAWvC,KAAKC,KAAKoC,IAAI9D,EAAMoC,IACjC,MAAM,IAAIa,MAAM,aAElBxB,KAAKK,QAAQF,QAAStB,IACpB,MAAM,IAAE0B,EAAF,QAAOC,GAAYR,KAAKF,KAAKjB,GACnC,GAAI2B,EAAQgC,QAAUjC,EAAI8B,IAAI9D,EAAMM,IAClC,MAAM,IAAI2C,MAAM,eAKdV,wBAAwBvC,GAC9ByB,KAAKK,QAAQF,QAAStB,IACpB,MAAM,IAAE0B,GAAQP,KAAKF,KAAKjB,GACpB4D,EAAIlE,EAAMM,GAChB,IAAId,EAAIwC,EAAIpC,IAAIsE,GACX1E,IACHA,EAAI,IAAI2E,IACRnC,EAAIG,IAAI+B,EAAG1E,IAEbA,EAAEoD,IAAI5C,EAAMoC,MAIRc,sBAAsBlD,GAC5ByB,KAAKK,QAAQF,QAAStB,IACpB,MAAM,IAAE0B,GAAQP,KAAKF,KAAKjB,GACpB4D,EAAIlE,EAAMM,GACVd,EAAIwC,EAAIpC,IAAIsE,GAClB1E,EAAEoE,OAAO5D,EAAMoC,IACV5C,EAAE4E,MACLpC,EAAI4B,OAAOM,M,wHCjLnB,MAAMG,EAVN,SAAsB/E,EAAcgF,GAClC,MAAMC,EAAY5F,OAAeW,GACjC,OAAIiF,IAIH5F,OAAeW,GAAQgF,EACjBA,GAGSE,CAChB,4BACA,IAAI7C,KAGS,MAAM8C,EAKZnD,aAAY,iBAAEE,EAAmB,GAAM,IAAI,qDAFrB,IAAIG,KAG/BF,KAAKD,iBAAmBA,EAG1B,eAAsBkD,GACpB,MAAMC,EAAY,IAAIC,MAAIF,GACpBpF,EAAOqF,EAAUE,SACvB,GAAIvF,GAAQ+E,EAAUP,IAAIxE,GACxB,OAAO+E,EAAUzE,IAAIN,GAEvB,MAAMwF,EAASH,EAAUI,aACnBvD,EAAmBwD,OAAOF,EAAOlF,IAAI,qBACrCqF,EAAK,IAAIR,EAAS,CAAEjD,qBAI1B,OAHIlC,GACF+E,EAAUlC,IAAI7C,EAAM2F,GAEfA,EAGFC,cACL5F,EACAiC,GAQA,OANKE,KAAK0D,UAAUrB,IAAIxE,IACtBmC,KAAK0D,UAAUhD,IAAI7C,EAAM,IAAI+B,EAC3BE,EACAE,KAAKD,mBAGFC,KAAK0D,UAAUvF,IAAIN,I,m2CCjD9B,MAAM8F,EAAW,MACXC,EAAK,KAIX,SAASC,EAAiBhG,GACxB,OAAIA,IAAS+F,EACJD,EAEF9F,EAGT,SAASiG,EAA0CvF,GACjD,IAAKA,QAAuB2C,IAAd3C,EAAMqF,GAClB,OAAOrF,EAET,MAAQ,CAACqF,GAAKjD,GAAgBpC,EAATwF,EAArB,EAA8BxF,EAA9B,CAASqF,GAAT,QACA,UAAS,CAACD,GAAWhD,GAAOoD,GAG9B,SAASC,EACPzF,GAEA,IAAKA,QAA6B2C,IAApB3C,EAAMoF,GAClB,OAAOpF,EAET,MAAQ,CAACoF,GAAWhD,GAAgBpC,EAATwF,EAA3B,EAAoCxF,EAApC,CAASoF,GAAT,QACA,UAAS,CAACC,GAAKjD,GAAOoD,GAGxB,SAASE,EAAgBC,GACvB,MAAMvC,EAAkC,GAOxC,OANIuC,IACFvC,EAAOgC,IAAY,EACnBO,EAAM/D,QAASgE,IACbxC,EAAOkC,EAAiBM,KAAc,KAGnCxC,EAGM,MAAMyC,EACZvE,YACYwE,EACjBvE,EAAkB,IAClB,KAFiBuE,aAGjBrG,OAAO8B,KAAKA,GAAMK,QAASC,IACzB,MAAMW,EAAUX,EACVI,EAAUV,EAAKiB,GACjBP,GAAWA,EAAQgC,OACrB6B,EAAWC,YAAY,CAAE,CAACvD,GAAU,GAAK,CAAEyB,QAAQ,IAEnD6B,EAAWC,YAAY,CAAE,CAACvD,GAAU,aAK1C,UAAiBxC,SACTyB,KAAKqE,WAAWE,UAAUT,EAAevF,IAGjD,aACEwC,EACAlC,EACAN,GACA,OAAEyC,GAAS,GAAU,UAEfhB,KAAKqE,WAAWG,UACpB,CAAE,CAACX,EAAiB9C,IAAWlC,GAC/B,CAAE4F,KAAMX,EAAevF,IACvB,CAAEyC,WAIN,UAIED,EACAlC,EACA8C,GAMA,OAAOqC,QAJWhE,KAAKqE,WAAWK,QAChC,CAAE,CAACb,EAAiB9C,IAAWlC,GAC/B,CAAE8F,WAAYV,EAAgBtC,MAKlC,aAIEZ,EACAlC,EACA8C,GAEA,MAAMK,EAA2B,GAEjC,IAAI4C,EACJ,MAAMC,EAAUZ,EAAgBtC,GAWhC,OATEiD,EADE7D,EACOf,KAAKqE,WAAWS,KACvB,CAAE,CAACjB,EAAiB9C,IAAWlC,GAC/B,CAAE8F,WAAYE,IAGP7E,KAAKqE,WAAWS,KAAQ,GAAI,CAAEH,WAAYE,UAE/CD,EAAOzE,QAAS4E,GAAQ/C,EAAO1B,KAAK0D,EAAoBe,KAEvD/C,EAGT,aACEnD,EACAN,GAKA,aAHqByB,KAAKqE,WAAWW,WACnC,CAAE,CAACnB,EAAiBhF,IAAON,KAEf0G,cAAgB,GCzHnB,MAAMC,EACXrF,YACW2D,GACjB,KADiBA,KAGnB,qBAA4BP,GAC1B,MAAM,YAAEkC,SAAsB,QAAN,qBAAa,IAC/BC,QAAeD,EAAYE,QAAQpC,EAAK,CAC5CqC,iBAAiB,EACjBC,oBAAoB,IAEtB,OAAO,IAAIL,EAAQE,EAAO5B,MAGrBC,cACL5F,EACAiC,GAEA,MAAMuE,EAAarE,KAAKwD,GAAGa,WAAWxG,GACtC,OAAO,IAAIuG,EAAgBC,EAAYvE,ICS3C,SAAS0F,EAAYjH,EAAeoD,GAClC,OAAOA,EACJ8D,KAAMxD,GAAUjE,OAAOkB,UAAUC,eAAe1B,KAAKc,EAAO0D,IAGlD,MAAMyD,EAOZ7F,YACY8F,EACAhE,EACAiE,GACjB,KAHiBD,iBAGjB,KAFiBhE,SAEjB,KADiBiE,UAGnB,UAAiBC,GACf,OAAO7F,KAAK2F,eAAexE,UAAUnB,KAAK8F,QAAQD,IAGpD,UAIEhH,EACAN,EACAoD,GAEA,GAAI3B,KAAK2B,OAAOoE,SAASlH,GACvB,MAAM,IAAI2C,MAAM,iCAElB,MAAMuD,QAAY/E,KAAK2F,eAAexH,IAAIU,EAAKN,EAAOoD,GACtD,OAAOoD,EAAM/E,KAAKgG,UAAUjB,GAAO,KAGrC,aAIElG,EACAN,EACAoD,GAEA,QAAYT,IAARrC,GAAqBmB,KAAK2B,OAAOoE,SAASlH,GAC5C,MAAM,IAAI2C,MAAM,iCAElB,MAAMuD,QAAY/E,KAAK2F,eAAe9D,OAAOhD,EAAMN,EAAQoD,GAC3D,OAAOlC,QAAQmC,IAAImD,EAAIxE,IAAKkC,GAAMzC,KAAKgG,UAAUvD,KAGnD,aACE5D,EACAN,EACA0H,EACAzF,GAEA,GAAIR,KAAK2B,OAAOoE,SAASlH,GACvB,MAAM,IAAI2C,MAAM,oCAElB,MAAM0E,QAAkBlG,KAAK8F,QAAQG,GACrC,OAAOjG,KAAK2F,eAAeM,OAAOpH,EAAKN,EAAO2H,EAAW1F,GAG3D,aACE3B,EACAN,GAEA,GAAIyB,KAAK2B,OAAOoE,SAASlH,GACvB,MAAM,IAAI2C,MAAM,oCAElB,IAAKxB,KAAK4F,QAAQO,UAChB,OAAOnG,KAAK2F,eAAeS,OAAOvH,EAAKN,GAGzC,MAAM8H,QAAcrG,KAAK2F,eAAe9D,OAAOhD,EAAKN,EAAO,CAAC,OAK5D,aAJMkB,QAAQmC,IAAIyE,EAAM9F,IAAI+F,gBACpBtG,KAAK4F,QAAQO,UAAWI,SACxBvG,KAAK2F,eAAeS,OAAO,KAAMG,EAAK5F,OAEvC0F,EAAMvE,OASf,cACEW,GAEA,IAAI+D,EACAxG,KAAK4F,QAAQa,SAAWjB,EAAY/C,EAAGzC,KAAK2B,UAC9C6E,QAAkBxG,KAAK4F,QAAQa,QAAQhE,IAEzC,MAAMyD,EAAYlI,OAAOoD,OAAO,GAAIqB,GAMpC,aALMhD,QAAQmC,IAAI5B,KAAK2B,OAAOpB,IAAI+F,UAC5BtI,OAAOkB,UAAUC,eAAe1B,KAAKgF,EAAGrC,KAC1C8F,EAAU9F,SAAWJ,KAAK4F,QAAQc,KAAKtG,EAAIqC,EAAUrC,GAAIoG,OAGtDN,EAST,gBACEzD,GAEA,IAAI+D,EACAxG,KAAK4F,QAAQe,WAAanB,EAAY/C,EAAGzC,KAAK2B,UAChD6E,QAAkBxG,KAAK4F,QAAQe,UAAUlE,IAE3C,MAAMyD,EAAYlI,OAAOoD,OAAO,GAAIqB,GAMpC,aALMhD,QAAQmC,IAAI5B,KAAK2B,OAAOpB,IAAI+F,UAC5BtI,OAAOkB,UAAUC,eAAe1B,KAAKgF,EAAGrC,KAC1C8F,EAAU9F,SAAWJ,KAAK4F,QAAQgB,OAAOxG,EAAIqC,EAAUrC,GAAIoG,OAGxDN,G,eC9JI,MAAMW,EAGZhH,YACYiH,G,UACjB,KADiBA,W,EACjB,K,EAAA,U,EAJyB,IAAI5G,I,6FAMxBQ,IAAI7B,EAAQN,GACjByB,KAAK+G,QAAQ5E,OAAOtD,GACpBmB,KAAK+G,QAAQrG,IAAI7B,EAAKN,GACtByB,KAAKgH,QAGA7I,IAAIU,GACT,MAAMN,EAAQyB,KAAK+G,QAAQ5I,IAAIU,GAI/B,OAHImB,KAAK+G,QAAQ5E,OAAOtD,IACtBmB,KAAK+G,QAAQrG,IAAI7B,EAAKN,GAEjBA,EAGF6H,OAAOvH,GACZmB,KAAK+G,QAAQ5E,OAAOtD,GAGdmI,QACN,KAAOhH,KAAK+G,QAAQpE,KAAO3C,KAAK8G,UAC9B9G,KAAK+G,QAAQ5E,OAAOnC,KAAK+G,QAAQjH,OAAOmH,OAAO1I,Q,oBCxBrD,MAAM2I,EAAM,cAqCGC,MAnCmC,CAChDC,QAAS,CAACvI,EAAgB4D,KACxB,MAAM4E,EAAKC,IAAOC,YAAY,IACxBC,EAASF,IAAOG,eAAeP,EAAKrI,EAAKwI,GACzCK,EAAOF,EAAOvB,OAAOxD,EAAG,OAAQ,UACtC,SAAUyE,KAAOG,EAAGM,SAAS,aAAaD,IAAOF,EAAOI,MAAM,aAGhEC,QAAS,CAAChJ,EAAgB4D,KACxB,MAAOqF,EAAKT,EAAIU,GAAatF,EAAEuF,MAAM,KAErC,GAAIF,IAAQZ,EACV,MAAM,IAAI1F,MAAM,gCAGlB,MAAMyG,EAAWX,IAAOY,iBACtBhB,EACArI,EACAsJ,OAAOC,KAAKf,EAAI,WAElB,IAAIgB,EAAYJ,EAAShC,OAAO8B,EAAW,SAAU,QAGrD,OAFAM,GAAaJ,EAASL,MAAM,SAK9BU,YAAa,IAAiBhB,IAC3BiB,gBAAgBjB,IAAOC,YAAY,KAEtCiB,aAAe3J,GAA2BA,EAAI4J,SAASd,SAAS,UAEhEe,eAAiBzI,GAA4BqH,IAC1CiB,gBAAgBJ,OAAOC,KAAKnI,EAAM,YCzBhC,MAAM0I,EAAe,CAC1BC,EACAC,EAA0B1B,IACvB,CACHxF,EACAgE,KAEA,MAAM9G,EAAMgK,EAAGH,eAAeE,GAE9B,OAAO,IAAIlD,EAAuCC,EAAgBhE,EAAQ,CACxE+E,KAAM,CAACtG,EAAGqC,IAAgCoG,EAAGzB,QAAQvI,EAAK+B,KAAKC,UAAU4B,IACzEmE,OAAQN,MAAOlG,EAAGqC,IAAoB7B,KAAKU,YAAYuH,EAAGhB,QAAQhJ,EAAK4D,OAI9DqG,EAAkB,CAC7BC,EACAC,EAAoB,EACpBH,EAA0B1B,IACvB,CACHxF,EACAgE,KAEA,MAAMsD,EAAQ,IAAIpC,EAA2BmC,GAEvCE,EAAU5C,MACd6C,EACAC,KAEA,MAAM,GAAEzI,GAAOyI,EAEf,QAAWlI,IAAPP,EACF,MAAM,IAAIa,MAAM,kCAGlB,MAAM6H,EAASJ,EAAM9K,IAAIwC,GACzB,GAAI0I,EACF,OAAOA,EAET,IAAIxK,EACJ,MAAM0H,QAAawC,EAAc5K,IAAI,KAAMwC,EAAI,CAAC,QAChD,GAAI4F,EACF1H,EAAMgK,EAAGH,eAAenC,EAAK1H,SACxB,CACL,IAAKsK,EACH,MAAM,IAAI3H,MAAM,sCAElB3C,QAAYgK,EAAGP,oBACTS,EAAc5H,IAAI,CAAER,KAAI9B,IAAKgK,EAAGL,aAAa3J,KAGrD,OADAoK,EAAMvI,IAAIC,EAAI9B,GACPA,GAQT,OAAO,IAAI6G,EAAyCC,EAAgBhE,EAAQ,CAC1E+E,KAAM,CAACtG,EAAGqC,EAAG5D,IAAkCgK,EAAGzB,QAAQvI,EAAK+B,KAAKC,UAAU4B,IAC9EmE,OAAQN,MAAOlG,EAAGqC,EAAG5D,IAAsB+B,KAAKU,YAAYuH,EAAGhB,QAAQhJ,EAAK4D,IAC5EgE,QAASyC,EAAQpK,KAAK,MAAM,GAC5B6H,UAAWuC,EAAQpK,KAAK,MAAM,GAC9BqH,UAVgBG,OAAS3F,eACnBoI,EAAc3C,OAAO,KAAMzF,GACjCsI,EAAM7C,OAAOzF,OAYJ2I,EAA+B,CAC1CC,EACAR,EACAC,EAAoB,EACpBH,EAA0B1B,IACvB,CACHxF,EACAgE,IACkBmD,EAClBH,EAAiCY,EAAYV,EAA7CF,CAAiD,CAAC,OAAQI,GAC1DC,EACAH,EAHkBC,CAIlBnH,EAAQgE,GC5FV,yWAwBe6D,UCpBA,MACb,qBAA4BvG,GAC1B,IAAIwG,EACJ,GAAIxG,EAAIyG,WAAW,UACjBD,EAAUzG,MACL,KAAIC,EAAIyG,WAAW,WAGxB,MAAM,IAAIlI,iDAAiDyB,KAF3DwG,EAAUvE,EAKZ,IACE,aAAauE,EAAQpE,QAAQpC,GAC7B,MAAOvB,GACP,MAAM,IAAIF,wCAAwCyB,OAASvB,EAAEiI","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"websocket-express\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"websocket-express\"] = factory();\n\telse\n\t\troot[\"websocket-express\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = require(\"crypto\");","module.exports = require(\"url\");","module.exports = require(\"mongodb\");","import Collection, { KeyOptions } from '../interfaces/Collection';\nimport IDable from '../interfaces/IDable';\nimport { DBKeys } from '../interfaces/DB';\n\nfunction sleep(millis: number): Promise<void> | null {\n  if (!millis) {\n    return null;\n  }\n\n  // Simulate data access delays to ensure non-flakey e2e tests, etc.\n  return new Promise((resolve): any => setTimeout(resolve, millis));\n}\n\nfunction applyFilter<T, F extends readonly (keyof T)[]>(\n  data: T,\n  fields?: F,\n): Pick<T, F[-1]> {\n  if (!fields) {\n    return data;\n  }\n  const result: Pick<T, F[-1]> = {} as any;\n  fields.forEach((field) => {\n    result[field] = data[field];\n  });\n  return result;\n}\n\ninterface KeyInfo<ID, T> {\n  map: Map<T, Set<ID>>;\n  options: KeyOptions;\n}\n\nexport default class MemoryCollection<T extends IDable> implements Collection<T> {\n  private readonly data: Map<T['id'], string>;\n\n  private readonly keyList: (keyof T)[] = [];\n\n  private readonly keys: { [K in keyof T]?: KeyInfo<T['id'], T[K]> } = {};\n\n  public constructor(\n    keys: DBKeys<T> = {},\n    private readonly simulatedLatency = 0,\n  ) {\n    this.data = new Map();\n\n    Object.keys(keys).forEach((k) => {\n      const key = k as keyof DBKeys<T>;\n      this.keyList.push(key);\n      this.keys[key] = { map: new Map(), options: keys[key]! };\n    });\n  }\n\n  public async add(value: T): Promise<void> {\n    await sleep(this.simulatedLatency);\n\n    this.internalCheckDuplicates(value, true);\n    this.data.set(value.id, JSON.stringify(value));\n    this.internalPopulateIndices(value);\n  }\n\n  public async update<K extends keyof T & string>(\n    keyName: K,\n    key: T[K],\n    value: Partial<T>,\n    { upsert = false } = {},\n  ): Promise<void> {\n    await sleep(this.simulatedLatency);\n\n    const id = this.internalGetIds(keyName, key)[0];\n    if (id === undefined) {\n      if (upsert) {\n        await this.add(Object.assign({ [keyName]: key }, value as T));\n      }\n      return;\n    }\n    const oldValue = JSON.parse(this.data.get(id)!) as T;\n    const newValue = Object.assign({}, oldValue, value);\n    if (newValue.id !== oldValue.id) {\n      throw new Error('Cannot update id');\n    }\n    this.internalRemoveIndices(oldValue);\n    try {\n      this.internalCheckDuplicates(newValue, false);\n    } catch (e) {\n      this.internalPopulateIndices(oldValue);\n      throw e;\n    }\n    this.data.set(newValue.id, JSON.stringify(newValue));\n    this.internalPopulateIndices(newValue);\n  }\n\n  public async get<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    keyName: K,\n    key: T[K],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    const all = await this.getAll(keyName, key, fields);\n    if (!all.length) {\n      return null;\n    }\n    return all[0];\n  }\n\n  public async getAll<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    keyName?: K,\n    key?: T[K],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    await sleep(this.simulatedLatency);\n\n    let ids: T['id'][];\n    if (keyName) {\n      ids = this.internalGetIds(keyName, key!);\n    } else {\n      ids = [...this.data.keys()];\n    }\n    return ids.map((id) => applyFilter(\n      JSON.parse(this.data.get(id)!),\n      fields,\n    ));\n  }\n\n  public async remove<K extends keyof T & string>(\n    key: K,\n    value: T[K],\n  ): Promise<number> {\n    await sleep(this.simulatedLatency);\n\n    const ids = this.internalGetIds(key, value);\n    ids.forEach((id) => {\n      const oldValue = JSON.parse(this.data.get(id)!) as T;\n      this.internalRemoveIndices(oldValue);\n      this.data.delete(id);\n    });\n\n    return ids.length;\n  }\n\n  private internalGetIds<K extends keyof T>(\n    keyName: K,\n    key: T[K],\n  ): T['id'][] {\n    if (keyName === 'id') {\n      const idKey = key as T['id'];\n      return this.data.has(idKey) ? [idKey] : [];\n    }\n    const keyInfo = this.keys[keyName];\n    if (!keyInfo) {\n      throw new Error(`Requested key ${keyName} not indexed`);\n    }\n    const ids = keyInfo.map.get(key);\n    return ids ? [...ids] : []; // convert set to array\n  }\n\n  private internalCheckDuplicates(value: T, checkId: boolean): void {\n    if (checkId && this.data.has(value.id)) {\n      throw new Error('duplicate');\n    }\n    this.keyList.forEach((key) => {\n      const { map, options } = this.keys[key]!;\n      if (options.unique && map.has(value[key])) {\n        throw new Error('duplicate');\n      }\n    });\n  }\n\n  private internalPopulateIndices(value: T): void {\n    this.keyList.forEach((key) => {\n      const { map } = this.keys[key]!;\n      const v = value[key];\n      let o = map.get(v);\n      if (!o) {\n        o = new Set<T['id']>();\n        map.set(v, o);\n      }\n      o.add(value.id);\n    });\n  }\n\n  private internalRemoveIndices(value: T): void {\n    this.keyList.forEach((key) => {\n      const { map } = this.keys[key]!;\n      const v = value[key];\n      const o = map.get(v)!;\n      o.delete(value.id);\n      if (!o.size) {\n        map.delete(v);\n      }\n    });\n  }\n}\n","import { URL } from 'url';\nimport MemoryCollection from './MemoryCollection';\nimport DB, { DBKeys } from '../interfaces/DB';\nimport IDable from '../interfaces/IDable';\n\nfunction getGlobal<T>(name: string, initial: T): T {\n  const existing = (global as any)[name];\n  if (existing) {\n    return existing;\n  }\n\n  (global as any)[name] = initial;\n  return initial;\n}\n\nconst globalDbs = getGlobal(\n  'collectionStorageInMemory',\n  new Map<string, MemoryDb>(),\n);\n\nexport default class MemoryDb implements DB {\n  private readonly simulatedLatency: number;\n\n  private readonly mapTables = new Map<string, MemoryCollection<any>>();\n\n  public constructor({ simulatedLatency = 0 } = {}) {\n    this.simulatedLatency = simulatedLatency;\n  }\n\n  public static connect(url: string): MemoryDb {\n    const parsedUrl = new URL(url);\n    const name = parsedUrl.hostname;\n    if (name && globalDbs.has(name)) {\n      return globalDbs.get(name)!;\n    }\n    const params = parsedUrl.searchParams;\n    const simulatedLatency = Number(params.get('simulatedLatency'));\n    const db = new MemoryDb({ simulatedLatency });\n    if (name) {\n      globalDbs.set(name, db);\n    }\n    return db;\n  }\n\n  public getCollection<T extends IDable>(\n    name: string,\n    keys?: DBKeys<T>,\n  ): MemoryCollection<T> {\n    if (!this.mapTables.has(name)) {\n      this.mapTables.set(name, new MemoryCollection(\n        keys,\n        this.simulatedLatency,\n      ));\n    }\n    return this.mapTables.get(name)! as MemoryCollection<T>;\n  }\n}\n","import { Collection as MCollection, Cursor as MCursor } from 'mongodb';\nimport IDable from '../interfaces/IDable';\nimport Collection from '../interfaces/Collection';\nimport { DBKeys } from '../interfaces/DB';\n\nconst MONGO_ID = '_id';\nconst ID = 'id';\n\ntype MongoT<T extends Partial<IDable>> = Omit<T, 'id'> & { _id?: T['id'] };\n\nfunction fieldNameToMongo(name: string): string {\n  if (name === ID) {\n    return MONGO_ID;\n  }\n  return name;\n}\n\nfunction convertToMongo<T extends Partial<IDable>>(value: T): MongoT<T> {\n  if (!value || value[ID] === undefined) {\n    return value;\n  }\n  const { [ID]: id, ...rest } = value;\n  return { [MONGO_ID]: id, ...rest };\n}\n\nfunction convertFromMongo<T extends Partial<IDable>>(\n  value: MongoT<T> | null,\n): T | null {\n  if (!value || value[MONGO_ID] === undefined) {\n    return value as T | null;\n  }\n  const { [MONGO_ID]: id, ...rest } = value;\n  return { [ID]: id, ...rest } as any;\n}\n\nfunction makeMongoFields(names?: readonly string[]): Record<string, boolean> {\n  const fields: Record<string, boolean> = {};\n  if (names) {\n    fields[MONGO_ID] = false;\n    names.forEach((fieldName) => {\n      fields[fieldNameToMongo(fieldName)] = true;\n    });\n  }\n  return fields;\n}\n\nexport default class MongoCollection<T extends IDable> implements Collection<T> {\n  public constructor(\n    private readonly collection: MCollection,\n    keys: DBKeys<T> = {},\n  ) {\n    Object.keys(keys).forEach((k) => {\n      const keyName = k as keyof DBKeys<T>;\n      const options = keys[keyName];\n      if (options && options.unique) {\n        collection.createIndex({ [keyName]: 1 }, { unique: true });\n      } else {\n        collection.createIndex({ [keyName]: 'hashed' });\n      }\n    });\n  }\n\n  public async add(value: T): Promise<void> {\n    await this.collection.insertOne(convertToMongo(value));\n  }\n\n  public async update<K extends keyof T & string>(\n    keyName: K,\n    key: T[K],\n    value: Partial<T>,\n    { upsert = false } = {},\n  ): Promise<void> {\n    await this.collection.updateOne(\n      { [fieldNameToMongo(keyName)]: key },\n      { $set: convertToMongo(value) },\n      { upsert },\n    );\n  }\n\n  public async get<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    keyName: K,\n    key: T[K],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    const raw = await this.collection.findOne<T>(\n      { [fieldNameToMongo(keyName)]: key },\n      { projection: makeMongoFields(fields) },\n    );\n    return convertFromMongo<T>(raw);\n  }\n\n  public async getAll<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    keyName?: K,\n    key?: T[K],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    const result: Pick<T, F[-1]>[] = [];\n\n    let cursor: MCursor<T>;\n    const mFields = makeMongoFields(fields);\n    if (keyName) {\n      cursor = this.collection.find<T>(\n        { [fieldNameToMongo(keyName)]: key },\n        { projection: mFields },\n      );\n    } else {\n      cursor = this.collection.find<T>({}, { projection: mFields });\n    }\n    await cursor.forEach((raw) => result.push(convertFromMongo<T>(raw)!));\n\n    return result;\n  }\n\n  public async remove<K extends keyof T & string>(\n    key: K,\n    value: T[K],\n  ): Promise<number> {\n    const result = await this.collection.deleteMany(\n      { [fieldNameToMongo(key)]: value },\n    );\n    return result.deletedCount || 0;\n  }\n}\n","import { Db as MDb } from 'mongodb';\nimport MongoCollection from './MongoCollection';\nimport DB, { DBKeys } from '../interfaces/DB';\nimport IDable from '../interfaces/IDable';\n\nexport default class MongoDb implements DB {\n  private constructor(\n    private readonly db: MDb,\n  ) {}\n\n  public static async connect(url: string): Promise<MongoDb> {\n    const { MongoClient } = await import('mongodb');\n    const client = await MongoClient.connect(url, {\n      useNewUrlParser: true,\n      useUnifiedTopology: true,\n    });\n    return new MongoDb(client.db());\n  }\n\n  public getCollection<T extends IDable>(\n    name: string,\n    keys?: DBKeys<T>,\n  ): MongoCollection<T> {\n    const collection = this.db.collection(name);\n    return new MongoCollection(collection, keys);\n  }\n}\n","import IDable from '../interfaces/IDable';\nimport Collection, { UpdateOptions } from '../interfaces/Collection';\n\nexport type Wrapped<T extends IDable, WF extends keyof T, W> = {\n  [K in keyof T]: K extends 'id' ? T[K] : K extends WF ? W : T[K];\n};\n\nexport interface Wrapper<T extends IDable, K extends keyof T, W, E> {\n  wrap: (\n    key: K,\n    value: T[K],\n    processed: E,\n  ) => Promise<W> | W;\n\n  unwrap: (\n    key: K,\n    value: W,\n    processed: E,\n  ) => Promise<T[K]> | T[K];\n\n  preWrap?: (\n    record: Readonly<Partial<T>>,\n  ) => Promise<E> | E;\n\n  preUnwrap?: (\n    record: Readonly<Partial<Wrapped<T, K, W>>>,\n  ) => Promise<E> | E;\n\n  preRemove?: (\n    record: Readonly<Pick<Wrapped<T, K, W>, 'id'>>,\n  ) => Promise<void> | void;\n}\n\nfunction hasAnyField(value: object, fields: readonly string[]): boolean {\n  return fields\n    .some((field) => Object.prototype.hasOwnProperty.call(value, field));\n}\n\nexport default class WrappedCollection<\n  T extends IDable,\n  WF extends readonly (keyof Omit<T, 'id'> & string)[],\n  W,\n  E,\n  Inner extends Wrapped<T, WF[-1], W> = Wrapped<T, WF[-1], W>\n> implements Collection<T> {\n  public constructor(\n    private readonly baseCollection: Collection<Inner>,\n    private readonly fields: WF,\n    private readonly wrapper: Wrapper<T, WF[-1], W, E>,\n  ) {}\n\n  public async add(entry: T): Promise<void> {\n    return this.baseCollection.add(await this.wrapAll(entry));\n  }\n\n  public async get<\n    K extends keyof T & keyof Inner & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    key: K,\n    value: T[K] & Inner[K],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    if (this.fields.includes(key as any)) {\n      throw new Error('Cannot get by encrypted value');\n    }\n    const raw = await this.baseCollection.get(key, value, fields!);\n    return raw ? this.unwrapAll(raw) : null;\n  }\n\n  public async getAll<\n    K extends keyof T & keyof Inner & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    key?: K,\n    value?: T[K] & Inner[NonNullable<K>],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    if (key !== undefined && this.fields.includes(key as any)) {\n      throw new Error('Cannot get by encrypted value');\n    }\n    const raw = await this.baseCollection.getAll(key!, value!, fields!);\n    return Promise.all(raw.map((v) => this.unwrapAll(v)));\n  }\n\n  public async update<K extends keyof T & keyof Inner & string>(\n    key: K,\n    value: T[K] & Inner[K],\n    update: Partial<T>,\n    options?: UpdateOptions,\n  ): Promise<void> {\n    if (this.fields.includes(key as any)) {\n      throw new Error('Cannot update by encrypted value');\n    }\n    const converted = await this.wrapAll(update);\n    return this.baseCollection.update(key, value, converted, options);\n  }\n\n  public async remove<K extends keyof T & string>(\n    key: K,\n    value: T[K] & Inner[K],\n  ): Promise<number> {\n    if (this.fields.includes(key as any)) {\n      throw new Error('Cannot remove by encrypted value');\n    }\n    if (!this.wrapper.preRemove) {\n      return this.baseCollection.remove(key, value);\n    }\n\n    const items = await this.baseCollection.getAll(key, value, ['id']);\n    await Promise.all(items.map(async (item) => {\n      await this.wrapper.preRemove!(item);\n      await this.baseCollection.remove('id', item.id);\n    }));\n    return items.length;\n  }\n\n  private async wrapAll(v: Readonly<T>): Promise<Inner>;\n\n  private async wrapAll(\n    v: Readonly<Partial<T>>,\n  ): Promise<Partial<Inner>>;\n\n  private async wrapAll(\n    v: Readonly<Partial<T>>,\n  ): Promise<Partial<Inner>> {\n    let processed: E;\n    if (this.wrapper.preWrap && hasAnyField(v, this.fields)) {\n      processed = await this.wrapper.preWrap(v);\n    }\n    const converted = Object.assign({}, v) as any;\n    await Promise.all(this.fields.map(async (k) => {\n      if (Object.prototype.hasOwnProperty.call(v, k)) {\n        converted[k] = await this.wrapper.wrap(k, (v as any)[k], processed);\n      }\n    }));\n    return converted;\n  }\n\n  private async unwrapAll(v: Readonly<Inner>): Promise<T>;\n\n  private async unwrapAll<K extends keyof T>(\n    v: Readonly<Pick<Inner, K>>,\n  ): Promise<Pick<T, K>>;\n\n  private async unwrapAll<K extends keyof T>(\n    v: Readonly<Pick<Inner, K>>,\n  ): Promise<Pick<T, K>> {\n    let processed: E;\n    if (this.wrapper.preUnwrap && hasAnyField(v, this.fields)) {\n      processed = await this.wrapper.preUnwrap(v as any);\n    }\n    const converted = Object.assign({}, v) as any;\n    await Promise.all(this.fields.map(async (k) => {\n      if (Object.prototype.hasOwnProperty.call(v, k)) {\n        converted[k] = await this.wrapper.unwrap(k, (v as any)[k], processed);\n      }\n    }));\n    return converted;\n  }\n}\n","export default class LruCache<K, V> {\n  private readonly storage = new Map<K, V>();\n\n  public constructor(\n    private readonly capacity: number,\n  ) {}\n\n  public set(key: K, value: V): void {\n    this.storage.delete(key);\n    this.storage.set(key, value);\n    this.flush();\n  }\n\n  public get(key: K): V | undefined {\n    const value = this.storage.get(key);\n    if (this.storage.delete(key)) {\n      this.storage.set(key, value!);\n    }\n    return value;\n  }\n\n  public remove(key: K): void {\n    this.storage.delete(key);\n  }\n\n  private flush(): void {\n    while (this.storage.size > this.capacity) {\n      this.storage.delete(this.storage.keys().next().value);\n    }\n  }\n}\n","import crypto, { KeyObject } from 'crypto';\nimport Encryption from './Encryption';\n\nconst ALG = 'aes-256-cbc';\n\nconst nodeEncryptionSync: Encryption<KeyObject> = {\n  encrypt: (key: KeyObject, v: string): string => {\n    const iv = crypto.randomBytes(16);\n    const cipher = crypto.createCipheriv(ALG, key, iv);\n    const part = cipher.update(v, 'utf8', 'base64');\n    return `${ALG}:${iv.toString('base64')}:${part}${cipher.final('base64')}`;\n  },\n\n  decrypt: (key: KeyObject, v: string): string => {\n    const [alg, iv, encrypted] = v.split(':');\n\n    if (alg !== ALG) {\n      throw new Error('Unknown encryption algorithm');\n    }\n\n    const decipher = crypto.createDecipheriv(\n      ALG,\n      key as any,\n      Buffer.from(iv, 'base64'),\n    );\n    let decrypted = decipher.update(encrypted, 'base64', 'utf8');\n    decrypted += decipher.final('utf8');\n\n    return decrypted;\n  },\n\n  generateKey: (): KeyObject => crypto\n    .createSecretKey(crypto.randomBytes(32)),\n\n  serialiseKey: (key: KeyObject): string => key.export().toString('base64'),\n\n  deserialiseKey: (data: string): KeyObject => crypto\n    .createSecretKey(Buffer.from(data, 'base64')),\n};\n\nexport default nodeEncryptionSync;\n","import IDable from '../interfaces/IDable';\nimport Collection from '../interfaces/Collection';\nimport LruCache from '../helpers/LruCache';\nimport WrappedCollection, { Wrapped } from './WrappedCollection';\nimport Encryption from './encryption/Encryption';\nimport nodeEncryptionSync from './encryption/nodeEncryptionSync';\n\nexport interface KeyRecord<ID> {\n  id: ID;\n  key: string;\n}\n\nexport const encryptByKey = <T extends IDable>(\n  sKey: string,\n  cr: Encryption<unknown> = nodeEncryptionSync,\n) => <F extends readonly (keyof Omit<T, 'id'> & string)[]>(\n  fields: F,\n  baseCollection: Collection<Wrapped<T, F[-1], string>>,\n): Collection<T> => {\n  const key = cr.deserialiseKey(sKey);\n\n  return new WrappedCollection<T, F, string, never>(baseCollection, fields, {\n    wrap: (k, v): Promise<string> | string => cr.encrypt(key, JSON.stringify(v)),\n    unwrap: async (k, v): Promise<any> => JSON.parse(await cr.decrypt(key, v)),\n  });\n};\n\nexport const encryptByRecord = <T extends IDable>(\n  keyCollection: Collection<KeyRecord<T['id']>>,\n  cacheSize: number = 0,\n  cr: Encryption<unknown> = nodeEncryptionSync,\n) => <F extends readonly (keyof Omit<T, 'id'> & string)[]>(\n  fields: F,\n  baseCollection: Collection<Wrapped<T, F[-1], string>>,\n): Collection<T> => {\n  const cache = new LruCache<T['id'], unknown>(cacheSize);\n\n  const loadKey = async (\n    generateIfNeeded: boolean,\n    record: Partial<Pick<T, 'id'>>,\n  ): Promise<unknown> => {\n    const { id } = record;\n\n    if (id === undefined) {\n      throw new Error('Must provide ID for encryption');\n    }\n\n    const cached = cache.get(id);\n    if (cached) {\n      return cached;\n    }\n    let key: unknown;\n    const item = await keyCollection.get('id', id, ['key']);\n    if (item) {\n      key = cr.deserialiseKey(item.key);\n    } else {\n      if (!generateIfNeeded) {\n        throw new Error('No encryption key found for record');\n      }\n      key = await cr.generateKey();\n      await keyCollection.add({ id, key: cr.serialiseKey(key) });\n    }\n    cache.set(id, key);\n    return key;\n  };\n\n  const removeKey = async ({ id }: Pick<T, 'id'>): Promise<void> => {\n    await keyCollection.remove('id', id);\n    cache.remove(id);\n  };\n\n  return new WrappedCollection<T, F, string, unknown>(baseCollection, fields, {\n    wrap: (k, v, key): Promise<string> | string => cr.encrypt(key, JSON.stringify(v)),\n    unwrap: async (k, v, key): Promise<any> => JSON.parse(await cr.decrypt(key, v)),\n    preWrap: loadKey.bind(null, true),\n    preUnwrap: loadKey.bind(null, false),\n    preRemove: removeKey,\n  });\n};\n\nexport const encryptByRecordWithMasterKey = <T extends IDable>(\n  sMasterKey: string,\n  keyCollection: Collection<KeyRecord<T['id']>>,\n  cacheSize: number = 0,\n  cr: Encryption<unknown> = nodeEncryptionSync,\n) => <F extends readonly (keyof Omit<T, 'id'> & string)[]>(\n  fields: F,\n  baseCollection: Collection<Wrapped<T, F[-1], string>>,\n): Collection<T> => encryptByRecord<T>(\n  encryptByKey<KeyRecord<T['id']>>(sMasterKey, cr)(['key'], keyCollection),\n  cacheSize,\n  cr,\n)(fields, baseCollection);\n","import CollectionStorage from './CollectionStorage';\nimport WrappedCollection, { Wrapped } from './wrappers/WrappedCollection';\nimport Encryption from './wrappers/encryption/Encryption';\nimport DB from './interfaces/DB';\nimport Collection from './interfaces/Collection';\nimport IDable from './interfaces/IDable';\n\nexport type DB = DB;\nexport type Collection<T extends IDable> = Collection<T>;\nexport type Wrapped<T extends IDable, WF extends keyof T, W> = Wrapped<T, WF, W>;\nexport type Encryption<Key> = Encryption<Key>;\n\nexport { default as MemoryDb } from './memory/MemoryDb';\nexport { default as MongoDb } from './mongo/MongoDb';\nexport { default as LruCache } from './helpers/LruCache';\nexport { WrappedCollection };\nexport {\n  encryptByKey,\n  encryptByRecord,\n  encryptByRecordWithMasterKey,\n} from './wrappers/encrypted';\nexport {\n  default as nodeEncryptionSync,\n} from './wrappers/encryption/nodeEncryptionSync';\nexport default CollectionStorage;\n","import MemoryDb from './memory/MemoryDb';\nimport MongoDb from './mongo/MongoDb';\nimport DB from './interfaces/DB';\n\nexport default class CollectionStorage {\n  public static async connect(url: string): Promise<DB> {\n    let dbClass;\n    if (url.startsWith('memory')) {\n      dbClass = MemoryDb;\n    } else if (url.startsWith('mongodb')) {\n      dbClass = MongoDb;\n    } else {\n      throw new Error(`Unsupported database connection string: ${url}`);\n    }\n\n    try {\n      return await dbClass.connect(url);\n    } catch (e) {\n      throw new Error(`Failed to connect to database \"${url}\": ${e.message}`);\n    }\n  }\n}\n"],"sourceRoot":""}