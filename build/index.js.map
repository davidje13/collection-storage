{"version":3,"sources":["webpack://collection-storage/webpack/universalModuleDefinition","webpack://collection-storage/webpack/bootstrap","webpack://collection-storage/./src/interfaces/BaseCollection.ts","webpack://collection-storage/external \"crypto\"","webpack://collection-storage/external \"mongodb\"","webpack://collection-storage/./src/helpers/retry.ts","webpack://collection-storage/external \"zlib\"","webpack://collection-storage/external \"util\"","webpack://collection-storage/external \"url\"","webpack://collection-storage/./src/mongo/MongoCollection.ts","webpack://collection-storage/external \"ioredis\"","webpack://collection-storage/external \"pg\"","webpack://collection-storage/./src/helpers/serialiser.ts","webpack://collection-storage/./src/memory/MemoryCollection.ts","webpack://collection-storage/./src/interfaces/BaseDB.ts","webpack://collection-storage/./src/memory/MemoryDb.ts","webpack://collection-storage/./src/mongo/MongoDb.ts","webpack://collection-storage/./src/redis/helpers.ts","webpack://collection-storage/./src/redis/RedisCollection.ts","webpack://collection-storage/./src/redis/scripts.ts","webpack://collection-storage/./src/redis/RedisConnectionPool.ts","webpack://collection-storage/./src/redis/RedisDb.ts","webpack://collection-storage/./src/postgresql/hstore.ts","webpack://collection-storage/./src/postgresql/sql.ts","webpack://collection-storage/./src/postgresql/PostgresCollection.ts","webpack://collection-storage/./src/postgresql/PostgresDb.ts","webpack://collection-storage/./src/wrappers/WrappedCollection.ts","webpack://collection-storage/./src/helpers/LruCache.ts","webpack://collection-storage/./src/wrappers/encryption/nodeEncryptionSync.ts","webpack://collection-storage/./src/wrappers/encrypted.ts","webpack://collection-storage/./src/wrappers/compressed.ts","webpack://collection-storage/./src/wrappers/migrated.ts","webpack://collection-storage/./src/index.ts","webpack://collection-storage/./src/CollectionStorage.ts"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","BaseCollection","constructor","keys","this","innerPreAct","preAct","entry","internalAdd","searchAttribute","searchValue","returnAttributes","isIndexed","Error","internalGet","internalGetAll","update","options","undefined","id","upsert","withoutId","internalUpsert","isIndexUnique","some","k","internalUpdate","internalRemove","wait","pending","addPending","Promise","resolve","reject","push","internalReady","async","e","forEach","f","attribute","keyOptions","Boolean","unique","require","sleep","millis","setTimeout","shouldRetry","timeoutMillis","initialDelayMillis","maxDelayMillis","delayGrowth","jitter","limit","Date","now","currentDelay","attempt","fn","delay","Math","min","random","message","DOT_REG","fieldNameToMongo","encodeURIComponent","replace","MONGO_ERROR_IDX","withUpsertRetry","retry","MongoError","code","exec","getErrorIndex","convertToMongo","converted","v","Buffer","MBinary","_bsontype","convertFromMongo","buffer","decodeURIComponent","makeMongoProjection","names","projection","fieldName","configureCollection","collection","existing","indexes","catch","idxToCreate","idxToDelete","Set","map","idx","delete","keyName","makeIndex","index","match","find","a","b","aKey","bKey","length","every","indicesMatch","createIndexes","size","all","idxName","dropIndex","MongoCollection","stateRef","closed","super","initAsync","insertOne","updateOne","$set","query","mongoUpdate","updateMany","findOne","cursor","result","raw","deleteMany","deletedCount","MARK_BINARY","charCodeAt","MARK_STRING","MARK_BINARY_BUFF","Uint8Array","of","serialiseValue","toString","JSON","stringify","deserialiseValue","type","data","substr","from","parse","includes","serialiseValueBin","concat","deserialiseValueBin","subarray","serialiseRecord","record","deserialiseRecord","MemoryCollection","simulatedLatency","Map","indices","serialised","internalCheckDuplicates","set","internalPopulateIndices","has","updates","internalGetSerialisedIds","sId","oldSerialised","oldValue","newValue","newSerialised","internalRemoveIndices","sIds","fields","field","applyFilter","sKey","serialisedValue","checkId","add","BaseDB","makeCollection","getCollection","cached","collectionCache","normKeys","sort","join","cachedNormKeys","cachedCol","created","close","syncClose","toAwait","values","allSettled","then","internalClose","globalDbs","initial","getGlobal","MemoryDb","url","parsedUrl","URL","hostname","params","searchParams","Number","db","MongoDb","client","escapeName","MongoClient","default","connect","useNewUrlParser","useUnifiedTopology","getDb","minifyLuaScript","lines","argNames","combined","ln","trim","RegExp","notUndefined","item","makeIndexKeys","partialSerialisedValue","filter","prefix","parseItem","itemHasContent","unwatchAll","unwatch","mapAwaitSync","RedisCollection","pool","keyPrefix","keyPrefixes","keyInfo","uniqueKeys","nonUniqueKeys","withConnection","runAdd","patchSerialised","retryWithConnection","patch","getUpdatePatch","runUpdates","insertValue","getAndWatchBySerialisedKey","patches","getByKeysKeepWatches","makeKey","cut","indexedKeys","items","rawByKeyKeepWatches","pipeline","multi","remove","serialisedId","checkWatch","keyCount","entries","flat","watch","argsList","makeUpdateArgs","results","updateArgs","checkUpdate","chain","updateWithoutCheck","diff","patchUniqueKeys","patchNonUniqueKeys","oldUniqueKeys","oldNonUniqueKeys","serialisedIds","commands","multiExec","exists","hmget","hgetall","parsed","keyAddress","smembers","SCRIPT_ADD","FRAG_CHECK_UPDATE","FRAG_UPDATE","SCRIPT_CHECK_UPDATE","SCRIPT_UPDATE_WITHOUT_CHECK","SCRIPT_UPDATE","SCRIPT_REMOVE","withRetry","RedisConnectionPool","RedisStatic","maxConnections","teardown","getConnection","returnConnection","inUse","doClose","closingFn","connections","disconnect","pop","defineCommand","lua","defineAllScripts","queue","q","shift","RedisDb","lazyConnect","getConnectionPool","quoteHValue","DQUOTE_REG","SQUOTE_REG","quoteValue","msg","ID_REG","withIdentifiers","base","identifiers","STATEMENTS","CREATE_TABLE","GET_INDEX_NAMES","CREATE_INDEX","CREATE_UNIQUE_INDEX","DROP_INDEX","INSERT","UPDATE","UPDATE_ID","UPSERT_ID","SELECT_ONE","SELECT_ALL","SELECT_ALL_BY","SELECT_ID","DELETE","DELETE_ID","toHStore","encodeHStore","fromHStore","rawMap","hstore","current","currentKey","quote","decodeHStore","PostgresCollection","tableName","T","rowMode","text","oldIndexNames","rows","startsWith","keyEntries","I","indicesToDelete","release","configureTable","rest","runTableQuery","rowCount","queryName","cachedQueries","PostgresDb","Pool","connectionString","end","hasAnyField","WrappedCollection","baseCollection","wrapper","wrapAll","unwrapAll","getAll","extra","preRemove","processed","preWrap","allFields","wrap","preUnwrap","unwrap","LruCache","capacity","calc","storage","flush","next","ALG","ALG_BUF","nodeEncryptionSync","encrypt","iv","crypto","randomBytes","cipher","createCipheriv","part","final","decrypt","slice","equals","encrypted","decipher","createDecipheriv","generateKey","createSecretKey","serialiseKey","export","deserialiseKey","makeEncrypter","encryptByKey","encryption","allowRaw","encryptByRecord","keyCollection","cacheSize","cache","loadKey","generateIfNeeded","cachedAsync","removeKey","encryptByRecordWithMasterKey","sMasterKey","opts","keyEnc","gzipCompress","promisify","zlib","gzip","gzipDecompress","gunzip","MARK_UNCOMPRESSED","compress","compressionThresholdBytes","gzipped","compressValue","allowRawBuffer","decompressValue","MigratedCollection","migrations","extraFetchFields","extendAttributes","applyMigration","attr","migration","migrate","CollectionStorage","dbClass"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,qBAAsB,GAAIH,GACP,iBAAZC,QACdA,QAAQ,sBAAwBD,IAEhCD,EAAK,sBAAwBC,IAR/B,CASGK,QAAQ,WACX,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUP,QAGnC,IAAIC,EAASI,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHT,QAAS,IAUV,OANAU,EAAQH,GAAUI,KAAKV,EAAOD,QAASC,EAAQA,EAAOD,QAASM,GAG/DL,EAAOQ,GAAI,EAGJR,EAAOD,QA0Df,OArDAM,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASd,EAASe,EAAMC,GAC3CV,EAAoBW,EAAEjB,EAASe,IAClCG,OAAOC,eAAenB,EAASe,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAAStB,GACX,oBAAXuB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAenB,EAASuB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAenB,EAAS,aAAc,CAAEyB,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAAShC,GAChC,IAAIe,EAASf,GAAUA,EAAO2B,WAC7B,WAAwB,OAAO3B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAK,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,GAIjBhC,EAAoBA,EAAoBiC,EAAI,G,uZC9EtC,MAAeC,EAMlBC,YACWC,GACnB,KADmBA,OACnB,4DACAC,KAAKC,YAAcD,KAAKE,OAAOb,KAAKW,MAGtC,UAAiBG,GAEf,aADMH,KAAKC,cACJD,KAAKI,YAAYD,GAG1B,UAIEE,EACAC,EACAC,GAEA,IAAKP,KAAKQ,UAAUH,GAClB,MAAM,IAAII,MAAO,gBAAeJ,GAGlC,aADML,KAAKC,cACJD,KAAKU,YAAYL,EAAiBC,EAAaC,GAGxD,aAIEF,EACAC,EACAC,GAEA,GAAIF,IAAoBL,KAAKQ,UAAUH,GACrC,MAAM,IAAII,MAAO,gBAAeJ,GAGlC,aADML,KAAKC,cACJD,KAAKW,eAAeN,EAAiBC,EAAaC,GAG3D,aACEF,EACAC,EACAM,EACAC,EAAyB,IAEzB,GAAwB,OAApBR,QAA0CS,IAAdF,EAAOG,IAAoBH,EAAOG,KAAOT,EACvE,MAAM,IAAIG,MAAM,oBAElB,GAAII,EAAQG,OAAQ,CAClB,GAAwB,OAApBX,EACF,MAAM,IAAII,MAAO,8BAA6BJ,GAEhD,IAAIY,EAAYL,EAMhB,OALIrC,OAAOkB,UAAUC,eAAe1B,KAAK4C,EAAQ,QAC/CK,E,+VAAY,CAAH,GAAQL,UACVK,EAAUF,UAEbf,KAAKC,cACJD,KAAKkB,eAAeZ,EAAwBW,EAAWJ,GAEhE,IAAKb,KAAKQ,UAAUH,GAClB,MAAM,IAAII,MAAO,gBAAeJ,GAElC,IACGL,KAAKmB,cAAcd,IACpB9B,OAAOwB,KAAKa,GAAQQ,KAAMC,GAAMrB,KAAKmB,cAAcE,IAEnD,MAAM,IAAIZ,MAAM,aAIlB,aADMT,KAAKC,cACJD,KAAKsB,eAAejB,EAAiBC,EAAaM,EAAQC,GAGnE,aACER,EACAC,GAEA,IAAKN,KAAKQ,UAAUH,GAClB,MAAM,IAAII,MAAO,gBAAeJ,GAGlC,aADML,KAAKC,cACJD,KAAKuB,eAAelB,EAAiBC,GAO9C,gBAA0BkB,GACxB,MAAMC,EAA8C,GAC9CC,EAAa,IAAqB,IAAIC,QAAQ,CAACC,EAASC,KAC5DJ,EAAQK,KAAK,CAACF,EAASC,MAEzB7B,KAAK+B,cAAgBL,EACrB1B,KAAKC,YAAc+B,gBACXN,IACC1B,KAAKE,UAEd,UACQsB,EACN,MAAOS,GAIP,OAHAjC,KAAK+B,cAAgB,IAAqBJ,QAAQE,OAAOI,GACzDjC,KAAKC,YAAc,KAAc,MAAMgC,QACvCR,EAAQS,QAASC,GAAMA,EAAE,GAAGF,IAG9BjC,KAAK+B,mBAAgBjB,EACrBd,KAAKC,YAAcD,KAAKE,OAAOb,KAAKW,MACpCyB,EAAQS,QAASC,GAAMA,EAAE,MAGjB3B,UAAU4B,GAClB,MACgB,OAAdA,QAC4CtB,IAA5Cd,KAAKD,KAAKqC,GAIJjB,cAAciB,GACtB,MAAMC,EAAarC,KAAKD,KAAKqC,GAC7B,MACgB,OAAdA,GACAE,QAAQD,GAAcA,EAAWE,QAK3BrC,UAEV,kBAIEG,EACAC,EACAC,GAC0C,MAE1C,wBADkBP,KAAKW,eAAeN,EAAiBC,EAAaC,IACzD,UAAX,QAAiB,KAGTW,eACRH,EACAH,EACAC,GAEA,OAAOb,KAAKsB,eAAe,KAAMP,EAAIH,EAAQC,M,cC/JjDvD,EAAOD,QAAUmF,QAAQ,W,cCAzBlF,EAAOD,QAAUmF,QAAQ,Y,6BCAzB,SAASC,EAAMC,GACb,OAAO,IAAIf,QAASC,GAAiBe,WAAWf,EAASc,IAG5C,KAACE,GACdC,gBAAgB,IAChBC,qBAAqB,GACrBC,iBAAiB,IACjBC,cAAc,EACdC,UAAS,GACP,KAAOjB,UACT,MAAMkB,EAAQC,KAAKC,MAAQP,EAC3B,IAAIQ,EAAeP,EACnB,IAAK,IAAIQ,EAAU,GAAKA,GAAW,EACjC,IAEE,aAAaC,IACb,MAAOtB,GACP,IAAKW,EAAYX,GACf,MAAMA,EAGR,MAAMuB,EACJC,KAAKC,IAAIL,EAAcN,IACtBE,EAASQ,KAAKE,SAAW,GAI5B,GAFAN,GAAgBL,EAEZG,KAAKC,MAAQI,EAAQN,EAEvB,MADAjB,EAAE2B,SAAY,mBAAkBN,cAC1BrB,QAIFQ,EAAMe,M,cClClBlG,EAAOD,QAAUmF,QAAQ,S,cCAzBlF,EAAOD,QAAUmF,QAAQ,S,cCAzBlF,EAAOD,QAAUmF,QAAQ,Q,8DCAzB,wEAaA,MAGMqB,EAAU,MAChB,SAASC,EAAiB1F,GACxB,MAJS,OAILA,EALW,MAQR2F,mBAAmB3F,GAAM4F,QAAQH,EAAS,OAUnD,MAAMI,EAAkB,kCAKxB,MAAMC,EAAkBC,YAAOlC,GAC7BA,aAAamC,cACF,OAAXnC,EAAEoC,MACmB,SAPvB,SAAuBpC,GAAuB,MAC5C,OAAO,UAAAgC,EAAgBK,KAAKrC,EAAE2B,gBAAvB,eAAkC,KAAM,GAM/CW,CAActC,IAGhB,SAASuC,EACP1F,GAEA,MAAM2F,EAAqC,GAW3C,OAVAlG,OAAOwB,KAAKjB,GAAOoD,QAASb,IAC1B,IAAIqD,EAAK5F,EAAcuC,GACvB,GAAIqD,aAAaC,OACfD,EAAI,IAAIE,SAAQF,QAEX,GAAiB,iBAANA,GAAkBA,EAAEG,UACpC,MAAM,IAAIpE,MAAM,0CAElBgE,EAAUX,EAAiBzC,IAAMqD,IAE5BD,EAGT,SAASK,EACPhG,GAEA,IAAKA,EACH,OAAO,KAET,MAAM2F,EAAe,GASrB,OARAlG,OAAOwB,KAAKjB,GAAOoD,QAASb,IAC1B,IAAIqD,EAAK5F,EAAcuC,GA3C3B,IAA4BjD,EA6CP,iBAANsG,GAAkC,WAAhBA,EAAEG,YAC7BH,EAAIA,EAAEK,QAEPN,GAhDuBrG,EAgDciD,EA3DzB,QAYXjD,EAXK,KAcF4G,mBAAmB5G,KA4CoBsG,IAEvCD,EAGT,SAASQ,EACPC,GAEA,MAAMC,EAAsC,GAO5C,OANID,IACFC,EAAU,KAAa,EACvBD,EAAMhD,QAASkD,IACbD,EAAWrB,EAAiBsB,KAAc,KAGvCD,EA+BTnD,eAAeqD,EACbC,EACAvF,EAAoB,IAEpB,MAAMwF,QAA+BD,EAAWE,UAAUC,MAAM,IAAM,IAChEC,EAAoC,GACpCC,EAAc,IAAIC,IAAIL,EAASM,IAAKC,GAAQA,EAAI1H,OACtDuH,EAAYI,OAAO,QAEnBxH,OAAOwB,KAAKA,GACT8F,IAAKG,GAhCV,SAAmBA,EAAiBnF,EAAsB,IACxD,MAAM0B,EAASD,QAAQzB,EAAQ0B,QAE/B,MAAO,CACLnD,IAAK,CAAE,CAFQ0E,EAAiBkC,IAEbzD,EAAS,EAAI,UAChCA,UA2BkB0D,CAAUD,EAASjG,EAAKiG,KACzC9D,QAASgE,IACR,MAAMC,EAAQZ,EAASa,KAAMN,GAzBnC,SAAsBO,EAAuBC,GAC3C,GAAIhE,QAAQ+D,EAAE9D,UAAYD,QAAQgE,EAAE/D,QAClC,OAAO,EAET,MAAMgE,EAAOF,EAAEjH,IACToH,EAAOF,EAAElH,IACTW,EAAOxB,OAAOwB,KAAKwG,GACzB,OAAIhI,OAAOwB,KAAKyG,GAAMC,SAAW1G,EAAK0G,QAG/B1G,EAAK2G,MAAOrF,GAAOkF,EAAKlF,KAAOmF,EAAKnF,IAeFsF,CAAab,EAAKI,IACnDC,EACFR,EAAYI,OAAOI,EAAM/H,MAEzBsH,EAAY5D,KAAKoE,KAGnBR,EAAYe,cACRnB,EAAWsB,cAAclB,GAE7BC,EAAYkB,YACRlF,QAAQmF,IAAI,IAAInB,GAAaE,IAAKkB,GAAYzB,EAAW0B,UAAUD,KAI9D,MAAME,UAA0CpH,IACtDC,YACYwF,EACjBvF,EAAkB,GACDmH,EAAqB,CAAEC,QAAQ,IAEhDC,MAAMrH,GADN,KAHiBuF,aAGjB,KADiB4B,WAGjBlH,KAAKqH,UAAUhC,EAAoBC,EAAYvF,IAGvCG,SACR,GAAIF,KAAKkH,SAASC,OAChB,MAAM,IAAI1G,MAAM,qBAIpB,kBAA4B3B,SACpBkB,KAAKsF,WAAWgC,UAAU9C,EAAe1F,IAGjD,qBACEiC,EACAH,SAEMsD,EAAgB,IAAMlE,KAAKsF,WAAWiC,UAC1C/C,EAAe,CAAEzD,OACjB,CAAEyG,KAAMhD,EAAe5D,IACvB,CAAEI,QAAQ,KAId,qBACEX,EACAC,EACAM,GAEA,MAAM6G,EAAQjD,EAAe,CAAE,CAACnE,GAAkBC,IAC5CoH,EAAc,CAAEF,KAAMhD,EAAe5D,IACvCZ,KAAKmB,cAAcd,SACfL,KAAKsF,WAAWiC,UAAUE,EAAOC,SAEjC1H,KAAKsF,WAAWqC,WAAWF,EAAOC,GAI5C,kBAIErH,EACAC,EACAC,GAMA,OAAOuE,QAJW9E,KAAKsF,WAAWsC,QAChCpD,EAAe,CAAE,CAACnE,GAAkBC,IACpC,CAAE6E,WAAYF,EAAoB1E,MAKtC,qBAIEF,EACAC,EACAC,GAEA,MAAMsH,EAAS7H,KAAKsF,WAAWc,KAC7B/F,EAAkBmE,EAAe,CAAE,CAACnE,GAAkBC,IAAiB,GACvE,CAAE6E,WAAYF,EAAoB1E,KAG9BuH,EAA2B,GAGjC,aAFMD,EAAO3F,QAAS6F,GAAQD,EAAOhG,KAAKgD,EAAoBiD,KAEvDD,EAGT,qBACEzH,EACAC,GAKA,aAHqBN,KAAKsF,WAAW0C,WACnCxD,EAAe,CAAE,CAACnE,GAAkBC,MAExB2H,cAAgB,K,cCvOlC3K,EAAOD,QAAUmF,QAAQ,Y,cCAzBlF,EAAOD,QAAUmF,QAAQ,O,gjBCQzB,MACM0F,EAAc,IAAIC,WAAW,GAC7BC,EAAc,IAAID,WAAW,GAE7BE,EAAmBC,WAAWC,GAAGL,GAehC,SAASM,EAAe1J,GAC7B,OAAIA,aAAiB6F,OACX,IAAG7F,EAAM2J,SAAS,UAEP,iBAAV3J,EACD,IAAGA,EAEQ,kBAAVA,EACFA,EAAQ,IAAM,IAET,OAAVA,EACK,IAED,IAAG4J,KAAKC,UAAU7J,GAGrB,SAAS8J,EAAiB9J,GAC/B,MAAM+J,EAAO/J,EAAM,GACbgK,EAAOhK,EAAMiK,OAAO,GAC1B,OAAQF,GACN,IAAK,IAAK,OAAOlE,OAAOqE,KAAKF,EAAM,UACnC,IAAK,IAAK,OAAOA,EACjB,IAAK,IAAK,OAAO,EACjB,IAAK,IAAK,OAAO,EACjB,IAAK,IAAK,OAAO,KACjB,IAAK,IAAK,OAAOJ,KAAKO,MAAMH,GAC5B,QACE,GA9CkB,iBA8CEI,SAASL,GAC3B,OAAOH,KAAKO,MAAMnK,GAEpB,MAAM,IAAI2B,MAAO,qBAAoBoI,IAIpC,SAASM,EAAkBrK,GAChC,OAAIA,aAAiB6F,OACZA,OAAOyE,OAAO,CAACf,EAAkBvJ,IAEnC6F,OAAOqE,KAAKR,EAAe1J,GAAQ,QAGrC,SAASuK,EAAoBvK,GAClC,GAAqB,iBAAVA,EACT,OAAO8J,EAAiB9J,GAG1B,MAAM+J,EAAO/J,EAAM,GACnB,OAAI+J,IAASX,EACJpJ,EAAMwK,SAAS,GAEpBT,IAAST,EACJtJ,EAAMwK,SAAS,GAAGb,SAAS,QAE7BG,EAAiB9J,EAAM2J,SAAS,SAGlC,SAASc,EACdC,GAEA,MAAM1B,EAAiC,GAIvC,OAHAvJ,OAAOwB,KAAKyJ,GAAQtH,QAASb,IAC3ByG,EAAOzG,GAAKmH,EAAgBgB,EAAenI,MAEtCyG,EAGF,SAAS2B,EACdD,GAEA,MAAM1B,EAA8B,GAOpC,OANAvJ,OAAOwB,KAAKyJ,GAAQtH,QAASb,IAC3B,MAAMqD,EAAI8E,EAAOnI,GACbqD,IACFoD,EAAOzG,GAAKuH,EAAiBlE,MAG1BoD,E,urBCtEM,MAAM4B,UAA2C7J,IAKvDC,YACLC,EAAkB,GACD4J,EAAmB,EACnBzC,EAAqB,CAAEC,QAAQ,IAEhDC,MAAMrH,GADN,KAFiB4J,mBAEjB,KADiBzC,WACjB,uCAN6E,IAS7ElH,KAAK8I,KAAO,IAAIc,IAEhBrL,OAAOwB,KAAKA,GAAMmC,QAASb,IACzBrB,KAAK6J,QAAQxI,GAAgB,IAAIuI,MAI3B1J,SACR,GAAIF,KAAKkH,SAASC,OAChB,MAAM,IAAI1G,MAAM,qBAElB,OA9CJ,SAAeiC,GACb,GAAKA,EAKL,OAAO,IAAIf,QAASC,GAAiBe,WAAWf,EAASc,IAwChDD,CAAMzC,KAAK2J,kBAGpB,kBAA4B7K,GAC1B,MAAMgL,EAAaP,EAAgBzK,GACnCkB,KAAK+J,wBAAwBD,GAAY,GACzC9J,KAAK8I,KAAKkB,IAAIF,EAAW/I,GAAI+I,GAC7B9J,KAAKiK,wBAAwBH,GAG/B,qBACE/I,EACAH,GAEIZ,KAAK8I,KAAKoB,IAAI1B,EAAezH,UACzBf,KAAKsB,eAAe,KAAMP,EAAIH,SAE9BZ,KAAKI,YAAL,GAAmBW,MAAOH,IAIpC,qBACEP,EACAC,EACAM,GAEA,MAEMuJ,EAFOnK,KAAKoK,yBAAyB/J,EAAiBC,GAEvCuF,IAAKwE,IACxB,MAAMC,EAAgBtK,KAAK8I,KAAKpK,IAAI2L,GAC9BE,EAAWd,EAAkBa,GAC7BE,EAAW,EAAH,KAAQD,GAAa3J,GACnC,GAAI4J,EAASzJ,KAAOwJ,EAASxJ,GAC3B,MAAM,IAAIN,MAAM,oBAGlB,MAAO,CAAE6J,gBAAeG,cADFlB,EAAgBiB,MAIxCL,EAAQjI,QAAQ,EAAGoI,mBAAoBtK,KAAK0K,sBAAsBJ,IAClE,IACEH,EAAQjI,QAAQ,EAAGuI,mBAAoBzK,KAAK+J,wBAAwBU,GAAe,IACnF,MAAOxI,GAEP,MADAkI,EAAQjI,QAAQ,EAAGoI,mBAAoBtK,KAAKiK,wBAAwBK,IAC9DrI,EAERkI,EAAQjI,QAAQ,EAAGuI,oBACjBzK,KAAK8I,KAAKkB,IAAIS,EAAc1J,GAAI0J,GAChCzK,KAAKiK,wBAAwBQ,KAIjC,qBAIEpK,EACAC,EACAC,GAEA,IAAIoK,EAMJ,OAJEA,EADEtK,EACKL,KAAKoK,yBAAyB/J,EAAiBC,GAE/C,IAAIN,KAAK8I,KAAK/I,QAEhB4K,EAAK9E,IAAKwE,GAvGrB,SACEvB,EACA8B,GAEA,IAAKA,EACH,OAAO9B,EAET,MAAMhB,EAAyB,GAI/B,OAHA8C,EAAO1I,QAAS2I,IACd/C,EAAO+C,GAAS/B,EAAK+B,KAEhB/C,EA4FoBgD,CACvBrB,EAAkBzJ,KAAK8I,KAAKpK,IAAI2L,IAChC9J,IAIJ,qBACEF,EACAC,GAEA,MAAMqK,EAAO3K,KAAKoK,yBAAyB/J,EAAiBC,GAO5D,OANAqK,EAAKzI,QAASmI,IACZ,MAAMC,EAAgBtK,KAAK8I,KAAKpK,IAAI2L,GACpCrK,KAAK0K,sBAAsBJ,GAC3BtK,KAAK8I,KAAK/C,OAAOsE,KAGZM,EAAKlE,OAGN2D,yBACN/J,EACAC,GAEA,MAAMyK,EAAOvC,EAAelI,GAC5B,GAAwB,OAApBD,EACF,OAAOL,KAAK8I,KAAKoB,IAAIa,GAAQ,CAACA,GAAQ,GAExC,MAAM7E,EAAQlG,KAAK6J,QAAQxJ,GAC3B,IAAK6F,EACH,MAAM,IAAIzF,MAAO,iBAAgBJ,iBAEnC,MAAMsK,EAAOzE,EAAMxH,IAAIqM,GACvB,OAAOJ,EAAO,IAAIA,GAAQ,GAGpBZ,wBACNiB,EACAC,GAEA,GAAIA,GAAWjL,KAAK8I,KAAKoB,IAAIc,EAAgBjK,IAC3C,MAAM,IAAIN,MAAM,aAElBlC,OAAOwB,KAAKC,KAAKD,MAAMmC,QAAS9C,IAC9B,MAAM8G,EAAQlG,KAAK6J,QAAQzK,GAC3B,GAAIY,KAAKmB,cAAc/B,IAAQ8G,EAAMgE,IAAIc,EAAgB5L,IACvD,MAAM,IAAIqB,MAAM,eAKdwJ,wBACNe,GAEAzM,OAAOwB,KAAKC,KAAKD,MAAMmC,QAAS9C,IAC9B,MAAM8G,EAAQlG,KAAK6J,QAAQzK,GACrBsF,EAAIsG,EAAgB5L,GAC1B,IAAId,EAAI4H,EAAMxH,IAAIgG,GACbpG,IACHA,EAAI,IAAIsH,IACRM,EAAM8D,IAAItF,EAAGpG,IAEfA,EAAE4M,IAAIF,EAAgBjK,MAIlB2J,sBACNM,GAEAzM,OAAOwB,KAAKC,KAAKD,MAAMmC,QAAS9C,IAC9B,MAAM8G,EAAQlG,KAAK6J,QAAQzK,GACrBsF,EAAIsG,EAAgB5L,GACpBd,EAAI4H,EAAMxH,IAAIgG,GACpBpG,EAAEyH,OAAOiF,EAAgBjK,IACpBzC,EAAEuI,MACLX,EAAMH,OAAOrB,M,wHCxLN,MAAeyG,EAK5BrL,YACmBsL,GAIjB,KAJiBA,iBAIjB,kBATsC,CAAEjE,QAAQ,IAShD,yBAPiC,IAAIyC,KAShCyB,cAAgCjN,EAAc2B,GACnD,MAAMuL,EAAStL,KAAKuL,gBAAgB7M,IAAIN,GAClCoN,GFboBlN,EEaKyB,GFHzB,IAJQxB,OAAOwB,KAAKzB,GACzBmN,OACA5F,IAAKxE,GAAO,GAAEqH,KAAKC,UAAUtH,MAAMqH,KAAKC,UAAUrK,EAAE+C,OACpDqK,KAAK,QAPC,OAFJ,IAAuBpN,EEc1B,GAAIgN,EAAQ,CACV,MAAOK,EAAgBC,GAAaN,EACpC,GAAIE,IAAaG,EACf,MAAM,IAAIlL,MAAO,+BAA8BrC,0BAEjD,OAAOwN,EAET,MAAMC,EAAU7L,KAAKoL,eAAehN,EAAM2B,GAE1C,OADAC,KAAKuL,gBAAgBvB,IAAI5L,EAAM,CAACoN,EAAUK,IACnCA,EAGTC,QACE,GAAI9L,KAAKkH,SAASC,OAChB,OAEFnH,KAAK+L,YACL,MAAMC,EAAU,IAAIhM,KAAKuL,gBAAgBU,UACtCpG,IAAI,EAAE,CAAE3H,MAAJ,0BAAY,EAAAA,GAA8B6D,qBAA1C,aAAW,YAClB,OAAOJ,QAAQuK,WAAWF,GAASG,KAAK,IAAMnM,KAAKoM,iBAG3CL,YACR/L,KAAKkH,SAASC,QAAS,EAIfiF,kBCvCZ,MAAMC,EAVN,SAAsBjO,EAAckO,GAClC,MAAM/G,EAAY9H,OAAeW,GACjC,OAAImH,IAIH9H,OAAeW,GAAQkO,EACjBA,GAGSC,CAChB,4BACA,IAAI3C,KAGS,MAAM4C,UAAiBrB,EAC7BrL,aAAY,iBAAE6J,EAAmB,GAAM,IAC5CvC,MAAM,CAAChJ,EAAM2B,IAAS,IAAI2J,EAAiB3J,EAAM4J,EAAkB3J,KAAKkH,WAG1E,eAAsBuF,GACpB,MAAMC,EAAY,IAAIC,MAAIF,GACpBrO,EAAOsO,EAAUE,SACvB,GAAIxO,GAAQiO,EAAUnC,IAAI9L,GACxB,OAAOiO,EAAU3N,IAAIN,GAEvB,MAAMyO,EAASH,EAAUI,aACnBnD,EAAmBoD,OAAOF,EAAOnO,IAAI,qBACrCsO,EAAK,IAAIR,EAAS,CAAE7C,qBAI1B,OAHIvL,GACFiO,EAAUrC,IAAI5L,EAAM4O,GAEfA,EAGF3B,cAAgCjN,EAAc2B,GACnD,OAAOqH,MAAMiE,cAAcjN,EAAM2B,GAG5B+L,QACL9L,KAAK+L,aCpCM,MAAMkB,UAAgB9B,EAC3BrL,YACWoN,EACjBjG,GAEAG,MAAM,CAAChJ,EAAM2B,IAAS,IAAIkH,EACxBjH,KAAKkN,OAAOF,KAAK1H,WAVvB,SAAoBlH,GAClB,OAAO2F,mBAAmB3F,GASM+O,CAAW/O,IACvC2B,EACAC,KAAKkH,WAJP,KAFiBgG,SAUnB,qBAA4BT,GAC1B,MAAM,YAAEW,SAAsB,QAAN,qBAAa,KAEnCC,QAASpG,SACD,QAAN,qBAAwC,IACtCiG,QAAeE,EAAYE,QAAQb,EAAK,CAC5Cc,iBAAiB,EACjBC,oBAAoB,IAEtB,OAAO,IAAIP,EAAQC,EAAQjG,GAGtBoE,cAAgCjN,EAAc2B,GACnD,OAAOqH,MAAMiE,cAAcjN,EAAM2B,GAG5B0N,QACL,OAAOzN,KAAKkN,OAAOF,KAGXZ,gBACR,OAAOpM,KAAKkN,OAAOpB,SCZhB,SAAS4B,EACdC,KACGC,GAEH,IAAIC,EAAWF,EAAM9H,IAAKiI,GAAOA,EAAGC,QAAQrC,KAAK,KAIjD,OAHAkC,EAAS1L,QAAQ,CAAC9D,EAAMP,KACtBgQ,EAAWA,EAAS7J,QAAQ,IAAIgK,OAAQ,MAAK5P,OAAW,KAAO,QAAOP,EAAI,QAErEgQ,E,2iCCfT,MAAMI,EAAmBC,QAAkCpN,IAAToN,EAElD,SAASC,EACPpO,EACAqO,GAEA,OAAOrO,EACJsO,OAAO,EAAGjP,SAAUgP,EAAuBhP,IAC3CyG,IAAI,EAAGzG,MAAKkP,YAAc,GAAEA,KAAUF,EAAuBhP,MAGlE,SAASmP,EACPL,EACAtD,GAEA,IAAKA,EACH,OAAOsD,EAET,MAAMpG,EAAwC,GAC9C,IAAK,IAAI3F,EAAI,EAAGA,EAAIyI,EAAOnE,OAAQtE,GAAK,EACtC2F,EAAO8C,EAAOzI,IAAO+L,EAAa/L,GAEpC,OAAO2F,EAGT,SAAS0G,EAAeN,GACtB,OAAO3P,OAAO0N,OAAOiC,GAAM9M,KAAMsD,GAAa,OAANA,GAG1C1C,eAAeyM,EAAWvB,SAClBA,EAAOwB,UAGf1M,eAAe2M,EACb1C,EACA1I,GAEA,MAAMuE,EAAc,GACpB,IAAK,IAAIjK,EAAI,EAAGA,EAAIoO,EAAOxF,OAAQ5I,GAAK,EAEtCiK,EAAOhG,WAAWyB,EAAG0I,EAAOpO,KAE9B,OAAOiK,EAGM,MAAM8G,UAA0C/O,IAOtDC,YACY+O,EACAP,EACjBvO,EAAkB,IAElBqH,MAAMrH,GADN,KAHiB8O,OAGjB,KAFiBP,SAEjB,qBAV0D,IAU1D,oBARsC,IAQtC,uBANyC,IASzC/P,OAAOwB,KAAKA,GAAMmC,QAASb,IACzB,MAAMjC,EAAMiC,EACNyN,EAAa,GAAER,KAAUlP,IAC/BY,KAAK+O,YAAY3P,GAAO0P,EACxB,MAAME,EAAU,CAAE5P,MAAKkP,OAAQQ,GAC3B/O,EAAKX,GAAMmD,OACbvC,KAAKiP,WAAWnN,KAAKkN,GAErBhP,KAAKkP,cAAcpN,KAAKkN,KAKpB5O,YAAYtB,GACpB,MAAMgL,EAAaP,EAAgBzK,GACnC,OAAOkB,KAAK6O,KAAKM,eAAenN,UAE9B,UADoBhC,KAAKoP,OAAOlC,EAAQpD,GAAY,GAElD,MAAM,IAAIrJ,MAAM,eAKZa,eACRjB,EACAC,EACAM,GACA,OAAEI,IAEF,MAAMqO,EAAkB9F,EAAgB3I,GAClCmK,EAAOvC,EAAelI,GAE5B,MAAwB,OAApBD,EACKL,KAAK6O,KAAKS,oBAAoBtN,UACnC,MAAMuN,QAAcvP,KAAKwP,eAAetC,EAAQnC,EAAMsE,GACtD,GAAIE,QACIvP,KAAKyP,WAAWvC,EAAQ,CAACqC,SAC1B,GAAIvO,EAAQ,CACjB,MAAM0O,EAAc,OAAKL,GAAR,IAAyBtO,GAAIgK,IAC9C,UAAW/K,KAAKoP,OAAOlC,EAAQwC,GAAa,GAC1C,MAAM,IAAIjP,MAAM,eAGnBgO,GAGEzO,KAAK6O,KAAKS,oBAAoBtN,UACnC,MAAM2I,QAAa3K,KAAK2P,2BAA2BzC,EAAQ7M,EAAiB0K,GACtE6E,SAAiBjB,EACrBhE,EACCN,GAAQrK,KAAKwP,eAAetC,EAAQ7C,EAAKgF,KACzChB,OAAOJ,SACJjO,KAAKyP,WAAWvC,EAAQ0C,IAC7BnB,GAGK/N,YAIRL,EACAC,EACAC,GAEA,MAAMwK,EAAOvC,EAAelI,GAC5B,OAAON,KAAK6O,KAAKS,oBAAoBtN,UAAkB,MACrD,MAAMqI,SAAarK,KAAK2P,2BAA2BzC,EAAQ7M,EAAiB0K,IAAO,GACnF,QAAYjK,IAARuJ,EACF,OAAO,KAGT,wBADsBrK,KAAK6P,qBAAqB3C,EAAQ,CAAC7C,GAAM9J,IAChD,UAAf,QAAqB,MACpBkO,GAGK9N,eAIRN,EACAC,EACAC,GAEA,OAAOP,KAAK6O,KAAKS,oBAAoBtN,UACnC,IAAI2I,EACJ,GAAItK,EAAiB,CACnB,MAAM0K,EAAOvC,EAAelI,GAC5BqK,QAAa3K,KAAK2P,2BAA2BzC,EAAQ7M,EAAiB0K,OACjE,CACLJ,QAAauC,EAAOnN,KAAKC,KAAK8P,QAAQ,MACtC,MAAMC,EAAM/P,KAAKsO,OAAO7H,OAAS,EACjCkE,EAAOA,EAAK9E,IAAKnB,GAAMA,EAAEqE,OAAOgH,IAElC,OAAO/P,KAAK6P,qBAAqB3C,EAAQvC,EAAMpK,IAC9CkO,GAGKlN,eACRlB,EACAC,GAEA,MAAMyK,EAAOvC,EAAelI,GACtB0P,EAAczR,OAAOwB,KAAKC,KAAKD,MAGrC,OAFAiQ,EAAYlO,KAAK,MAEV9B,KAAK6O,KAAKS,oBAAoBtN,UACnC,MAAM2I,QAAa3K,KAAK2P,2BAA2BzC,EAAQ7M,EAAiB0K,GACtEkF,SAAetB,EACnBhE,EACCN,GAAQrK,KAAKkQ,oBAAoBhD,EAAQ7C,EAAK2F,KAC9C3B,OAAOJ,GAEV,GAAqB,IAAjBgC,EAAMxJ,OACR,OAAO,EAGT,MAAM0J,EAAWjD,EAAOkD,QAaxB,OAZAH,EAAM/N,QAASgM,IACb,MAAMe,EAAad,EAAcnO,KAAKiP,WAAYf,GAC5CgB,EAAgBf,EAAcnO,KAAKkP,cAAehB,GACxDiC,EAASE,OACP,EAAIpB,EAAWxI,OAASyI,EAAczI,OACtCzG,KAAK8P,QAAQ5B,EAAKnN,OACfkO,KACAC,EACHhB,EAAKnN,YAGHoP,EAAS7L,OACR2L,EAAMxJ,QACZgI,GAGGqB,QAAQQ,GACd,MAAQ,GAAEtQ,KAAKsO,UAAUgC,IAG3B,aACEpD,EADF,EAGEqD,GACkB,IAFlB,GAAExP,GAEgB,EAFT+I,EAES,YAClB,MAAMmF,EAAad,EAAcnO,KAAKiP,WAAYnF,GAC5CoF,EAAgBf,EAAcnO,KAAKkP,cAAepF,GAElD0G,EAAW,EAAIvB,EAAWxI,OAASyI,EAAczI,OACjDoG,EAAS,CACb7M,KAAK8P,QAAQ/O,MACVkO,KACAC,EACHD,EAAWxI,OACX,KACA1F,KACGxC,OAAOkS,QAAQ3G,GAAY4G,QAGhC,IAAKH,EACH,OAAOjO,cAAc4K,EAAOhC,IAAIsF,KAAa3D,IAG/C,MAAM/E,QAAeoF,EAClBkD,QACAlF,IAAIsF,KAAa3D,GACjBvI,OACH,IAAKwD,EACH,MAAM,IAAIrH,MAAM,mBAElB,OAAO6B,QAAQwF,EAAO,GAAG,IAG3B,qBACEoF,EACA7C,EACAgF,SAEMnC,EAAOyD,MAAM3Q,KAAK8P,QAAQzF,IAChC,MAAMC,QAAsBtK,KAAKkQ,oBAC/BhD,EACA7C,EACA9L,OAAOwB,KAAKC,KAAKD,MAAMsO,OAAQhN,GAAMgO,EAAgBhO,KAEvD,IAAKiJ,EACH,OAEF,MAAMG,EAAgB,KAAK4E,GAO3B,OANA9Q,OAAOwB,KAAK0K,GAAevI,QAASb,IAC9BiJ,EAAcjJ,KAAOoJ,EAAcpJ,YAC9BoJ,EAAcpJ,UACdiJ,EAAcjJ,MAGlB,CAAEgJ,MAAKI,gBAAeH,iBAG/B,iBACE4C,EACA0C,GAEA,MAAMgB,EAAWhB,EACd/J,IAAK0J,GAAUvP,KAAK6Q,eAAetB,IACnClB,OAAOJ,GAEV,IAAK2C,EAASnK,OACZ,OAGF,GAAwB,IAApBmK,EAASnK,OAAc,CACzB,MAAMqK,QAAgB5D,EAAOkD,QAC1BxP,OAAOgQ,EAAS,GAAG,GAAIA,EAAS,GAAG,IACnCtM,OAEH,IAAKwM,EACH,MAAM,IAAIrQ,MAAM,mBAElB,IAAKqQ,EAAQ,GAAG,GACd,MAAM,IAAIrQ,MAAM,aAElB,OAOF,UAJiCkO,EAC/BiC,EACCG,GAAe7D,EAAO8D,YAAYD,EAAW,GAAIA,EAAW,MAExC3P,KAAMzC,IAAOA,GAClC,MAAM,IAAI8B,MAAM,aAGlB,IAAIwQ,EAAQ/D,EAAOkD,QACnBQ,EAAS1O,QAAS6O,IAChBE,EAAQA,EAAMC,mBAAmBH,EAAW,GAAIA,EAAW,MAI7D,UAFsBE,EAAM3M,OAG1B,MAAM,IAAI7D,MAAM,mBAIZoQ,gBACN,IAAExG,EAAF,cAAOC,EAAP,cAAsBG,IAEtB,MAAM0G,EAAO5S,OAAOkS,QAAQhG,GAAeiG,OAC3C,IAAKS,EAAK1K,OACR,OAEF,MAAM2K,EAAkBjD,EAAcnO,KAAKiP,WAAYxE,GACjD4G,EAAqBlD,EAAcnO,KAAKkP,cAAezE,GACvD6G,EAAgBnD,EAAcnO,KAAKiP,WAAY3E,GAC/CiH,EAAmBpD,EAAcnO,KAAKkP,cAAe5E,GAC3D,GACEgH,EAAc7K,SAAW2K,EAAgB3K,QACzC8K,EAAiB9K,SAAW4K,EAAmB5K,OAE/C,MAAM,IAAIhG,MAAM,0CAclB,MAAO,CAZU,EAA2D,GAAtD2Q,EAAgB3K,OAAS4K,EAAmB5K,QACnD,CACbzG,KAAK8P,QAAQzF,MACV+G,KACAC,KACAC,KACAC,EACHH,EAAgB3K,OAChB2K,EAAgB3K,OAAS4K,EAAmB5K,OAC5C4D,KACG8G,IAKP,2BACEjE,EACAsE,EACA5G,GAEA,MAAMkG,QDlVH9O,eACLkL,EACAuE,GAEA,OAAKA,EAAShL,OAGPyG,EAAOkD,MAAMqB,GAAUnN,OAFrB,GC6UeoN,CACpBxE,EACAsE,EACG3L,IAAKwE,GAAQrK,KAAK8P,QAAQzF,IAC1BxE,IAAKxE,GAAOuJ,EAAS,CAAC,QAASvJ,KAAMuJ,GAAU,CAAC,UAAWvJ,KAEhE,IAAKyP,EACH,MAAM,IAAIrQ,MAAM,mBAElB,OAAOqQ,EACJjL,IAAI,EAAE,CAAEqI,KAA0BK,EAAUL,EAAMtD,IAClDyD,OAAOG,GACP3I,IAAI4D,GAGT,0BACEyD,EACAoD,EACA1F,GAEA,MAAMxL,EAAMY,KAAK8P,QAAQQ,GACzB,IAAIpC,EACJ,GAAItD,EAAQ,CACV,IAAKA,EAAOnE,OAAQ,CAGlB,aADqByG,EAAOyE,OAAOvS,GACnB,QAAK0B,EAEvBoN,QAAahB,EAAO0E,MAAMxS,KAAQwL,QAElCsD,QAAahB,EAAO2E,QAAQzS,GAE9B,MAAM0S,EAASvD,EAAUL,EAAMtD,GAC/B,OAAO4D,EAAesD,GAAUA,OAAShR,EAG3C,iCACEoM,EACAlH,EACAgF,GAEA,GAAgB,OAAZhF,EACF,MAAO,CAACgF,GAEV,MAAM8D,EAAY9O,KAAK+O,YAAY/I,GACnC,IAAK8I,EACH,MAAM,IAAIrO,MAAO,iBAAgBuF,iBAEnC,MAAM+L,EAAc,GAAEjD,KAAa9D,IAEnC,aADMkC,EAAOyD,MAAMoB,GACZ7E,EAAO8E,SAASD,IC3Y3B,MAAME,EAAavE,EAAgB,CACjC,0CACA,aACA,MACA,yCACA,4CACA,eACA,QACA,MACA,6CACA,mBACA,uCACA,MACA,YACC,kBAEGwE,EAAoB,CACxB,yCACA,4CACA,eACA,QACA,OAGIC,EAAc,CAClB,qCACA,6CACA,iBACA,oDACA,OAIIC,EAAsB1E,EAAgB,IACvCwE,EACH,YACC,iBAAkB,gBAAiB,MAGhCG,EAA8B3E,EAAgB,IAC/CyE,GACF,iBAAkB,gBAAiB,MAGhCG,EAAgB5E,EAAgB,IACjCwE,KACAC,EACH,YACC,iBAAkB,gBAAiB,MAGhCI,EAAgB7E,EAAgB,CACpC,4BACA,mBACA,mCACA,OACC,M,mIChEH,MAAM8E,EAAYrO,YAAOlC,GACV,iBAANA,GACO,oBAAdA,EAAE2B,SAGW,MAAM6O,EAWZ3S,YACY4S,EACAjG,EACA5L,EACA8R,GACjB,KAJiBD,cAIjB,KAHiBjG,MAGjB,KAFiB5L,UAEjB,KADiB8R,iBACjB,qBAfuC,IAevC,eAbc,GAad,eAX4C,IAW5C,4CAPe,GASjB,qBACEpP,EACAqP,GAEA,MAAM1U,QAAU8B,KAAK6S,gBACrB,IACE,aAAatP,EAAGrF,GADlB,cAGQ0U,aAAN,EAAMA,EAAW1U,IACjB8B,KAAK8S,iBAAiB5U,IAI1B,0BACEqF,EACAqP,GAEA,OAAOJ,EAAU,IAAMxS,KAAKmP,eAAe5L,EAAIqP,IAG1C9G,QACL,OAAI9L,KAAKmH,OACAxF,QAAQC,WAGjB5B,KAAKmH,QAAS,EACK,IAAfnH,KAAK+S,OACP/S,KAAKgT,UACErR,QAAQC,WAGV,IAAID,QAASC,IAClB5B,KAAKiT,UAAY,KACfjT,KAAKgT,UACLpR,QAKEoR,UACNhT,KAAKkT,YAAYhR,QAAShE,GAAMA,EAAEiV,cAClCnT,KAAKkT,YAAYzM,OAAS,EAG5B,sBACE,GAAIzG,KAAKmH,OACP,MAAM,IAAI1G,MAAM,qBAGlB,MAAM9B,EAAIqB,KAAKkT,YAAYE,MAC3B,GAAIzU,EAEF,OADAqB,KAAK+S,OAAS,EACPpU,EAET,GAAIqB,KAAK+S,MAAQ/S,KAAK2S,eAAgB,CACpC3S,KAAK+S,OAAS,EACd,MAAM7F,EAAS,IAAIlN,KAAK0S,YAAY1S,KAAKyM,IAAKzM,KAAKa,SAEnD,aADMqM,EAAOI,UDdJ,SAA0BJ,GAOvC,OANAA,EAAOmG,cAAc,MAAO,CAAEC,IAAKrB,IACnC/E,EAAOmG,cAAc,SAAU,CAAEC,IAAKhB,IACtCpF,EAAOmG,cAAc,cAAe,CAAEC,IAAKlB,IAC3ClF,EAAOmG,cAAc,qBAAsB,CAAEC,IAAKjB,IAClDnF,EAAOmG,cAAc,SAAU,CAAEC,IAAKf,IAE/BrF,ECQIqG,CAAiBrG,GAE1B,OAAO,IAAIvL,QAASC,IAClB5B,KAAKwT,MAAM1R,KAAKF,KAIZkR,iBAAiB5U,GACvB,MAAMuV,EAAIzT,KAAKwT,MAAME,QAMG,MALpBD,EACFA,EAAEvV,IAEF8B,KAAK+S,OAAS,EACd/S,KAAKkT,YAAYpR,KAAK5D,GACH,IAAf8B,KAAK+S,QACP,UAAA/S,KAAKiT,iBAAL,cAAAjT,SChGO,MAAM2T,UAAgBxI,EAC3BrL,YACW+O,GAEjBzH,MAAM,CAAChJ,EAAM2B,IAAS,IAAI6O,EAAgB5O,KAAK6O,KAAMzQ,EAAM2B,IAD3D,KADiB8O,OAKnB,qBAA4BpC,GAC1B,MAAQY,QAASqF,SAAsB,QAAN,qBAAa,IAE9C,OAAO,IAAIiB,EAAQ,IAAIlB,EACrBC,EACAjG,EACA,CAAEmH,aAAa,GAJU,IAStBvI,cAAgCjN,EAAc2B,GACnD,OAAOqH,MAAMiE,cAAcjN,EAAM2B,GAG5B8T,oBACL,OAAO7T,KAAK6O,KAGJzC,gBACR,OAAOpM,KAAK6O,KAAK/C,SCjCd,SAASgI,EAAYpP,GAC1B,MAAQ,IAAGA,EAAEV,QAAQ,WAAY,WCDnC,MAAM+P,EAAa,KAKnB,MAAMC,EAAa,KACZ,SAASC,EAAWC,GAGzB,MAAQ,IAAGA,EAAIlQ,QAAQgQ,EAAY,SAGrC,MAAMG,EAAS,WACR,SAASC,EACdC,EACAC,GAEA,OAAOD,EAAKrQ,QACVmQ,EACCzP,GAjBK,IAiBiB4P,EAAY5P,EAAEqE,OAAO,IAjB/B/E,QAAQ+P,EAAY,U,oXCOrC,MAAMQ,GAAa,CACjBC,aAAc,CACZ,kCACA,gCACA,uBACA,KACA9I,KAAK,IAEP+I,gBAAiB,sFAEjBC,aAAc,8DACdC,oBAAqB,0DACrBC,WAAY,0BAEZC,OAAQ,oDAERC,OAAQ,qEACRC,UAAW,kDAEXC,UAAW,4GAEXC,WAAY,oDACZC,WAAY,0BACZC,cAAe,4CACfC,UAAW,sCAEXC,OAAQ,mCACRC,UAAW,8BAiEb,SAASC,GAAS/L,GAChB,OFlGK,SAAsBA,GAC3B,MAAM1B,EAAmB,GAIzB,OAHAvJ,OAAOwB,KAAKyJ,GAAQtH,QAASb,IAC3ByG,EAAOhG,KAAM,GAAEgS,EAAYzS,OAAOyS,EAAYtK,EAAOnI,SAEhDyG,EAAO4D,KAAK,KE6FZ8J,CAAajM,EAAgBC,IAGtC,SAASiM,IACN1U,EAAI+H,GACL8B,GAEA,MAAM8K,EFjGD,SAAsBC,GAC3B,MAAM7N,EAAiC,GACvC,IAAI8N,EAAU,GACVC,EAAa,GACbC,GAAQ,EACZ,IAAK,IAAInW,EAAI,EAAGA,EAAIgW,EAAOlP,QAAS,CAClC,MAAMvI,EAAIyX,EAAOhW,GACjB,OAAQzB,GACN,IAAK,IACL,IAAK,KACL,IAAK,KACL,IAAK,KACC4X,IACFF,GAAW1X,GAEb,MACF,IAAK,KACH0X,GAAWD,EAAOhW,EAAI,GACtBA,GAAK,EACL,MACF,IAAK,IACHmW,GAASA,EACT,MACF,IAAK,IACCA,EACFF,GAAW1X,EACgB,MAAlByX,EAAOhW,EAAI,KACpBkW,EAAaD,EACbA,EAAU,GACVjW,GAAK,GAEP,MACF,IAAK,IACCmW,EACFF,GAAW1X,GAEX4J,EAAO+N,GAAcD,EACrBC,EAAa,GACbD,EAAU,IAEZ,MACF,QACEA,GAAW1X,EAGfyB,GAAK,EAKP,OAHIkW,IACF/N,EAAO+N,GAAcD,GAEhB9N,EE+CQiO,CAAajN,GAC5B4M,EAAO3U,GAAKA,EAEZ,MAAM+G,EAAkC,GAExC,OAAK8C,GAOLA,EAAO1I,QAASC,IACd2F,EAAO3F,GAAKyG,EAAiB8M,EAAOvT,MAE/B2F,IATLvJ,OAAOkS,QAAQiF,GAAQxT,QAAQ,EAAEb,EAAGqD,MAClCoD,EAAOzG,GAAKuH,EAAiBlE,KAExBoD,GASI,MAAMkO,WAA6CnW,IAGzDC,YACY+O,EACAoH,EACjBlW,EAAkB,GACDmH,EAAqB,CAAEC,QAAQ,I,UAEhDC,MAAMrH,GADN,KAJiB8O,OAIjB,KAHiBoH,YAGjB,KADiB/O,W,EANgE,I,EAOjF,mB,EAAA,M,sFAGAlH,KAAKqH,UAnGTrF,eACE6M,EACAoH,EACAlW,EAAoB,IAEpB,MAAM7B,QAAU2Q,EAAKvB,UACrB,UAGQpP,EAAEuJ,MAAM2M,EAAgBG,GAAWC,aAAc,CACrD0B,EAAGD,KAGL,MAAMpM,QAAgB3L,EAAEuJ,MAAM,CAC5B0O,QAAS,QACTC,KAAM7B,GAAWE,gBACjBxI,OAAQ,CAACgK,KAELI,EAAgB,IAAIzQ,IACxBiE,EAAQyM,KACLzQ,IAAKlH,GAAMA,EAAE,IACb0P,OAAQxQ,GAAOA,EAAE0Y,WAAcN,EAAF,OAAoBpY,EAAE0Y,WAAcN,EAAF,QAK9DO,EAAajY,OAAOkS,QAAQ1Q,GAClC,IAAK,IAAIlC,EAAI,EAAGA,EAAI2Y,EAAW/P,OAAQ5I,GAAK,EAAG,CAC7C,MAAOwD,EAAGqD,GAAK8R,EAAW3Y,GAC1B,GAAI6G,GAAKA,EAAEnC,OAAQ,CACjB,MAAMnE,EAAQ,GAAE6X,MAAc5U,IACzBgV,EAActQ,OAAO3H,UAClBF,EAAEuJ,MAAM2M,EAAgBG,GAAWI,oBAAqB,CAC5DuB,EAAGD,EACHQ,EAAGrY,IACF4F,QAAQ,OAAQiQ,EAAW5S,SAE3B,CACL,MAAMjD,EAAQ,GAAE6X,MAAc5U,IACzBgV,EAActQ,OAAO3H,UAClBF,EAAEuJ,MAAM2M,EAAgBG,GAAWG,aAAc,CACrDwB,EAAGD,EACHQ,EAAGrY,IACF4F,QAAQ,OAAQiQ,EAAW5S,MAIpC,MAAMqV,EAAkB,IAAIL,GAC5B,IAAK,IAAIxY,EAAI,EAAGA,EAAI6Y,EAAgBjQ,OAAQ5I,GAAK,EAAG,CAClD,MAAMiI,EAAM4Q,EAAgB7Y,SACtBK,EAAEuJ,MAAM2M,EAAgBG,GAAWK,WAAY,CACnDsB,EAAGD,EACHQ,EAAG3Q,MA9CT,QAoDE5H,EAAEyY,WAyCaC,CAAe/H,EAAMoH,EAAWlW,IAGjD,qBAA+D,IAAnC,GAAEgB,GAAiC,EAA1B8V,EAA0B,kBACvD7W,KAAK8W,cAAc,SAAUtO,EAAezH,GAAKwU,GAASsB,IAGlE,qBACE9V,EACAH,SAEMZ,KAAK8W,cAAc,YAAatO,EAAezH,GAAKwU,GAAS3U,IAGrE,qBACEP,EACAC,EAFF,GAIiB,IADf,GAAES,GACa,EADN8V,EACM,YACf,MAAMxM,EAAM7B,EAAelI,GACrBqV,EAASJ,GAASsB,GAExB,GAAwB,OAApBxW,QACIL,KAAK8W,cAAc,YAAanB,EAAQtL,OACzC,CACL,MAAM1L,QAAUqB,KAAK8W,cAAc,SAAUnB,EAAQtV,EAAiBgK,GACtE,QAAWvJ,IAAPC,GAAoBpC,EAAEoY,SAAW,GAAKpY,EAAE2X,KAAK,GAAG,KAAOvV,EACzD,MAAM,IAAIN,MAAM,qBAKtB,kBAIEJ,EACAC,EACAC,GAEA,IAAIwH,EAMJ,OAJEA,EADsB,OAApB1H,QACUL,KAAK8W,cAAc,YAAatO,EAAelI,UAE/CN,KAAK8W,cAAc,aAAczW,EAAiBmI,EAAelI,IAE1EyH,EAAIgP,SAGFtB,GAAc1N,EAAIuO,KAAK,GAAI/V,GAFzB,KAKX,qBAIEF,EACAC,EACAC,GAEA,IAAIwH,EAQJ,OAJEA,EAHG1H,EAE0B,OAApBA,QACGL,KAAK8W,cAAc,YAAatO,EAAelI,UAE/CN,KAAK8W,cAAc,gBAAiBzW,EAAiBmI,EAAelI,UAJpEN,KAAK8W,cAAc,cAM1B/O,EAAIuO,KAAKzQ,IAAKnB,GAAM+Q,GAAc/Q,EAAGnE,IAG9C,qBACEF,EACAC,GAEA,IAAIyH,EAMJ,OAJEA,EADsB,OAApB1H,QACUL,KAAK8W,cAAc,YAAatO,EAAelI,UAE/CN,KAAK8W,cAAc,SAAUzW,EAAiBmI,EAAelI,IAEpEyH,EAAIgP,SAGLD,cACNE,KACG/K,GAEH,GAAIjM,KAAKkH,SAASC,OAChB,MAAM,IAAI1G,MAAM,qBAGlB,IAAI6K,EAAStL,KAAKiX,cAAcD,GAMhC,OALK1L,IACHA,EAAS8I,EAAgBG,GAAWyC,GAAY,CAAEd,EAAGlW,KAAKiW,YAC1DjW,KAAKiX,cAAcD,GAAa1L,GAG3BtL,KAAK6O,KAAKpH,MAAM,CACrBrJ,KAAO,GAAE4B,KAAKiW,aAAae,IAC3Bb,QAAS,QACTC,KAAM9K,EACNW,YC1OS,MAAMiL,WAAmB/L,EAC9BrL,YACW+O,GAEjBzH,MAAM,CAAChJ,EAAM2B,IAAS,IAAIiW,GAAmBnH,EAAMzQ,EAAM2B,EAAMC,KAAKkH,WADpE,KADiB2H,OAKnB,qBAA4BpC,GAC1B,MAAM,KAAE0K,SAAe,QAAN,qBAAa,KACxBtI,EAAO,IAAIsI,EAAK,CAAEC,iBAAkB3K,IAE1C,aADMoC,EAAKpH,MAAM,yCACV,IAAIyP,GAAWrI,GAGjBxD,cAAgCjN,EAAc2B,GACnD,OAAOqH,MAAMiE,cAAcjN,EAAM2B,GAG5B8T,oBACL,OAAO7T,KAAK6O,KAGJzC,gBACR,OAAOpM,KAAK6O,KAAKwI,O,6rBCIrB,SAASC,GAAYxY,EAAe8L,GAClC,OAAOA,EACJxJ,KAAMyJ,GAAUtM,OAAOkB,UAAUC,eAAe1B,KAAKc,EAAO+L,IAGlD,MAAM0M,GAOZzX,YACY0X,EACA5M,EACA6M,GACjB,KAHiBD,iBAGjB,KAFiB5M,SAEjB,KADiB6M,UAGnB,UAAiBtX,GACf,OAAOH,KAAKwX,eAAetM,UAAUlL,KAAK0X,QAAQvX,IAGpD,UAIEf,EACAN,EACA8L,GAEA,GAAI5K,KAAK4K,OAAO1B,SAAS9J,GACvB,MAAM,IAAIqB,MAAM,+BAElB,MAAMsH,QAAY/H,KAAKwX,eAAe9Y,IAAIU,EAAKN,EAAO8L,GACtD,OAAO7C,EAAM/H,KAAK2X,UAAU5P,EAAK,CAAE,CAAC3I,GAAMN,IAAW,KAGvD,aAIEM,EACAN,EACA8L,GAEA,QAAY9J,IAAR1B,GAAqBY,KAAK4K,OAAO1B,SAAS9J,GAC5C,MAAM,IAAIqB,MAAM,+BAElB,MAAMsH,QAAY/H,KAAKwX,eAAeI,OAAOxY,EAAMN,EAAQ8L,GACrDiN,OAAiB/W,IAAR1B,EAAqB,CAAE,CAACA,GAAMN,QAAUgC,EACvD,OAAOa,QAAQmF,IAAIiB,EAAIlC,IAAKnB,GAAM1E,KAAK2X,UAAUjT,EAAGmT,KAGtD,aACEzY,EACAN,EACA8B,EACAC,GAEA,GAAIb,KAAK4K,OAAO1B,SAAS9J,GACvB,MAAM,IAAIqB,MAAM,kCAElB,MAAMgE,QAAkBzE,KAAK0X,QAAQ9W,EAAQ,CAAE,CAACxB,GAAMN,IACtD,OAAOkB,KAAKwX,eAAe5W,OAAOxB,EAAKN,EAAO2F,EAAW5D,GAG3D,aACEzB,EACAN,GAEA,GAAIkB,KAAK4K,OAAO1B,SAAS9J,GACvB,MAAM,IAAIqB,MAAM,kCAElB,IAAKT,KAAKyX,QAAQK,UAChB,OAAO9X,KAAKwX,eAAenH,OAAOjR,EAAKN,GAGzC,MAAMmR,QAAcjQ,KAAKwX,eAAeI,OAAOxY,EAAKN,EAAO,CAAC,OAK5D,aAJM6C,QAAQmF,IAAImJ,EAAMpK,IAAI7D,gBACpBhC,KAAKyX,QAAQK,UAAW5J,SACxBlO,KAAKwX,eAAenH,OAAO,KAAMnC,EAAKnN,OAEvCkP,EAAMxJ,OAaf,cACE/B,EACAmT,GAEA,IAAIE,EACJ,GAAI/X,KAAKyX,QAAQO,SAAWV,GAAY5S,EAAG1E,KAAK4K,QAAS,CACvD,MAAMqN,EAAYJ,EAAQ,SAAKA,GAAUnT,GAAMA,EAC/CqT,QAAkB/X,KAAKyX,QAAQO,QAAQC,GAEzC,MAAMxT,EAAY,MAAKC,GAMvB,aALM/C,QAAQmF,IAAI9G,KAAK4K,OAAO/E,IAAI7D,UAC5BzD,OAAOkB,UAAUC,eAAe1B,KAAK0G,EAAGrD,KAC1CoD,EAAUpD,SAAWrB,KAAKyX,QAAQS,KAAK7W,EAAIqD,EAAUrD,GAAI0W,OAGtDtT,EAaT,gBACEC,EACAmT,GAEA,IAAIE,EACJ,GAAI/X,KAAKyX,QAAQU,WAAab,GAAY5S,EAAG1E,KAAK4K,QAAS,CACzD,MAAMqN,EAAYJ,EAAQ,SAAKA,GAAUnT,GAAMA,EAC/CqT,QAAkB/X,KAAKyX,QAAQU,UAAUF,GAE3C,MAAMxT,EAAY,MAAKC,GAMvB,aALM/C,QAAQmF,IAAI9G,KAAK4K,OAAO/E,IAAI7D,UAC5BzD,OAAOkB,UAAUC,eAAe1B,KAAK0G,EAAGrD,KAC1CoD,EAAUpD,SAAWrB,KAAKyX,QAAQW,OAAO/W,EAAIqD,EAAUrD,GAAI0W,OAGxDtT,GC3KI,MAAM4T,GAGZvY,YACYwY,G,UACjB,KADiBA,W,EACjB,K,EAAA,U,EAJyB,IAAI1O,I,6FAM/B,kBAAyBxK,EAAQmZ,GAC/B,MAAMzZ,EAAQkB,KAAKwY,QAAQ9Z,IAAIU,GAC/B,GAAIY,KAAKwY,QAAQzS,OAAO3G,GAEtB,OADAY,KAAKwY,QAAQxO,IAAI5K,EAAKN,GACfA,EAET,MAAM+M,QAAgB0M,EAAKnZ,GAG3B,OAFAY,KAAKwY,QAAQxO,IAAI5K,EAAKyM,GACtB7L,KAAKyY,QACE5M,EAGFwE,OAAOjR,GACZY,KAAKwY,QAAQzS,OAAO3G,GAGdqZ,QACN,KAAOzY,KAAKwY,QAAQ3R,KAAO7G,KAAKsY,UAC9BtY,KAAKwY,QAAQzS,OAAO/F,KAAKwY,QAAQzY,OAAO2Y,OAAO5Z,Q,uBCtBrD,MAAM6Z,GAAM,cACNC,GAAUjU,OAAOqE,KAAQ2P,GAAF,IAAU,QAmCxBE,OAhC2C,CACxDC,QAAS,CAAC1Z,EAAgBsF,KACxB,MAAMqU,EAAKC,KAAOC,YAJP,IAKLC,EAASF,KAAOG,eAAeR,GAAKvZ,EAAK2Z,GACzCK,EAAOF,EAAOtY,OAAO8D,GACrB2U,EAAQH,EAAOG,QACrB,OAAO1U,OAAOyE,OAAO,CAACwP,GAASG,EAAIK,EAAMC,KAG3CC,QAAS,CAACla,EAAgBsF,KACxB,IAAKA,EAAE6U,MAAM,EAAGX,GAAQnS,QAAQ+S,OAAOZ,IACrC,MAAM,IAAInY,MAAM,gCAGlB,MAAMsY,EAAKrU,EAAE6U,MAAMX,GAAQnS,OAAQmS,GAAQnS,OAhBhC,IAiBLgT,EAAY/U,EAAE6U,MAAMX,GAAQnS,OAjBvB,IAmBLiT,EAAWV,KAAOW,iBAAiBhB,GAAKvZ,EAAK2Z,GAC7CK,EAAOM,EAAS9Y,OAAO6Y,GACvBJ,EAAQK,EAASL,QAEvB,OAAO1U,OAAOyE,OAAO,CAACgQ,EAAMC,KAG9BO,YAAa,IAAiBZ,KAC3Ba,gBAAgBb,KAAOC,YAAY,KAEtCa,aAAe1a,GAA2BA,EAAI2a,SAE9CC,eAAiBlR,GAA4BkQ,KAAOa,gBAAgB/Q,ICVtE,SAASmR,GACPxC,GAKA,MAAO,CAAC7M,EAAc4M,IAChB5M,GAAU4M,EAELC,EAAQ7M,EAAQ4M,GAElBC,EA4BX,SAASyC,GACPnP,GACA,WACEoP,EAAatB,GADf,SAEEuB,GAAW,GACgC,IAE7C,MAAMhb,EAAM+a,EAAWH,eAAejP,GAEtC,OAAOkP,GAAc,CACnBrP,EACA4M,IACG,IAAID,GAAuCC,EAAgB5M,EAAQ,CACtEsN,KAAM,CAAC7W,EAAGqD,IAAgCyV,EAAWrB,QAAQ1Z,EAAK+J,EAAkBzE,IACpF0T,OAAQpW,MAAOX,EAAGqD,KAChB,KAAMA,aAAaC,QAAS,CAC1B,GAAIyV,EACF,OAAO1V,EAET,MAAM,IAAIjE,MAAM,oBAElB,OAAO4I,QAA0B8Q,EAAWb,QAAQla,EAAKsF,QAe/D,SAAS2V,GACPC,GACA,WACEH,EAAatB,GADf,SAEEuB,GAAW,EAFb,UAGEG,EAAY,GACyD,IAEvE,MAAMC,EAAQ,IAAInC,GAAmBkC,GAE/BE,EAAUzY,MACd0Y,EACAlR,KAEA,MAAM,GAAEzI,GAAOyI,EAEf,QAAW1I,IAAPC,EACF,MAAM,IAAIN,MAAM,kCAGlB,OAAO+Z,EAAMG,YAAY5Z,EAAIiB,UAC3B,MAAMkM,QAAaoM,EAAc5b,IAAI,KAAMqC,EAAI,CAAC,QAChD,GAAImN,EACF,OAAOiM,EAAWH,eAAe9L,EAAK9O,KAExC,IAAKsb,EACH,MAAM,IAAIja,MAAM,sCAElB,MAAMrB,QAAY+a,EAAWP,cAE7B,aADMU,EAAcpP,IAAI,CAAEnK,KAAI3B,IAAK+a,EAAWL,aAAa1a,KACpDA,KAILwb,EAAY5Y,OAASjB,eACnBuZ,EAAcjK,OAAO,KAAMtP,GACjCyZ,EAAMnK,OAAOtP,IAIf,OAAOkZ,GAAkB,CACvBrP,EACA4M,IACG,IAAID,GAAsCC,EAAgB5M,EAAQ,CACrEsN,KAAM,CAAC7W,EAAGqD,EAAGtF,IAAkC+a,EAAWrB,QAAQ1Z,EAAK+J,EAAkBzE,IACzF0T,OAAQpW,MAAOX,EAAGqD,EAAGtF,KACnB,KAAMsF,aAAaC,QAAS,CAC1B,GAAIyV,EACF,OAAO1V,EAET,MAAM,IAAIjE,MAAM,oBAElB,OAAO4I,QAA0B8Q,EAAWb,QAAQla,EAAKsF,KAE3DsT,QAASyC,EAAQpb,KAAK,MAAM,GAC5B8Y,UAAWsC,EAAQpb,KAAK,MAAM,GAC9ByY,UAAW8C,KAgBf,SAASC,GACPC,EACAR,EACAzZ,EAA6E,IAE7E,MAAMka,EAAOla,EAMb,OAAOwZ,GALQH,GAAaY,EAAYC,EACfC,GACvB,CAAC,OACDV,GAEuCS,G,+BCvK3C,MAAME,GAAeC,qBAA0BC,KAAKC,MAC9CC,GAAiBH,qBAA0BC,KAAKG,QAEhDC,GAAoB5W,OAAO4D,GAAG,GAqC7B,SAASiT,GACd5Q,EACA4M,EACA3W,EAA2B,IAE3B,OAAO,IAAI0W,GAAuCC,EAAgB5M,EAAQ,CACxEsN,KAAM,CAAC7W,EAAGqD,IAzCd1C,eAA6B0C,GAAY,0BACvC+W,EAA4B,MAE5B,MAAM3R,EAAaX,EAAkBzE,GACrC,GAAIoF,EAAWrD,QAAUgV,EAA2B,CAClD,MAAMC,QAAgBT,GAAanR,GACnC,GAAI4R,EAAQjV,OAASqD,EAAWrD,OAAS,EACvC,OAAOiV,EAGX,OAAO/W,OAAOyE,OAAO,CAACmS,GAAmBzR,IA+BN6R,CAAcjX,EAAG7D,GAClDuX,OAAQ,CAAC/W,EAAGqD,IA7BhB1C,eAA+B0C,GAAW,SACxC0V,GAAW,EAD6B,eAExCwB,GAAiB,IAEjB,KAAMlX,aAAaC,QAAS,CAC1B,GAAIyV,EACF,OAAO1V,EAET,MAAM,IAAIjE,MAAM,4BAElB,GAAa,KAATiE,EAAE,IAAwB,MAATA,EAAE,GACrB,OAAO2E,QAA0BgS,GAAe3W,IAElD,GAAIA,EAAE,KAAO6W,GAAkB,GAC7B,OAAOlS,EAAoB3E,EAAE4E,SAAS,IAExC,GAAI8Q,GAAYwB,EACd,OAAOlX,EAET,MAAM,IAAIjE,MAAM,4BAUkBob,CAAgBnX,EAAG7D,K,wVCtDvD,MAAMib,GAIGhc,YACY0X,EACAuE,EACAC,GACjB,KAHiBxE,iBAGjB,KAFiBuE,aAEjB,KADiBC,mBAGnB,UAAiB7b,GACf,OAAOH,KAAKwX,eAAetM,IAAI/K,GAGjC,UAIEE,EACAC,EACAC,GAEA,MAAMwH,QAAY/H,KAAKwX,eAAe9Y,IACpC2B,EACAC,EACAN,KAAKic,iBAAiB1b,IAExB,OAAOwH,EAAM/H,KAAKkc,eAAenU,EAAKxH,GAAoB,KAG5D,aAIEF,EACAC,EACAC,GAOA,aALmBP,KAAKwX,eAAeI,OACrCvX,EACAC,EACAN,KAAKic,iBAAiB1b,KAEZsF,IAAKkC,GAAQ/H,KAAKkc,eAAenU,EAAKxH,IAGpD,aACEF,EACAC,EACAM,EACAC,GAEA,OAAOb,KAAKwX,eAAe5W,OAAOP,EAAiBC,EAAaM,EAAQC,GAG1E,aACER,EACAC,GAEA,OAAON,KAAKwX,eAAenH,OAAOhQ,EAAiBC,GAG7C2b,iBAEN1b,GACA,OAAIA,GAAoBP,KAAKgc,iBACpB,IAAIzb,KAAqBP,KAAKgc,kBAEhCzb,EAGD2b,eACNnU,EACAxH,GAEA,GAAIA,IAAqBA,EAAiBa,KAAM+a,GAASnc,KAAK+b,WAAWI,IACvE,OAAOpU,EAET,MAAMD,E,kWAAyB,IAAKC,GASpC,OARcxH,GAAoBhC,OAAOwB,KAAKC,KAAK+b,aAC7C7Z,QAAS9C,IACb,MAAM+c,EAAO/c,EACPgd,EAAYpc,KAAK+b,WAAWI,GAC9BC,IACFtU,EAAOqU,GAAQC,EAAUrU,EAAIoU,GAAOpU,MAGjCD,GAuCIuU,OArBf,SAIEL,EACAD,EACAvE,GAEA,OAAIA,EACK,IAAIsE,GACTtE,EACAuE,EACAC,GAGG,IAAIF,GACTC,EACAC,IC3FWM,UCnCA,MACb,qBAA4B7P,GAC1B,IAAI8P,EACJ,GAAI9P,EAAI8J,WAAW,UACjBgG,EAAU/P,OACL,GAAIC,EAAI8J,WAAW,WACxBgG,EAAUtP,OACL,GAAIR,EAAI8J,WAAW,SACxBgG,EAAU5I,MACL,KAAIlH,EAAI8J,WAAW,YAGxB,MAAM,IAAI9V,MAAO,2CAA0CgM,GAF3D8P,EAAUrF,GAKZ,IACE,aAAaqF,EAAQjP,QAAQb,GAC7B,MAAOxK,GACP,MAAM,IAAIxB,MAAO,kCAAiCgM,OAASxK,EAAE2B","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"collection-storage\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"collection-storage\"] = factory();\n\telse\n\t\troot[\"collection-storage\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","import type { Collection, UpdateOptions } from './Collection';\nimport type { IDable } from './IDable';\nimport type { DBKeys } from './DB';\n\nexport default abstract class BaseCollection<T extends IDable> implements Collection<T> {\n  // actually read publicly by BaseDB but we don't want this to be a user-accessible property\n  protected internalReady?: () => Promise<void>;\n\n  private innerPreAct: () => Promise<void> | void;\n\n  protected constructor(\n    protected readonly keys: DBKeys<T>,\n  ) {\n    this.innerPreAct = this.preAct.bind(this);\n  }\n\n  public async add(entry: T): Promise<void> {\n    await this.innerPreAct();\n    return this.internalAdd(entry);\n  }\n\n  public async get<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    searchAttribute: K,\n    searchValue: T[K],\n    returnAttributes?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    if (!this.isIndexed(searchAttribute)) {\n      throw new Error(`No index for ${searchAttribute}`);\n    }\n    await this.innerPreAct();\n    return this.internalGet(searchAttribute, searchValue, returnAttributes);\n  }\n\n  public async getAll<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    searchAttribute?: K,\n    searchValue?: T[K],\n    returnAttributes?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    if (searchAttribute && !this.isIndexed(searchAttribute)) {\n      throw new Error(`No index for ${searchAttribute}`);\n    }\n    await this.innerPreAct();\n    return this.internalGetAll(searchAttribute, searchValue, returnAttributes);\n  }\n\n  public async update<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n    update: Partial<T>,\n    options: UpdateOptions = {},\n  ): Promise<void> {\n    if (searchAttribute === 'id' && update.id !== undefined && update.id !== searchValue) {\n      throw new Error('Cannot update ID');\n    }\n    if (options.upsert) {\n      if (searchAttribute !== 'id') {\n        throw new Error(`Can only upsert by ID, not ${searchAttribute}`);\n      }\n      let withoutId = update;\n      if (Object.prototype.hasOwnProperty.call(update, 'id')) {\n        withoutId = { ...update };\n        delete withoutId.id;\n      }\n      await this.innerPreAct();\n      return this.internalUpsert(searchValue as T['id'], withoutId, options);\n    }\n    if (!this.isIndexed(searchAttribute)) {\n      throw new Error(`No index for ${searchAttribute}`);\n    }\n    if (\n      !this.isIndexUnique(searchAttribute) &&\n      Object.keys(update).some((k) => this.isIndexUnique(k))\n    ) {\n      throw new Error('duplicate');\n    }\n\n    await this.innerPreAct();\n    return this.internalUpdate(searchAttribute, searchValue, update, options);\n  }\n\n  public async remove<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n  ): Promise<number> {\n    if (!this.isIndexed(searchAttribute)) {\n      throw new Error(`No index for ${searchAttribute}`);\n    }\n    await this.innerPreAct();\n    return this.internalRemove(searchAttribute, searchValue);\n  }\n\n  // Subclass constructors can call this with a promise that will resolve when\n  // they are ready to be used. BaseCollection will automatically ensure that\n  // other interactions are queued until this promise resolves.\n  // (this call will always succeed; you can safely ignore the promise returned)\n  protected async initAsync(wait: Promise<unknown>): Promise<void> {\n    const pending: [() => void, (e: Error) => void][] = [];\n    const addPending = (): Promise<void> => new Promise((resolve, reject) => {\n      pending.push([resolve, reject]);\n    });\n    this.internalReady = addPending;\n    this.innerPreAct = async (): Promise<void> => {\n      await addPending();\n      return this.preAct();\n    };\n    try {\n      await wait;\n    } catch (e) {\n      this.internalReady = (): Promise<void> => Promise.reject(e);\n      this.innerPreAct = (): void => { throw e; };\n      pending.forEach((f) => f[1](e));\n      return;\n    }\n    this.internalReady = undefined;\n    this.innerPreAct = this.preAct.bind(this);\n    pending.forEach((f) => f[0]());\n  }\n\n  protected isIndexed(attribute: string): boolean {\n    return (\n      attribute === 'id' ||\n      this.keys[attribute as keyof DBKeys<T>] !== undefined\n    );\n  }\n\n  protected isIndexUnique(attribute: string): boolean {\n    const keyOptions = this.keys[attribute as keyof DBKeys<T>];\n    return (\n      attribute === 'id' ||\n      Boolean(keyOptions && keyOptions.unique)\n    );\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  protected preAct(): Promise<void> | void {}\n\n  protected async internalGet<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    searchAttribute: K,\n    searchValue: T[K],\n    returnAttributes?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    const all = await this.internalGetAll(searchAttribute, searchValue, returnAttributes);\n    return all[0] ?? null;\n  }\n\n  protected internalUpsert(\n    id: T['id'],\n    update: Partial<T>,\n    options: UpdateOptions,\n  ): Promise<void> {\n    return this.internalUpdate('id', id, update, options);\n  }\n\n  protected abstract internalAdd(entry: T): Promise<void>;\n\n  protected abstract internalGetAll<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    searchAttribute?: K,\n    searchValue?: T[K],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]>;\n\n  protected abstract internalUpdate<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n    update: Partial<T>,\n    options: UpdateOptions,\n  ): Promise<void>;\n\n  protected abstract internalRemove<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n  ): Promise<number>;\n}\n","module.exports = require(\"crypto\");","module.exports = require(\"mongodb\");","function sleep(millis: number): Promise<void> | null {\n  return new Promise((resolve): any => setTimeout(resolve, millis));\n}\n\nexport default (shouldRetry: (e: any) => boolean, {\n  timeoutMillis = 60000,\n  initialDelayMillis = 20,\n  maxDelayMillis = 5000,\n  delayGrowth = 2,\n  jitter = true,\n} = {}) => async <T>(fn: () => Promise<T> | T): Promise<T> => {\n  const limit = Date.now() + timeoutMillis;\n  let currentDelay = initialDelayMillis;\n  for (let attempt = 1; ; attempt += 1) {\n    try {\n      // eslint-disable-next-line no-await-in-loop\n      return await fn();\n    } catch (e) {\n      if (!shouldRetry(e)) {\n        throw e;\n      }\n\n      const delay = (\n        Math.min(currentDelay, maxDelayMillis) *\n        (jitter ? Math.random() : 1)\n      );\n      currentDelay *= delayGrowth;\n\n      if (Date.now() + delay > limit) {\n        e.message += ` (timeout after ${attempt} attempts)`;\n        throw e;\n      }\n\n      // eslint-disable-next-line no-await-in-loop\n      await sleep(delay);\n    }\n  }\n};\n","module.exports = require(\"zlib\");","module.exports = require(\"util\");","module.exports = require(\"url\");","import {\n  Collection as MCollection,\n  Binary as MBinary,\n  IndexSpecification,\n  MongoError,\n} from 'mongodb';\nimport type { IDable } from '../interfaces/IDable';\nimport BaseCollection from '../interfaces/BaseCollection';\nimport type { KeyOptions } from '../interfaces/Collection';\nimport type { DBKeys } from '../interfaces/DB';\nimport type { StateRef } from '../interfaces/BaseDB';\nimport retry from '../helpers/retry';\n\nconst MONGO_ID = '_id';\nconst ID = 'id';\n\nconst DOT_REG = /\\./g;\nfunction fieldNameToMongo(name: string): string {\n  if (name === ID) {\n    return MONGO_ID;\n  }\n  return encodeURIComponent(name).replace(DOT_REG, '%2E');\n}\n\nfunction fieldNameFromMongo(name: string): string {\n  if (name === MONGO_ID) {\n    return ID;\n  }\n  return decodeURIComponent(name);\n}\n\nconst MONGO_ERROR_IDX = /^.*? index: ([^ ]+) dup key:.*$/;\nfunction getErrorIndex(e: MongoError): string {\n  return MONGO_ERROR_IDX.exec(e.message)?.[1] || '';\n}\n\nconst withUpsertRetry = retry((e) => (\n  e instanceof MongoError &&\n  e.code === 11000 &&\n  getErrorIndex(e) === '_id_'\n));\n\nfunction convertToMongo<T extends Partial<IDable>>(\n  value: T,\n): Record<string, unknown> {\n  const converted: Record<string, unknown> = {};\n  Object.keys(value).forEach((k) => {\n    let v = (value as any)[k];\n    if (v instanceof Buffer) {\n      v = new MBinary(v);\n      // eslint-disable-next-line no-underscore-dangle\n    } else if (typeof v === 'object' && v._bsontype) {\n      throw new Error('Must use Buffer to provide binary data');\n    }\n    converted[fieldNameToMongo(k)] = v;\n  });\n  return converted;\n}\n\nfunction convertFromMongo<T extends Partial<IDable>>(\n  value: Record<string, unknown> | null,\n): T | null {\n  if (!value) {\n    return null;\n  }\n  const converted: T = {} as any;\n  Object.keys(value).forEach((k) => {\n    let v = (value as any)[k];\n    // eslint-disable-next-line no-underscore-dangle\n    if (typeof v === 'object' && v._bsontype === 'Binary') {\n      v = v.buffer;\n    }\n    (converted as any)[fieldNameFromMongo(k)] = v;\n  });\n  return converted;\n}\n\nfunction makeMongoProjection(\n  names?: readonly string[],\n): Record<string, boolean> {\n  const projection: Record<string, boolean> = {};\n  if (names) {\n    projection[MONGO_ID] = false;\n    names.forEach((fieldName) => {\n      projection[fieldNameToMongo(fieldName)] = true;\n    });\n  }\n  return projection;\n}\n\ninterface MongoIndex {\n  name: string;\n  key: Record<string, -1 | 0 | 1 | 'hashed'>;\n  unique?: boolean;\n}\n\nfunction makeIndex(keyName: string, options: KeyOptions = {}): IndexSpecification {\n  const unique = Boolean(options.unique);\n  const mongoKey = fieldNameToMongo(keyName);\n  return {\n    key: { [mongoKey]: unique ? 1 : 'hashed' },\n    unique,\n  };\n}\n\nfunction indicesMatch(a: IndexSpecification, b: IndexSpecification): boolean {\n  if (Boolean(a.unique) !== Boolean(b.unique)) {\n    return false;\n  }\n  const aKey = a.key as Record<string, unknown>;\n  const bKey = b.key as Record<string, unknown>;\n  const keys = Object.keys(aKey);\n  if (Object.keys(bKey).length !== keys.length) {\n    return false;\n  }\n  return keys.every((k) => (aKey[k] === bKey[k]));\n}\n\nasync function configureCollection(\n  collection: MCollection,\n  keys: DBKeys<any> = {},\n): Promise<void> {\n  const existing: MongoIndex[] = await collection.indexes().catch(() => []);\n  const idxToCreate: IndexSpecification[] = [];\n  const idxToDelete = new Set(existing.map((idx) => idx.name));\n  idxToDelete.delete('_id_'); // MongoDB implicit primary key\n\n  Object.keys(keys)\n    .map((keyName) => makeIndex(keyName, keys[keyName]))\n    .forEach((index) => {\n      const match = existing.find((idx) => indicesMatch(idx, index));\n      if (match) {\n        idxToDelete.delete(match.name);\n      } else {\n        idxToCreate.push(index);\n      }\n    });\n  if (idxToCreate.length) {\n    await collection.createIndexes(idxToCreate);\n  }\n  if (idxToDelete.size) {\n    await Promise.all([...idxToDelete].map((idxName) => collection.dropIndex(idxName)));\n  }\n}\n\nexport default class MongoCollection<T extends IDable> extends BaseCollection<T> {\n  public constructor(\n    private readonly collection: MCollection,\n    keys: DBKeys<T> = {},\n    private readonly stateRef: StateRef = { closed: false },\n  ) {\n    super(keys);\n    this.initAsync(configureCollection(collection, keys));\n  }\n\n  protected preAct(): void {\n    if (this.stateRef.closed) {\n      throw new Error('Connection closed');\n    }\n  }\n\n  protected async internalAdd(value: T): Promise<void> {\n    await this.collection.insertOne(convertToMongo(value));\n  }\n\n  protected async internalUpsert(\n    id: T['id'],\n    update: Partial<T>,\n  ): Promise<void> {\n    await withUpsertRetry(() => this.collection.updateOne(\n      convertToMongo({ id }),\n      { $set: convertToMongo(update) },\n      { upsert: true },\n    ));\n  }\n\n  protected async internalUpdate<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n    update: Partial<T>,\n  ): Promise<void> {\n    const query = convertToMongo({ [searchAttribute]: searchValue });\n    const mongoUpdate = { $set: convertToMongo(update) };\n    if (this.isIndexUnique(searchAttribute)) {\n      await this.collection.updateOne(query, mongoUpdate);\n    } else {\n      await this.collection.updateMany(query, mongoUpdate);\n    }\n  }\n\n  protected async internalGet<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    searchAttribute: K,\n    searchValue: T[K],\n    returnAttributes?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    const raw = await this.collection.findOne(\n      convertToMongo({ [searchAttribute]: searchValue }),\n      { projection: makeMongoProjection(returnAttributes) },\n    );\n    return convertFromMongo<T>(raw);\n  }\n\n  protected async internalGetAll<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    searchAttribute?: K,\n    searchValue?: T[K],\n    returnAttributes?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    const cursor = this.collection.find(\n      searchAttribute ? convertToMongo({ [searchAttribute]: searchValue }) : {},\n      { projection: makeMongoProjection(returnAttributes) },\n    );\n\n    const result: Pick<T, F[-1]>[] = [];\n    await cursor.forEach((raw) => result.push(convertFromMongo<T>(raw)!));\n\n    return result;\n  }\n\n  protected async internalRemove<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n  ): Promise<number> {\n    const result = await this.collection.deleteMany(\n      convertToMongo({ [searchAttribute]: searchValue }),\n    );\n    return result.deletedCount || 0;\n  }\n}\n","module.exports = require(\"ioredis\");","module.exports = require(\"pg\");","// B = base64 binary\n// b = raw binary (*Bin functions only)\n// s = raw utf8 string\n// t = true\n// f = false\n// n = null\n// J = JSON (also accepts any plain JSON value for compatibility)\n\nconst JSON_INIT_CHARS = '{[\"0123456789-'; // t/f/n are dedicated values\nconst MARK_BINARY = 'b'.charCodeAt(0);\nconst MARK_STRING = 's'.charCodeAt(0);\n\nconst MARK_BINARY_BUFF = Uint8Array.of(MARK_BINARY);\n\nexport function canonicalJSON(o: Record<string, unknown> | undefined): string {\n  if (!o) {\n    return 'null';\n  }\n  // string comparison is intended\n  /* eslint-disable-next-line @typescript-eslint/require-array-sort-compare */\n  const content = Object.keys(o)\n    .sort()\n    .map((k) => `${JSON.stringify(k)}:${JSON.stringify(o[k])}`)\n    .join(',');\n  return `{${content}}`;\n}\n\nexport function serialiseValue(value: unknown): string {\n  if (value instanceof Buffer) {\n    return `B${value.toString('base64')}`;\n  }\n  if (typeof value === 'string') {\n    return `s${value}`;\n  }\n  if (typeof value === 'boolean') {\n    return value ? 't' : 'f';\n  }\n  if (value === null) {\n    return 'n';\n  }\n  return `J${JSON.stringify(value)}`;\n}\n\nexport function deserialiseValue(value: string): unknown {\n  const type = value[0];\n  const data = value.substr(1);\n  switch (type) {\n    case 'B': return Buffer.from(data, 'base64');\n    case 's': return data;\n    case 't': return true;\n    case 'f': return false;\n    case 'n': return null;\n    case 'J': return JSON.parse(data);\n    default:\n      if (JSON_INIT_CHARS.includes(type)) {\n        return JSON.parse(value);\n      }\n      throw new Error(`Unknown data type ${type}`);\n  }\n}\n\nexport function serialiseValueBin(value: unknown): Buffer {\n  if (value instanceof Buffer) {\n    return Buffer.concat([MARK_BINARY_BUFF, value]);\n  }\n  return Buffer.from(serialiseValue(value), 'utf8');\n}\n\nexport function deserialiseValueBin(value: Buffer | string): unknown {\n  if (typeof value === 'string') {\n    return deserialiseValue(value);\n  }\n\n  const type = value[0];\n  if (type === MARK_BINARY) {\n    return value.subarray(1);\n  }\n  if (type === MARK_STRING) {\n    return value.subarray(1).toString('utf8');\n  }\n  return deserialiseValue(value.toString('utf8'));\n}\n\nexport function serialiseRecord<T>(\n  record: T,\n): Record<string, string> {\n  const result: Record<string, string> = {};\n  Object.keys(record).forEach((k) => {\n    result[k] = serialiseValue((record as any)[k]);\n  });\n  return result;\n}\n\nexport function deserialiseRecord(\n  record: Record<string, string | null>,\n): Record<string, unknown> {\n  const result: Record<string, any> = {};\n  Object.keys(record).forEach((k) => {\n    const v = record[k];\n    if (v) {\n      result[k] = deserialiseValue(v);\n    }\n  });\n  return result;\n}\n","import type { IDable } from '../interfaces/IDable';\nimport BaseCollection from '../interfaces/BaseCollection';\nimport type { DBKeys } from '../interfaces/DB';\nimport type { StateRef } from '../interfaces/BaseDB';\nimport {\n  serialiseValue,\n  serialiseRecord,\n  deserialiseRecord,\n} from '../helpers/serialiser';\n\nfunction sleep(millis: number): Promise<void> | void {\n  if (!millis) {\n    return undefined;\n  }\n\n  // Simulate data access delays to ensure non-flakey e2e tests, etc.\n  return new Promise((resolve): any => setTimeout(resolve, millis));\n}\n\nfunction applyFilter<T, F extends readonly (keyof T)[]>(\n  data: T,\n  fields?: F,\n): Pick<T, F[-1]> {\n  if (!fields) {\n    return data;\n  }\n  const result: Pick<T, F[-1]> = {} as any;\n  fields.forEach((field) => {\n    result[field] = data[field];\n  });\n  return result;\n}\n\nexport default class MemoryCollection<T extends IDable> extends BaseCollection<T> {\n  private readonly data: Map<string, Record<string, string>>;\n\n  private readonly indices: Partial<Record<keyof T, Map<string, Set<string>>>> = {};\n\n  public constructor(\n    keys: DBKeys<T> = {},\n    private readonly simulatedLatency = 0,\n    private readonly stateRef: StateRef = { closed: false },\n  ) {\n    super(keys);\n\n    this.data = new Map();\n\n    Object.keys(keys).forEach((k) => {\n      this.indices[k as keyof T] = new Map();\n    });\n  }\n\n  protected preAct(): Promise<void> | void {\n    if (this.stateRef.closed) {\n      throw new Error('Connection closed');\n    }\n    return sleep(this.simulatedLatency);\n  }\n\n  protected async internalAdd(value: T): Promise<void> {\n    const serialised = serialiseRecord(value);\n    this.internalCheckDuplicates(serialised, true);\n    this.data.set(serialised.id, serialised);\n    this.internalPopulateIndices(serialised);\n  }\n\n  protected async internalUpsert(\n    id: T['id'],\n    update: Partial<T>,\n  ): Promise<void> {\n    if (this.data.has(serialiseValue(id))) {\n      await this.internalUpdate('id', id, update);\n    } else {\n      await this.internalAdd({ id, ...update } as T);\n    }\n  }\n\n  protected async internalUpdate<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n    update: Partial<T>,\n  ): Promise<void> {\n    const sIds = this.internalGetSerialisedIds(searchAttribute, searchValue);\n\n    const updates = sIds.map((sId) => {\n      const oldSerialised = this.data.get(sId)!;\n      const oldValue = deserialiseRecord(oldSerialised) as T;\n      const newValue = { ...oldValue, ...update };\n      if (newValue.id !== oldValue.id) {\n        throw new Error('Cannot update ID');\n      }\n      const newSerialised = serialiseRecord(newValue);\n      return { oldSerialised, newSerialised };\n    });\n\n    updates.forEach(({ oldSerialised }) => this.internalRemoveIndices(oldSerialised));\n    try {\n      updates.forEach(({ newSerialised }) => this.internalCheckDuplicates(newSerialised, false));\n    } catch (e) {\n      updates.forEach(({ oldSerialised }) => this.internalPopulateIndices(oldSerialised));\n      throw e;\n    }\n    updates.forEach(({ newSerialised }) => {\n      this.data.set(newSerialised.id, newSerialised);\n      this.internalPopulateIndices(newSerialised);\n    });\n  }\n\n  protected async internalGetAll<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    searchAttribute?: K,\n    searchValue?: T[K],\n    returnAttributes?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    let sIds: string[];\n    if (searchAttribute) {\n      sIds = this.internalGetSerialisedIds(searchAttribute, searchValue!);\n    } else {\n      sIds = [...this.data.keys()];\n    }\n    return sIds.map((sId) => applyFilter(\n      deserialiseRecord(this.data.get(sId)!) as T,\n      returnAttributes,\n    ));\n  }\n\n  protected async internalRemove<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n  ): Promise<number> {\n    const sIds = this.internalGetSerialisedIds(searchAttribute, searchValue);\n    sIds.forEach((sId) => {\n      const oldSerialised = this.data.get(sId)!;\n      this.internalRemoveIndices(oldSerialised);\n      this.data.delete(sId);\n    });\n\n    return sIds.length;\n  }\n\n  private internalGetSerialisedIds<K extends keyof T>(\n    searchAttribute: K,\n    searchValue: T[K],\n  ): string[] {\n    const sKey = serialiseValue(searchValue);\n    if (searchAttribute === 'id') {\n      return this.data.has(sKey) ? [sKey] : [];\n    }\n    const index = this.indices[searchAttribute];\n    if (!index) {\n      throw new Error(`Requested key ${searchAttribute} not indexed`);\n    }\n    const sIds = index.get(sKey);\n    return sIds ? [...sIds] : []; // convert set to array\n  }\n\n  private internalCheckDuplicates(\n    serialisedValue: Record<string, string>,\n    checkId: boolean,\n  ): void {\n    if (checkId && this.data.has(serialisedValue.id)) {\n      throw new Error('duplicate');\n    }\n    Object.keys(this.keys).forEach((key) => {\n      const index = this.indices[key as keyof T]!;\n      if (this.isIndexUnique(key) && index.has(serialisedValue[key])) {\n        throw new Error('duplicate');\n      }\n    });\n  }\n\n  private internalPopulateIndices(\n    serialisedValue: Record<string, string>,\n  ): void {\n    Object.keys(this.keys).forEach((key) => {\n      const index = this.indices[key as keyof T]!;\n      const v = serialisedValue[key];\n      let o = index.get(v);\n      if (!o) {\n        o = new Set<string>();\n        index.set(v, o);\n      }\n      o.add(serialisedValue.id);\n    });\n  }\n\n  private internalRemoveIndices(\n    serialisedValue: Record<string, string>,\n  ): void {\n    Object.keys(this.keys).forEach((key) => {\n      const index = this.indices[key as keyof T]!;\n      const v = serialisedValue[key];\n      const o = index.get(v)!;\n      o.delete(serialisedValue.id);\n      if (!o.size) {\n        index.delete(v);\n      }\n    });\n  }\n}\n","import type { Collection } from './Collection';\nimport type { IDable } from './IDable';\nimport type { DB, DBKeys } from './DB';\nimport { canonicalJSON } from '../helpers/serialiser';\n\nexport interface StateRef {\n  closed: boolean;\n}\n\ninterface AsyncCollection<T extends IDable> extends Collection<T> {\n  internalReady?: () => Promise<void>;\n}\n\nexport default abstract class BaseDB implements DB {\n  protected readonly stateRef: StateRef = { closed: false };\n\n  private readonly collectionCache = new Map<string, [string, Collection<any>]>();\n\n  constructor(\n    private readonly makeCollection: <T extends IDable>(\n      name: string,\n      keys?: DBKeys<T>,\n    ) => Collection<T>,\n  ) {}\n\n  public getCollection<T extends IDable>(name: string, keys?: DBKeys<T>): Collection<T> {\n    const cached = this.collectionCache.get(name);\n    const normKeys = canonicalJSON(keys);\n    if (cached) {\n      const [cachedNormKeys, cachedCol] = cached;\n      if (normKeys !== cachedNormKeys) {\n        throw new Error(`Cannot requuest collection '${name}' with different keys`);\n      }\n      return cachedCol;\n    }\n    const created = this.makeCollection(name, keys) as AsyncCollection<T>;\n    this.collectionCache.set(name, [normKeys, created]);\n    return created;\n  }\n\n  close(): Promise<void> | void {\n    if (this.stateRef.closed) {\n      return undefined;\n    }\n    this.syncClose();\n    const toAwait = [...this.collectionCache.values()]\n      .map(([, c]) => (c as AsyncCollection<IDable>).internalReady?.());\n    return Promise.allSettled(toAwait).then(() => this.internalClose());\n  }\n\n  protected syncClose(): void {\n    this.stateRef.closed = true;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  protected internalClose(): Promise<void> | void {}\n}\n","import { URL } from 'url';\nimport MemoryCollection from './MemoryCollection';\nimport type { DBKeys } from '../interfaces/DB';\nimport type { IDable } from '../interfaces/IDable';\nimport BaseDB from '../interfaces/BaseDB';\n\nfunction getGlobal<T>(name: string, initial: T): T {\n  const existing = (global as any)[name];\n  if (existing) {\n    return existing;\n  }\n\n  (global as any)[name] = initial;\n  return initial;\n}\n\nconst globalDbs = getGlobal(\n  'collectionStorageInMemory',\n  new Map<string, MemoryDb>(),\n);\n\nexport default class MemoryDb extends BaseDB {\n  public constructor({ simulatedLatency = 0 } = {}) {\n    super((name, keys) => new MemoryCollection(keys, simulatedLatency, this.stateRef));\n  }\n\n  public static connect(url: string): MemoryDb {\n    const parsedUrl = new URL(url);\n    const name = parsedUrl.hostname;\n    if (name && globalDbs.has(name)) {\n      return globalDbs.get(name)!;\n    }\n    const params = parsedUrl.searchParams;\n    const simulatedLatency = Number(params.get('simulatedLatency'));\n    const db = new MemoryDb({ simulatedLatency });\n    if (name) {\n      globalDbs.set(name, db);\n    }\n    return db;\n  }\n\n  public getCollection<T extends IDable>(name: string, keys?: DBKeys<T>): MemoryCollection<T> {\n    return super.getCollection(name, keys) as MemoryCollection<T>;\n  }\n\n  public close(): void {\n    this.syncClose();\n  }\n}\n","import type { Db as MongoDbT, MongoClient as MongoClientT } from 'mongodb';\nimport type { DBKeys } from '../interfaces/DB';\nimport BaseDB from '../interfaces/BaseDB';\nimport type { IDable } from '../interfaces/IDable';\nimport type MongoCollectionT from './MongoCollection';\n\nfunction escapeName(name: string): string {\n  return encodeURIComponent(name);\n}\n\nexport default class MongoDb extends BaseDB {\n  private constructor(\n    private readonly client: MongoClientT,\n    MongoCollection: typeof MongoCollectionT,\n  ) {\n    super((name, keys) => new MongoCollection(\n      this.client.db().collection(escapeName(name)),\n      keys,\n      this.stateRef,\n    ));\n  }\n\n  public static async connect(url: string): Promise<MongoDb> {\n    const { MongoClient } = await import('mongodb');\n    const {\n      default: MongoCollection,\n    } = await import(/* webpackMode: \"eager\" */ './MongoCollection');\n    const client = await MongoClient.connect(url, {\n      useNewUrlParser: true,\n      useUnifiedTopology: true,\n    });\n    return new MongoDb(client, MongoCollection);\n  }\n\n  public getCollection<T extends IDable>(name: string, keys?: DBKeys<T>): MongoCollectionT<T> {\n    return super.getCollection(name, keys) as MongoCollectionT<T>;\n  }\n\n  public getDb(): MongoDbT {\n    return this.client.db();\n  }\n\n  protected internalClose(): Promise<void> {\n    return this.client.close();\n  }\n}\n","import type {\n  Redis,\n  Pipeline,\n  MultiOptions,\n  Ok,\n} from 'ioredis';\n\n// Thanks, https://stackoverflow.com/a/50014868/1180785\ntype ArgumentTypes<T> = T extends (...args: infer U) => any ? U : never;\n\ntype PipelineVersions<I> = {\n  [K in keyof I]: (...args: ArgumentTypes<I[K]>) => Pipeline & PipelineVersions<I>;\n};\n\ninterface RedisWithExtendedPipeline<I> extends Redis {\n  multi(commands?: string[][], options?: MultiOptions): Pipeline & PipelineVersions<I>;\n  multi(options: { pipeline: false }): Promise<Ok>;\n}\n\nexport type ExtendedRedis<I> = I & RedisWithExtendedPipeline<I>;\n\nexport async function multiExec(\n  client: Redis,\n  commands: string[][],\n): Promise<[unknown, any][] | null> {\n  if (!commands.length) {\n    return [];\n  }\n  return client.multi(commands).exec();\n}\n\nexport function minifyLuaScript(\n  lines: string[],\n  ...argNames: string[]\n): string {\n  let combined = lines.map((ln) => ln.trim()).join(' ');\n  argNames.forEach((name, i) => {\n    combined = combined.replace(new RegExp(`\\\\$${name}\\\\b`, 'g'), `ARGV[${i + 1}]`);\n  });\n  return combined;\n}\n","import type { IDable } from '../interfaces/IDable';\nimport BaseCollection from '../interfaces/BaseCollection';\nimport type { UpdateOptions } from '../interfaces/Collection';\nimport type { DBKeys } from '../interfaces/DB';\nimport {\n  serialiseValue,\n  serialiseRecord,\n  deserialiseRecord,\n} from '../helpers/serialiser';\nimport type RedisConnectionPool from './RedisConnectionPool';\nimport { multiExec } from './helpers';\nimport type { ERedis } from './scripts';\n\ninterface Key<T> {\n  key: keyof T & string;\n  prefix: string;\n}\n\ninterface InternalPatch {\n  sId: string;\n  oldSerialised: Record<string, string | null>;\n  newSerialised: Record<string, string>;\n}\n\nconst notUndefined = <T>(item?: T): item is T => (item !== undefined);\n\nfunction makeIndexKeys(\n  keys: Key<any>[],\n  partialSerialisedValue: Record<string, string | null>,\n): string[] {\n  return keys\n    .filter(({ key }) => partialSerialisedValue[key])\n    .map(({ key, prefix }) => `${prefix}:${partialSerialisedValue[key]}`);\n}\n\nfunction parseItem(\n  item: (string | null)[] | Record<string, string | null>,\n  fields?: readonly string[],\n): Record<string, string | null> {\n  if (!fields) {\n    return item as any;\n  }\n  const result: Record<string, string | null> = {};\n  for (let f = 0; f < fields.length; f += 1) {\n    result[fields[f]] = (item as any)[f];\n  }\n  return result;\n}\n\nfunction itemHasContent(item: Record<string, string | null>): boolean {\n  return Object.values(item).some((v) => (v !== null));\n}\n\nasync function unwatchAll(client: ERedis): Promise<void> {\n  await client.unwatch();\n}\n\nasync function mapAwaitSync<T, O>(\n  values: T[],\n  fn: (value: T) => Promise<O>,\n): Promise<O[]> {\n  const result: O[] = [];\n  for (let i = 0; i < values.length; i += 1) {\n    // eslint-disable-next-line no-await-in-loop\n    result.push(await fn(values[i]));\n  }\n  return result;\n}\n\nexport default class RedisCollection<T extends IDable> extends BaseCollection<T> {\n  private readonly keyPrefixes: { [K in keyof T]?: string } = {};\n\n  private readonly uniqueKeys: Key<T>[] = [];\n\n  private readonly nonUniqueKeys: Key<T>[] = [];\n\n  public constructor(\n    private readonly pool: RedisConnectionPool,\n    private readonly prefix: string,\n    keys: DBKeys<T> = {},\n  ) {\n    super(keys);\n\n    Object.keys(keys).forEach((k) => {\n      const key = k as keyof DBKeys<T>;\n      const keyPrefix = `${prefix}-${key}`;\n      this.keyPrefixes[key] = keyPrefix;\n      const keyInfo = { key, prefix: keyPrefix };\n      if (keys[key]!.unique) {\n        this.uniqueKeys.push(keyInfo);\n      } else {\n        this.nonUniqueKeys.push(keyInfo);\n      }\n    });\n  }\n\n  protected internalAdd(value: T): Promise<void> {\n    const serialised = serialiseRecord(value);\n    return this.pool.withConnection(async (client) => {\n      const added = await this.runAdd(client, serialised, false);\n      if (!added) {\n        throw new Error('duplicate');\n      }\n    });\n  }\n\n  protected internalUpdate<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n    update: Partial<T>,\n    { upsert }: UpdateOptions,\n  ): Promise<void> {\n    const patchSerialised = serialiseRecord(update);\n    const sKey = serialiseValue(searchValue);\n\n    if (searchAttribute === 'id') {\n      return this.pool.retryWithConnection(async (client) => {\n        const patch = await this.getUpdatePatch(client, sKey, patchSerialised);\n        if (patch) {\n          await this.runUpdates(client, [patch]);\n        } else if (upsert) {\n          const insertValue = { ...patchSerialised, id: sKey };\n          if (!await this.runAdd(client, insertValue, true)) {\n            throw new Error('duplicate');\n          }\n        }\n      }, unwatchAll);\n    }\n\n    return this.pool.retryWithConnection(async (client) => {\n      const sIds = await this.getAndWatchBySerialisedKey(client, searchAttribute, sKey);\n      const patches = (await mapAwaitSync(\n        sIds,\n        (sId) => this.getUpdatePatch(client, sId, patchSerialised),\n      )).filter(notUndefined);\n      await this.runUpdates(client, patches);\n    }, unwatchAll);\n  }\n\n  protected internalGet<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    searchAttribute: K,\n    searchValue: T[K],\n    returnAttributes?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    const sKey = serialiseValue(searchValue);\n    return this.pool.retryWithConnection(async (client) => {\n      const sId = (await this.getAndWatchBySerialisedKey(client, searchAttribute, sKey))[0];\n      if (sId === undefined) {\n        return null;\n      }\n      const results = await this.getByKeysKeepWatches(client, [sId], returnAttributes);\n      return results[0] ?? null;\n    }, unwatchAll);\n  }\n\n  protected internalGetAll<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    searchAttribute?: K,\n    searchValue?: T[K],\n    returnAttributes?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    return this.pool.retryWithConnection(async (client) => {\n      let sIds: string[];\n      if (searchAttribute) {\n        const sKey = serialiseValue(searchValue);\n        sIds = await this.getAndWatchBySerialisedKey(client, searchAttribute, sKey);\n      } else {\n        sIds = await client.keys(this.makeKey('*'));\n        const cut = this.prefix.length + 1;\n        sIds = sIds.map((v) => v.substr(cut));\n      }\n      return this.getByKeysKeepWatches(client, sIds, returnAttributes);\n    }, unwatchAll);\n  }\n\n  protected internalRemove<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n  ): Promise<number> {\n    const sKey = serialiseValue(searchValue);\n    const indexedKeys = Object.keys(this.keys);\n    indexedKeys.push('id');\n\n    return this.pool.retryWithConnection(async (client) => {\n      const sIds = await this.getAndWatchBySerialisedKey(client, searchAttribute, sKey);\n      const items = (await mapAwaitSync(\n        sIds,\n        (sId) => this.rawByKeyKeepWatches(client, sId, indexedKeys),\n      )).filter(notUndefined);\n\n      if (items.length === 0) {\n        return 0;\n      }\n\n      const pipeline = client.multi();\n      items.forEach((item) => {\n        const uniqueKeys = makeIndexKeys(this.uniqueKeys, item);\n        const nonUniqueKeys = makeIndexKeys(this.nonUniqueKeys, item);\n        pipeline.remove(\n          1 + uniqueKeys.length + nonUniqueKeys.length,\n          this.makeKey(item.id!),\n          ...uniqueKeys,\n          ...nonUniqueKeys,\n          item.id!,\n        );\n      });\n      await pipeline.exec();\n      return items.length;\n    }, unwatchAll);\n  }\n\n  private makeKey(serialisedId: string): string {\n    return `${this.prefix}:${serialisedId}`;\n  }\n\n  private async runAdd(\n    client: ERedis,\n    { id, ...serialised }: Record<string, string>,\n    checkWatch: boolean,\n  ): Promise<boolean> {\n    const uniqueKeys = makeIndexKeys(this.uniqueKeys, serialised);\n    const nonUniqueKeys = makeIndexKeys(this.nonUniqueKeys, serialised);\n\n    const keyCount = 1 + uniqueKeys.length + nonUniqueKeys.length;\n    const params = [\n      this.makeKey(id),\n      ...uniqueKeys,\n      ...nonUniqueKeys,\n      uniqueKeys.length,\n      'id', // ID is always first in flattened key/value pairs\n      id,\n      ...Object.entries(serialised).flat(),\n    ];\n\n    if (!checkWatch) {\n      return Boolean(await client.add(keyCount, ...params));\n    }\n\n    const result = await client\n      .multi()\n      .add(keyCount, ...params)\n      .exec();\n    if (!result) {\n      throw new Error('transient error');\n    }\n    return Boolean(result[0][1]);\n  }\n\n  private async getUpdatePatch(\n    client: ERedis,\n    sId: string,\n    patchSerialised: Record<string, string>,\n  ): Promise<InternalPatch | undefined> {\n    await client.watch(this.makeKey(sId));\n    const oldSerialised = await this.rawByKeyKeepWatches(\n      client,\n      sId,\n      Object.keys(this.keys).filter((k) => patchSerialised[k]),\n    );\n    if (!oldSerialised) {\n      return undefined;\n    }\n    const newSerialised = { ...patchSerialised };\n    Object.keys(newSerialised).forEach((k) => {\n      if (oldSerialised[k] === newSerialised[k]) {\n        delete newSerialised[k];\n        delete oldSerialised[k];\n      }\n    });\n    return { sId, newSerialised, oldSerialised };\n  }\n\n  private async runUpdates(\n    client: ERedis,\n    patches: InternalPatch[],\n  ): Promise<void> {\n    const argsList = patches\n      .map((patch) => this.makeUpdateArgs(patch))\n      .filter(notUndefined);\n\n    if (!argsList.length) {\n      return;\n    }\n\n    if (argsList.length === 1) {\n      const results = await client.multi()\n        .update(argsList[0][0], argsList[0][1])\n        .exec();\n\n      if (!results) {\n        throw new Error('transient error');\n      }\n      if (!results[0][1]) {\n        throw new Error('duplicate');\n      }\n      return;\n    }\n\n    const updateCheckResults = await mapAwaitSync(\n      argsList,\n      (updateArgs) => client.checkUpdate(updateArgs[0], updateArgs[1]),\n    );\n    if (updateCheckResults.some((r) => !r)) {\n      throw new Error('duplicate');\n    }\n\n    let chain = client.multi();\n    argsList.forEach((updateArgs) => {\n      chain = chain.updateWithoutCheck(updateArgs[0], updateArgs[1]);\n    });\n    const results = await chain.exec();\n\n    if (!results) {\n      throw new Error('transient error');\n    }\n  }\n\n  private makeUpdateArgs(\n    { sId, oldSerialised, newSerialised }: InternalPatch,\n  ): [number, any[]] | undefined {\n    const diff = Object.entries(newSerialised).flat();\n    if (!diff.length) {\n      return undefined; // nothing changed\n    }\n    const patchUniqueKeys = makeIndexKeys(this.uniqueKeys, newSerialised);\n    const patchNonUniqueKeys = makeIndexKeys(this.nonUniqueKeys, newSerialised);\n    const oldUniqueKeys = makeIndexKeys(this.uniqueKeys, oldSerialised);\n    const oldNonUniqueKeys = makeIndexKeys(this.nonUniqueKeys, oldSerialised);\n    if (\n      oldUniqueKeys.length !== patchUniqueKeys.length ||\n      oldNonUniqueKeys.length !== patchNonUniqueKeys.length\n    ) {\n      throw new Error('unexpected key mismatch with old value');\n    }\n    const keyCount = 1 + (patchUniqueKeys.length + patchNonUniqueKeys.length) * 2;\n    const params = [\n      this.makeKey(sId),\n      ...patchUniqueKeys,\n      ...patchNonUniqueKeys,\n      ...oldUniqueKeys,\n      ...oldNonUniqueKeys,\n      patchUniqueKeys.length,\n      patchUniqueKeys.length + patchNonUniqueKeys.length,\n      sId,\n      ...diff,\n    ];\n    return [keyCount, params];\n  }\n\n  private async getByKeysKeepWatches<F extends readonly (keyof T & string)[]>(\n    client: ERedis,\n    serialisedIds: string[],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    const results = await multiExec(\n      client,\n      serialisedIds\n        .map((sId) => this.makeKey(sId))\n        .map((k) => (fields ? ['hmget', k, ...fields] : ['hgetall', k])),\n    );\n    if (!results) {\n      throw new Error('transient error');\n    }\n    return results\n      .map(([, item]: [unknown, any]) => parseItem(item, fields))\n      .filter(itemHasContent)\n      .map(deserialiseRecord) as T[];\n  }\n\n  private async rawByKeyKeepWatches(\n    client: ERedis,\n    serialisedId: string,\n    fields?: readonly string[],\n  ): Promise<Record<string, string | null> | undefined> {\n    const key = this.makeKey(serialisedId);\n    let item;\n    if (fields) {\n      if (!fields.length) {\n        // just check existence\n        const exists = await client.exists(key);\n        return exists ? {} : undefined;\n      }\n      item = await client.hmget(key, ...fields);\n    } else {\n      item = await client.hgetall(key);\n    }\n    const parsed = parseItem(item, fields);\n    return itemHasContent(parsed) ? parsed : undefined;\n  }\n\n  private async getAndWatchBySerialisedKey(\n    client: ERedis,\n    keyName: keyof T,\n    serialisedValue: string,\n  ): Promise<string[]> {\n    if (keyName === 'id') {\n      return [serialisedValue];\n    }\n    const keyPrefix = this.keyPrefixes[keyName];\n    if (!keyPrefix) {\n      throw new Error(`Requested key ${keyName} not indexed`);\n    }\n    const keyAddress = `${keyPrefix}:${serialisedValue}`;\n    await client.watch(keyAddress);\n    return client.smembers(keyAddress);\n  }\n}\n","import type { Redis as RedisT } from 'ioredis';\nimport { minifyLuaScript, ExtendedRedis } from './helpers';\n\nexport interface ScriptExtensions {\n  add(keyCount: number, ...keysAndArgs: any[]): Promise<number>;\n  update(keyCount: number, ...keysAndArgs: any[]): Promise<number>;\n  checkUpdate(keyCount: number, ...keysAndArgs: any[]): Promise<number>;\n  updateWithoutCheck(keyCount: number, ...keysAndArgs: any[]): Promise<void>;\n  remove(keyCount: number, ...keysAndArgs: any[]): Promise<void>;\n}\n\nexport type ERedis = ExtendedRedis<ScriptExtensions>;\n\n// KEYS = [id, ...uniqueKeys, ...nonUniqueKeys]\nconst SCRIPT_ADD = minifyLuaScript([\n  'if redis.call(\"exists\",KEYS[1])==1 then',\n  '  return 0',\n  'end',\n  'for k=2,1+tonumber($uniqueKeyCount) do',\n  '  if redis.call(\"exists\",KEYS[k])==1 then',\n  '    return 0',\n  '  end',\n  'end',\n  'redis.call(\"hset\",KEYS[1],unpack(ARGV, 2))',\n  'for k=2,#KEYS do',\n  '  redis.call(\"sadd\",KEYS[k],ARGV[3])',\n  'end',\n  'return 1',\n], 'uniqueKeyCount');\n\nconst FRAG_CHECK_UPDATE = [\n  'for k=2,1+tonumber($uniqueKeyCount) do',\n  '  if redis.call(\"exists\",KEYS[k])==1 then',\n  '    return 0',\n  '  end',\n  'end',\n];\n\nconst FRAG_UPDATE = [\n  'local tkc=tonumber($totalKeyCount)',\n  'redis.call(\"hset\",KEYS[1],unpack(ARGV, 4))',\n  'for k=1,tkc do',\n  '  redis.call(\"smove\",KEYS[1+tkc+k],KEYS[1+k],$id)',\n  'end',\n];\n\n// KEYS = [id, ...patchUniqueKeys, ...patchNonUniqueKeys, ...oldUniqueKeys, ...oldNonUniqueKeys]\nconst SCRIPT_CHECK_UPDATE = minifyLuaScript([\n  ...FRAG_CHECK_UPDATE,\n  'return 1',\n], 'uniqueKeyCount', 'totalKeyCount', 'id');\n\n// KEYS = [id, ...patchUniqueKeys, ...patchNonUniqueKeys, ...oldUniqueKeys, ...oldNonUniqueKeys]\nconst SCRIPT_UPDATE_WITHOUT_CHECK = minifyLuaScript([\n  ...FRAG_UPDATE,\n], 'uniqueKeyCount', 'totalKeyCount', 'id');\n\n// KEYS = [id, ...patchUniqueKeys, ...patchNonUniqueKeys, ...oldUniqueKeys, ...oldNonUniqueKeys]\nconst SCRIPT_UPDATE = minifyLuaScript([\n  ...FRAG_CHECK_UPDATE,\n  ...FRAG_UPDATE,\n  'return 1',\n], 'uniqueKeyCount', 'totalKeyCount', 'id');\n\n// KEYS = [id, ...keys]\nconst SCRIPT_REMOVE = minifyLuaScript([\n  'redis.call(\"del\",KEYS[1])',\n  'for k=2,#KEYS do',\n  '  redis.call(\"srem\",KEYS[k],$id)',\n  'end',\n], 'id');\n\nexport default function defineAllScripts(client: RedisT): ERedis {\n  client.defineCommand('add', { lua: SCRIPT_ADD });\n  client.defineCommand('update', { lua: SCRIPT_UPDATE });\n  client.defineCommand('checkUpdate', { lua: SCRIPT_CHECK_UPDATE });\n  client.defineCommand('updateWithoutCheck', { lua: SCRIPT_UPDATE_WITHOUT_CHECK });\n  client.defineCommand('remove', { lua: SCRIPT_REMOVE });\n\n  return client as ERedis;\n}\n","import type { Redis as RedisT, RedisOptions as RedisOptionsT } from 'ioredis';\nimport defineAllScripts, { ERedis } from './scripts';\nimport retry from '../helpers/retry';\n\ntype RS = new(host?: string, options?: RedisOptionsT) => RedisT;\n\nconst withRetry = retry((e) => (\n  typeof e === 'object' &&\n  e.message === 'transient error'\n));\n\nexport default class RedisConnectionPool {\n  private readonly connections: ERedis[] = [];\n\n  private inUse = 0;\n\n  private queue: ((client: ERedis) => void)[] = [];\n\n  private closingFn?: () => void;\n\n  private closed = false;\n\n  public constructor(\n    private readonly RedisStatic: RS,\n    private readonly url: string,\n    private readonly options: RedisOptionsT,\n    private readonly maxConnections: number,\n  ) {}\n\n  public async withConnection<T>(\n    fn: (c: ERedis) => Promise<T> | T,\n    teardown?: (c: ERedis) => Promise<void> | void,\n  ): Promise<T> {\n    const c = await this.getConnection();\n    try {\n      return await fn(c);\n    } finally {\n      await teardown?.(c);\n      this.returnConnection(c);\n    }\n  }\n\n  public async retryWithConnection<T>(\n    fn: (c: ERedis) => Promise<T> | T,\n    teardown?: (c: ERedis) => Promise<void> | void,\n  ): Promise<T> {\n    return withRetry(() => this.withConnection(fn, teardown));\n  }\n\n  public close(): Promise<void> {\n    if (this.closed) {\n      return Promise.resolve();\n    }\n\n    this.closed = true;\n    if (this.inUse === 0) {\n      this.doClose();\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve): void => {\n      this.closingFn = (): void => {\n        this.doClose();\n        resolve();\n      };\n    });\n  }\n\n  private doClose(): void {\n    this.connections.forEach((c) => c.disconnect());\n    this.connections.length = 0;\n  }\n\n  private async getConnection(): Promise<ERedis> {\n    if (this.closed) {\n      throw new Error('Connection closed');\n    }\n\n    const r = this.connections.pop();\n    if (r) {\n      this.inUse += 1;\n      return r;\n    }\n    if (this.inUse < this.maxConnections) {\n      this.inUse += 1;\n      const client = new this.RedisStatic(this.url, this.options);\n      await client.connect();\n      return defineAllScripts(client);\n    }\n    return new Promise((resolve): void => {\n      this.queue.push(resolve);\n    });\n  }\n\n  private returnConnection(c: ERedis): void {\n    const q = this.queue.shift();\n    if (q) {\n      q(c);\n    } else {\n      this.inUse -= 1;\n      this.connections.push(c);\n      if (this.inUse === 0) {\n        this.closingFn?.();\n      }\n    }\n  }\n}\n","import RedisCollection from './RedisCollection';\nimport type { DBKeys } from '../interfaces/DB';\nimport BaseDB from '../interfaces/BaseDB';\nimport type { IDable } from '../interfaces/IDable';\nimport RedisConnectionPool from './RedisConnectionPool';\n\nexport default class RedisDb extends BaseDB {\n  private constructor(\n    private readonly pool: RedisConnectionPool,\n  ) {\n    super((name, keys) => new RedisCollection(this.pool, name, keys));\n  }\n\n  public static async connect(url: string): Promise<RedisDb> {\n    const { default: RedisStatic } = await import('ioredis');\n    const connectionPoolSize = 5;\n    return new RedisDb(new RedisConnectionPool(\n      RedisStatic,\n      url,\n      { lazyConnect: true },\n      connectionPoolSize,\n    ));\n  }\n\n  public getCollection<T extends IDable>(name: string, keys?: DBKeys<T>): RedisCollection<T> {\n    return super.getCollection(name, keys) as RedisCollection<T>;\n  }\n\n  public getConnectionPool(): RedisConnectionPool {\n    return this.pool;\n  }\n\n  protected internalClose(): Promise<void> {\n    return this.pool.close();\n  }\n}\n","export function quoteHValue(v: string): string {\n  return `\"${v.replace(/([\"\\\\])/g, '\\\\$1')}\"`;\n}\n\nexport function encodeHStore(record: Record<string, string>): string {\n  const result: string[] = [];\n  Object.keys(record).forEach((k) => {\n    result.push(`${quoteHValue(k)}=>${quoteHValue(record[k])}`);\n  });\n  return result.join(',');\n}\n\nexport function decodeHStore(hstore: string): Record<string, string> {\n  const result: Record<string, string> = {};\n  let current = '';\n  let currentKey = '';\n  let quote = false;\n  for (let p = 0; p < hstore.length;) {\n    const c = hstore[p];\n    switch (c) {\n      case ' ':\n      case '\\r':\n      case '\\n':\n      case '\\t':\n        if (quote) {\n          current += c;\n        }\n        break;\n      case '\\\\':\n        current += hstore[p + 1];\n        p += 1;\n        break;\n      case '\"':\n        quote = !quote;\n        break;\n      case '=':\n        if (quote) {\n          current += c;\n        } else if (hstore[p + 1] === '>') {\n          currentKey = current;\n          current = '';\n          p += 1;\n        }\n        break;\n      case ',':\n        if (quote) {\n          current += c;\n        } else {\n          result[currentKey] = current;\n          currentKey = '';\n          current = '';\n        }\n        break;\n      default:\n        current += c;\n        break;\n    }\n    p += 1;\n  }\n  if (currentKey) {\n    result[currentKey] = current;\n  }\n  return result;\n}\n","const DQUOTE_REG = /\"/g;\nexport function quoteIdentifier(msg: string): string {\n  return `\"${msg.replace(DQUOTE_REG, '\"\"')}\"`;\n}\n\nconst SQUOTE_REG = /'/g;\nexport function quoteValue(msg: string): string {\n  // only used for creating indices,\n  // because prepared statements do not support CREATE\n  return `'${msg.replace(SQUOTE_REG, '\\'\\'')}'`;\n}\n\nconst ID_REG = /\\$[A-Z]/g;\nexport function withIdentifiers(\n  base: string,\n  identifiers: Record<string, string>,\n): string {\n  return base.replace(\n    ID_REG,\n    (v) => quoteIdentifier(identifiers[v.substr(1)]),\n  );\n}\n","import type { Pool as PgPoolT, QueryArrayResult as PgQueryArrayResultT } from 'pg';\nimport type { IDable } from '../interfaces/IDable';\nimport BaseCollection from '../interfaces/BaseCollection';\nimport type { DBKeys } from '../interfaces/DB';\nimport type { StateRef } from '../interfaces/BaseDB';\nimport { serialiseValue, deserialiseValue, serialiseRecord } from '../helpers/serialiser';\nimport { encodeHStore, decodeHStore } from './hstore';\nimport { withIdentifiers, quoteValue } from './sql';\n\nconst STATEMENTS = {\n  CREATE_TABLE: [\n    'CREATE TABLE IF NOT EXISTS $T (',\n    'id TEXT NOT NULL PRIMARY KEY,',\n    'data HSTORE NOT NULL',\n    ')',\n  ].join(''),\n\n  GET_INDEX_NAMES: 'SELECT indexname FROM pg_indexes WHERE tablename=$1 AND schemaname=current_schema()',\n\n  CREATE_INDEX: 'CREATE INDEX IF NOT EXISTS $I ON $T USING HASH ((data->$1))',\n  CREATE_UNIQUE_INDEX: 'CREATE UNIQUE INDEX IF NOT EXISTS $I ON $T ((data->$1))',\n  DROP_INDEX: 'DROP INDEX IF EXISTS $I',\n\n  INSERT: 'INSERT INTO $T (id, data) VALUES ($1, $2::hstore)',\n\n  UPDATE: 'UPDATE $T SET data=data||$1::hstore WHERE data->$2=$3 RETURNING id',\n  UPDATE_ID: 'UPDATE $T SET data=data||$1::hstore WHERE id=$2',\n\n  UPSERT_ID: 'INSERT INTO $T (id, data) VALUES ($1, $2::hstore) ON CONFLICT (id) DO UPDATE SET data=$T.data||$2::hstore',\n\n  SELECT_ONE: 'SELECT id, data FROM $T WHERE data->$1=$2 LIMIT 1',\n  SELECT_ALL: 'SELECT id, data FROM $T',\n  SELECT_ALL_BY: 'SELECT id, data FROM $T WHERE data->$1=$2',\n  SELECT_ID: 'SELECT id, data FROM $T WHERE id=$1',\n\n  DELETE: 'DELETE FROM $T WHERE data->$1=$2',\n  DELETE_ID: 'DELETE FROM $T WHERE id=$1',\n};\n\nasync function configureTable(\n  pool: PgPoolT,\n  tableName: string,\n  keys: DBKeys<any> = {},\n): Promise<void> {\n  const c = await pool.connect();\n  try {\n    /* eslint-disable no-await-in-loop */ // client cannot multitask\n\n    await c.query(withIdentifiers(STATEMENTS.CREATE_TABLE, {\n      T: tableName,\n    }));\n\n    const indices = await c.query({\n      rowMode: 'array',\n      text: STATEMENTS.GET_INDEX_NAMES,\n      values: [tableName],\n    });\n    const oldIndexNames = new Set(\n      indices.rows\n        .map((r) => r[0])\n        .filter((i) => (i.startsWith(`${tableName}_i`) || i.startsWith(`${tableName}_u`))),\n    );\n\n    // PostgreSQL does not support prepared statements for CREATE statements,\n    // so we must escape the values manually using quoteValue.\n    const keyEntries = Object.entries(keys);\n    for (let i = 0; i < keyEntries.length; i += 1) {\n      const [k, v] = keyEntries[i];\n      if (v && v.unique) {\n        const name = `${tableName}_u${k}`;\n        if (!oldIndexNames.delete(name)) {\n          await c.query(withIdentifiers(STATEMENTS.CREATE_UNIQUE_INDEX, {\n            T: tableName,\n            I: name,\n          }).replace(/\\$1/g, quoteValue(k)));\n        }\n      } else {\n        const name = `${tableName}_i${k}`;\n        if (!oldIndexNames.delete(name)) {\n          await c.query(withIdentifiers(STATEMENTS.CREATE_INDEX, {\n            T: tableName,\n            I: name,\n          }).replace(/\\$1/g, quoteValue(k)));\n        }\n      }\n    }\n    const indicesToDelete = [...oldIndexNames];\n    for (let i = 0; i < indicesToDelete.length; i += 1) {\n      const idx = indicesToDelete[i];\n      await c.query(withIdentifiers(STATEMENTS.DROP_INDEX, {\n        T: tableName,\n        I: idx,\n      }));\n    }\n\n    /* eslint-enable no-await-in-loop */\n  } finally {\n    c.release();\n  }\n}\n\nfunction toHStore(record: Record<string, unknown>): string {\n  return encodeHStore(serialiseRecord(record));\n}\n\nfunction fromHStore<T>(\n  [id, data]: readonly any[],\n  fields?: readonly string[],\n): T {\n  const rawMap = decodeHStore(data);\n  rawMap.id = id;\n\n  const result: Record<string, unknown> = {};\n\n  if (!fields) {\n    Object.entries(rawMap).forEach(([k, v]) => {\n      result[k] = deserialiseValue(v);\n    });\n    return result as T;\n  }\n\n  fields.forEach((f) => {\n    result[f] = deserialiseValue(rawMap[f]);\n  });\n  return result as T;\n}\n\nexport default class PostgresCollection<T extends IDable> extends BaseCollection<T> {\n  private readonly cachedQueries: Partial<Record<keyof typeof STATEMENTS, string>> = {};\n\n  public constructor(\n    private readonly pool: PgPoolT,\n    private readonly tableName: string,\n    keys: DBKeys<T> = {},\n    private readonly stateRef: StateRef = { closed: false },\n  ) {\n    super(keys);\n\n    this.initAsync(configureTable(pool, tableName, keys));\n  }\n\n  protected async internalAdd({ id, ...rest }: T): Promise<void> {\n    await this.runTableQuery('INSERT', serialiseValue(id), toHStore(rest));\n  }\n\n  protected async internalUpsert(\n    id: T['id'],\n    update: Partial<T>,\n  ): Promise<void> {\n    await this.runTableQuery('UPSERT_ID', serialiseValue(id), toHStore(update));\n  }\n\n  protected async internalUpdate<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n    { id, ...rest }: Partial<T>,\n  ): Promise<void> {\n    const sId = serialiseValue(searchValue);\n    const hstore = toHStore(rest);\n\n    if (searchAttribute === 'id') {\n      await this.runTableQuery('UPDATE_ID', hstore, sId);\n    } else {\n      const r = await this.runTableQuery('UPDATE', hstore, searchAttribute, sId);\n      if (id !== undefined && r.rowCount > 0 && r.rows[0][0] !== id) {\n        throw new Error('Cannot update ID');\n      }\n    }\n  }\n\n  protected async internalGet<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    searchAttribute: K,\n    searchValue: T[K],\n    returnAttributes?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    let raw;\n    if (searchAttribute === 'id') {\n      raw = await this.runTableQuery('SELECT_ID', serialiseValue(searchValue));\n    } else {\n      raw = await this.runTableQuery('SELECT_ONE', searchAttribute, serialiseValue(searchValue));\n    }\n    if (!raw.rowCount) {\n      return null;\n    }\n    return fromHStore<T>(raw.rows[0], returnAttributes);\n  }\n\n  protected async internalGetAll<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    searchAttribute?: K,\n    searchValue?: T[K],\n    returnAttributes?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    let raw;\n    if (!searchAttribute) {\n      raw = await this.runTableQuery('SELECT_ALL');\n    } else if (searchAttribute === 'id') {\n      raw = await this.runTableQuery('SELECT_ID', serialiseValue(searchValue));\n    } else {\n      raw = await this.runTableQuery('SELECT_ALL_BY', searchAttribute, serialiseValue(searchValue));\n    }\n    return raw.rows.map((v) => fromHStore<T>(v, returnAttributes));\n  }\n\n  protected async internalRemove<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n  ): Promise<number> {\n    let raw;\n    if (searchAttribute === 'id') {\n      raw = await this.runTableQuery('DELETE_ID', serialiseValue(searchValue));\n    } else {\n      raw = await this.runTableQuery('DELETE', searchAttribute, serialiseValue(searchValue));\n    }\n    return raw.rowCount;\n  }\n\n  private runTableQuery(\n    queryName: keyof typeof STATEMENTS,\n    ...values: any[]\n  ): Promise<PgQueryArrayResultT<any[]>> {\n    if (this.stateRef.closed) {\n      throw new Error('Connection closed');\n    }\n\n    let cached = this.cachedQueries[queryName];\n    if (!cached) {\n      cached = withIdentifiers(STATEMENTS[queryName], { T: this.tableName });\n      this.cachedQueries[queryName] = cached;\n    }\n\n    return this.pool.query({\n      name: `${this.tableName}_${queryName}`,\n      rowMode: 'array',\n      text: cached,\n      values,\n    });\n  }\n}\n","import type { Pool as PgPoolT } from 'pg';\nimport PostgresCollection from './PostgresCollection';\nimport type { DBKeys } from '../interfaces/DB';\nimport BaseDB from '../interfaces/BaseDB';\nimport type { IDable } from '../interfaces/IDable';\n\nexport default class PostgresDb extends BaseDB {\n  private constructor(\n    private readonly pool: PgPoolT,\n  ) {\n    super((name, keys) => new PostgresCollection(pool, name, keys, this.stateRef));\n  }\n\n  public static async connect(url: string): Promise<PostgresDb> {\n    const { Pool } = await import('pg');\n    const pool = new Pool({ connectionString: url });\n    await pool.query('CREATE EXTENSION IF NOT EXISTS hstore');\n    return new PostgresDb(pool);\n  }\n\n  public getCollection<T extends IDable>(name: string, keys?: DBKeys<T>): PostgresCollection<T> {\n    return super.getCollection(name, keys) as PostgresCollection<T>;\n  }\n\n  public getConnectionPool(): PgPoolT {\n    return this.pool;\n  }\n\n  protected internalClose(): Promise<void> {\n    return this.pool.end();\n  }\n}\n","import type { IDable } from '../interfaces/IDable';\nimport type { Collection, UpdateOptions } from '../interfaces/Collection';\n\nexport type Wrapped<T extends IDable, Fields extends keyof T, FieldStorage> = {\n  [K in keyof T]: K extends 'id' ? T[K] : K extends Fields ? FieldStorage : T[K];\n};\n\nexport interface Wrapper<T extends IDable, K extends keyof T, FieldStorage, CustomData> {\n  wrap: (\n    key: K,\n    value: T[K],\n    processed: CustomData,\n  ) => Promise<FieldStorage> | FieldStorage;\n\n  unwrap: (\n    key: K,\n    value: FieldStorage,\n    processed: CustomData,\n  ) => Promise<T[K]> | T[K];\n\n  preWrap?: (\n    record: Readonly<Partial<T>>,\n  ) => Promise<CustomData> | CustomData;\n\n  preUnwrap?: (\n    record: Readonly<Partial<Wrapped<T, K, FieldStorage>>>,\n  ) => Promise<CustomData> | CustomData;\n\n  preRemove?: (\n    record: Readonly<Pick<Wrapped<T, K, FieldStorage>, 'id'>>,\n  ) => Promise<void> | void;\n}\n\nfunction hasAnyField(value: object, fields: readonly string[]): boolean {\n  return fields\n    .some((field) => Object.prototype.hasOwnProperty.call(value, field));\n}\n\nexport default class WrappedCollection<\n  T extends IDable,\n  WF extends readonly (keyof Omit<T, 'id'> & string)[],\n  FieldStorage,\n  E,\n  Inner extends Wrapped<T, WF[-1], FieldStorage> = Wrapped<T, WF[-1], FieldStorage>\n> implements Collection<T> {\n  public constructor(\n    private readonly baseCollection: Collection<Inner>,\n    private readonly fields: WF,\n    private readonly wrapper: Wrapper<T, WF[-1], FieldStorage, E>,\n  ) {}\n\n  public async add(entry: T): Promise<void> {\n    return this.baseCollection.add(await this.wrapAll(entry));\n  }\n\n  public async get<\n    K extends keyof T & keyof Inner & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    key: K,\n    value: T[K] & Inner[K],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    if (this.fields.includes(key as any)) {\n      throw new Error('Cannot get by wrapped value');\n    }\n    const raw = await this.baseCollection.get(key, value, fields!);\n    return raw ? this.unwrapAll(raw, { [key]: value }) : null;\n  }\n\n  public async getAll<\n    K extends keyof T & keyof Inner & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    key?: K,\n    value?: T[K] & Inner[NonNullable<K>],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    if (key !== undefined && this.fields.includes(key as any)) {\n      throw new Error('Cannot get by wrapped value');\n    }\n    const raw = await this.baseCollection.getAll(key!, value!, fields!);\n    const extra = (key !== undefined) ? { [key]: value } : undefined;\n    return Promise.all(raw.map((v) => this.unwrapAll(v, extra)));\n  }\n\n  public async update<K extends keyof T & keyof Inner & string>(\n    key: K,\n    value: T[K] & Inner[K],\n    update: Partial<T>,\n    options?: UpdateOptions,\n  ): Promise<void> {\n    if (this.fields.includes(key as any)) {\n      throw new Error('Cannot update by wrapped value');\n    }\n    const converted = await this.wrapAll(update, { [key]: value });\n    return this.baseCollection.update(key, value, converted, options);\n  }\n\n  public async remove<K extends keyof T & string>(\n    key: K,\n    value: T[K] & Inner[K],\n  ): Promise<number> {\n    if (this.fields.includes(key as any)) {\n      throw new Error('Cannot remove by wrapped value');\n    }\n    if (!this.wrapper.preRemove) {\n      return this.baseCollection.remove(key, value);\n    }\n\n    const items = await this.baseCollection.getAll(key, value, ['id']);\n    await Promise.all(items.map(async (item) => {\n      await this.wrapper.preRemove!(item);\n      await this.baseCollection.remove('id', item.id);\n    }));\n    return items.length;\n  }\n\n  private async wrapAll(\n    v: Readonly<T>,\n    extra?: object,\n  ): Promise<Inner>;\n\n  private async wrapAll(\n    v: Readonly<Partial<T>>,\n    extra?: object,\n  ): Promise<Partial<Inner>>;\n\n  private async wrapAll(\n    v: Readonly<Partial<T>>,\n    extra?: object,\n  ): Promise<Partial<Inner>> {\n    let processed: E;\n    if (this.wrapper.preWrap && hasAnyField(v, this.fields)) {\n      const allFields = extra ? { ...extra, ...v } : v;\n      processed = await this.wrapper.preWrap(allFields);\n    }\n    const converted = { ...v } as any;\n    await Promise.all(this.fields.map(async (k) => {\n      if (Object.prototype.hasOwnProperty.call(v, k)) {\n        converted[k] = await this.wrapper.wrap(k, (v as any)[k], processed);\n      }\n    }));\n    return converted;\n  }\n\n  private async unwrapAll(\n    v: Readonly<Inner>,\n    extra?: object,\n  ): Promise<T>;\n\n  private async unwrapAll<K extends keyof T>(\n    v: Readonly<Pick<Inner, K>>,\n    extra?: object,\n  ): Promise<Pick<T, K>>;\n\n  private async unwrapAll<K extends keyof T>(\n    v: Readonly<Pick<Inner, K>>,\n    extra?: object,\n  ): Promise<Pick<T, K>> {\n    let processed: E;\n    if (this.wrapper.preUnwrap && hasAnyField(v, this.fields)) {\n      const allFields = extra ? { ...extra, ...v } : v;\n      processed = await this.wrapper.preUnwrap(allFields as any);\n    }\n    const converted = { ...v } as any;\n    await Promise.all(this.fields.map(async (k) => {\n      if (Object.prototype.hasOwnProperty.call(v, k)) {\n        converted[k] = await this.wrapper.unwrap(k, (v as any)[k], processed);\n      }\n    }));\n    return converted;\n  }\n}\n","export default class LruCache<K, V> {\n  private readonly storage = new Map<K, V>();\n\n  public constructor(\n    private readonly capacity: number,\n  ) {}\n\n  public async cachedAsync(key: K, calc: (key: K) => Promise<V>): Promise<V> {\n    const value = this.storage.get(key);\n    if (this.storage.delete(key)) {\n      this.storage.set(key, value!);\n      return value!;\n    }\n    const created = await calc(key);\n    this.storage.set(key, created);\n    this.flush();\n    return created;\n  }\n\n  public remove(key: K): void {\n    this.storage.delete(key);\n  }\n\n  private flush(): void {\n    while (this.storage.size > this.capacity) {\n      this.storage.delete(this.storage.keys().next().value);\n    }\n  }\n}\n","import crypto, { KeyObject } from 'crypto';\nimport type Encryption from './Encryption';\n\nconst ALG = 'aes-256-cbc';\nconst ALG_BUF = Buffer.from(`${ALG}:`, 'utf8');\nconst IV_LEN = 16;\n\nconst nodeEncryptionSync: Encryption<KeyObject, Buffer> = {\n  encrypt: (key: KeyObject, v: Buffer): Buffer => {\n    const iv = crypto.randomBytes(IV_LEN);\n    const cipher = crypto.createCipheriv(ALG, key, iv);\n    const part = cipher.update(v);\n    const final = cipher.final();\n    return Buffer.concat([ALG_BUF, iv, part, final]);\n  },\n\n  decrypt: (key: KeyObject, v: Buffer): Buffer => {\n    if (!v.slice(0, ALG_BUF.length).equals(ALG_BUF)) {\n      throw new Error('Unknown encryption algorithm');\n    }\n\n    const iv = v.slice(ALG_BUF.length, ALG_BUF.length + IV_LEN);\n    const encrypted = v.slice(ALG_BUF.length + IV_LEN);\n\n    const decipher = crypto.createDecipheriv(ALG, key, iv);\n    const part = decipher.update(encrypted);\n    const final = decipher.final();\n\n    return Buffer.concat([part, final]);\n  },\n\n  generateKey: (): KeyObject => crypto\n    .createSecretKey(crypto.randomBytes(32)),\n\n  serialiseKey: (key: KeyObject): Buffer => key.export(),\n\n  deserialiseKey: (data: Buffer): KeyObject => crypto.createSecretKey(data),\n};\n\nexport default nodeEncryptionSync;\n","import type { IDable, IDableBy, IDType } from '../interfaces/IDable';\nimport type { Collection } from '../interfaces/Collection';\nimport LruCache from '../helpers/LruCache';\nimport { serialiseValueBin, deserialiseValueBin } from '../helpers/serialiser';\nimport WrappedCollection, { Wrapped } from './WrappedCollection';\nimport type Encryption from './encryption/Encryption';\nimport nodeEncryptionSync from './encryption/nodeEncryptionSync';\n\nexport interface KeyRecord<ID extends IDType, KeyT> {\n  id: ID;\n  key: KeyT;\n}\n\nexport type Encrypted<T extends IDable, WF extends keyof T> = Wrapped<T, WF, Buffer>;\n\ntype EncryptableKeys<T> = readonly (keyof Omit<T, 'id'> & string)[];\n\ntype Encrypter<ID extends IDType> = <T extends IDableBy<ID>>(\n) => <F extends EncryptableKeys<T>>(\n  fields: F,\n  baseCollection: Collection<Encrypted<T, F[-1]>>,\n) => Collection<T>;\n\n// makeEncrypter provides optional 2-tier function call due to\n// https://github.com/Microsoft/TypeScript/issues/26242\n\nfunction makeEncrypter<ID extends IDType>(\n  wrapper: <T extends IDableBy<ID>, F extends EncryptableKeys<T>>(\n    fields: F,\n    baseCollection: Collection<Encrypted<T, F[-1]>>,\n  ) => Collection<T>,\n): Encrypter<ID> {\n  return (fields?: any, baseCollection?: Collection<any>): any => {\n    if (fields && baseCollection) {\n      // non-typescript API (remove need for extra ())\n      return wrapper(fields, baseCollection) as any;\n    }\n    return wrapper;\n  };\n}\n\nexport interface EncryptionOptions<KeyT = Buffer, SerialisedKeyT = Buffer> {\n  allowRaw?: boolean;\n  encryption?: Encryption<KeyT, SerialisedKeyT>;\n}\n\nexport interface RecordEncryptionOptions {\n  cacheSize?: number;\n}\n\ninterface CustomEncryptionOptions<KeyT, SerialisedKeyT>\n  extends EncryptionOptions<KeyT, SerialisedKeyT> {\n  encryption: Encryption<KeyT, SerialisedKeyT>;\n}\n\nfunction encryptByKey(\n  sKey: Buffer,\n  options?: EncryptionOptions,\n): Encrypter<IDType>;\n\nfunction encryptByKey<KeyT, SerialisedKeyT>(\n  sKey: SerialisedKeyT,\n  options: CustomEncryptionOptions<KeyT, SerialisedKeyT>,\n): Encrypter<IDType>;\n\nfunction encryptByKey<KeyT, SerialisedKeyT>(\n  sKey: SerialisedKeyT,\n  {\n    encryption = nodeEncryptionSync as any,\n    allowRaw = false,\n  }: EncryptionOptions<KeyT, SerialisedKeyT> = {},\n): Encrypter<IDType> {\n  const key = encryption.deserialiseKey(sKey);\n\n  return makeEncrypter(<T extends IDable, F extends EncryptableKeys<T>>(\n    fields: F,\n    baseCollection: Collection<Encrypted<T, F[-1]>>,\n  ) => new WrappedCollection<T, F, Buffer, never>(baseCollection, fields, {\n    wrap: (k, v): Promise<Buffer> | Buffer => encryption.encrypt(key, serialiseValueBin(v)),\n    unwrap: async (k, v): Promise<any> => {\n      if (!(v instanceof Buffer)) {\n        if (allowRaw) {\n          return v; // probably an old record before encryption was added\n        }\n        throw new Error('unencrypted data');\n      }\n      return deserialiseValueBin(await encryption.decrypt(key, v));\n    },\n  }));\n}\n\nfunction encryptByRecord<ID extends IDType>(\n  keyCollection: Collection<KeyRecord<ID, Buffer>>,\n  options?: EncryptionOptions & RecordEncryptionOptions,\n): Encrypter<ID>;\n\nfunction encryptByRecord<ID extends IDType, KeyT, SerialisedKeyT>(\n  keyCollection: Collection<KeyRecord<ID, SerialisedKeyT>>,\n  options: CustomEncryptionOptions<KeyT, SerialisedKeyT> & RecordEncryptionOptions,\n): Encrypter<ID>;\n\nfunction encryptByRecord<ID extends IDType, KeyT, SerialisedKeyT>(\n  keyCollection: Collection<KeyRecord<ID, SerialisedKeyT>>,\n  {\n    encryption = nodeEncryptionSync as any,\n    allowRaw = false,\n    cacheSize = 0,\n  }: EncryptionOptions<KeyT, SerialisedKeyT> & RecordEncryptionOptions = {},\n): Encrypter<ID> {\n  const cache = new LruCache<ID, KeyT>(cacheSize);\n\n  const loadKey = async (\n    generateIfNeeded: boolean,\n    record: { id?: ID },\n  ): Promise<KeyT> => {\n    const { id } = record;\n\n    if (id === undefined) {\n      throw new Error('Must provide ID for encryption');\n    }\n\n    return cache.cachedAsync(id, async () => {\n      const item = await keyCollection.get('id', id, ['key']);\n      if (item) {\n        return encryption.deserialiseKey(item.key);\n      }\n      if (!generateIfNeeded) {\n        throw new Error('No encryption key found for record');\n      }\n      const key = await encryption.generateKey();\n      await keyCollection.add({ id, key: encryption.serialiseKey(key) });\n      return key;\n    });\n  };\n\n  const removeKey = async ({ id }: { id: ID }): Promise<void> => {\n    await keyCollection.remove('id', id);\n    cache.remove(id);\n  };\n\n  // https://github.com/microsoft/TypeScript/issues/39080\n  return makeEncrypter<ID>(<T extends IDableBy<ID>, F extends EncryptableKeys<T>>(\n    fields: F,\n    baseCollection: Collection<Encrypted<T, F[-1]>>,\n  ) => new WrappedCollection<T, F, Buffer, KeyT>(baseCollection, fields, {\n    wrap: (k, v, key): Promise<Buffer> | Buffer => encryption.encrypt(key, serialiseValueBin(v)),\n    unwrap: async (k, v, key): Promise<any> => {\n      if (!(v instanceof Buffer)) {\n        if (allowRaw) {\n          return v; // probably an old record before encryption was added\n        }\n        throw new Error('unencrypted data');\n      }\n      return deserialiseValueBin(await encryption.decrypt(key, v));\n    },\n    preWrap: loadKey.bind(null, true),\n    preUnwrap: loadKey.bind(null, false),\n    preRemove: removeKey,\n  }));\n}\n\nfunction encryptByRecordWithMasterKey<ID extends IDType>(\n  sMasterKey: Buffer,\n  keyCollection: Collection<KeyRecord<ID, Buffer>>,\n  options?: EncryptionOptions & RecordEncryptionOptions,\n): Encrypter<ID>;\n\nfunction encryptByRecordWithMasterKey<ID extends IDType, KeyT, SerialisedKeyT>(\n  sMasterKey: SerialisedKeyT,\n  keyCollection: Collection<KeyRecord<ID, Buffer>>,\n  options: CustomEncryptionOptions<KeyT, SerialisedKeyT> & RecordEncryptionOptions,\n): Encrypter<ID>;\n\nfunction encryptByRecordWithMasterKey<ID extends IDType, KeyT, SerialisedKeyT>(\n  sMasterKey: SerialisedKeyT,\n  keyCollection: Collection<KeyRecord<ID, Buffer>>,\n  options: EncryptionOptions<KeyT, SerialisedKeyT> & RecordEncryptionOptions = {},\n): Encrypter<ID> {\n  const opts = options as CustomEncryptionOptions<KeyT, SerialisedKeyT> & RecordEncryptionOptions;\n  const keyEnc = encryptByKey(sMasterKey, opts);\n  const encKeyCollection = keyEnc<KeyRecord<ID, SerialisedKeyT>>()(\n    ['key'],\n    keyCollection,\n  );\n  return encryptByRecord(encKeyCollection, opts);\n}\n\nexport {\n  encryptByKey,\n  encryptByRecord,\n  encryptByRecordWithMasterKey,\n};\n","import zlib from 'zlib';\nimport { promisify } from 'util';\nimport type { IDable } from '../interfaces/IDable';\nimport type { Collection } from '../interfaces/Collection';\nimport { serialiseValueBin, deserialiseValueBin } from '../helpers/serialiser';\nimport WrappedCollection, { Wrapped } from './WrappedCollection';\n\ntype CompressableKeys<T> = readonly (keyof Omit<T, 'id'> & string)[];\n\nexport type Compressed<T extends IDable, WF extends keyof T> = Wrapped<T, WF, Buffer>;\n\nexport interface CompressOptions {\n  allowRaw?: boolean;\n  allowRawBuffer?: boolean;\n  compressionThresholdBytes?: number;\n}\n\nconst gzipCompress = promisify<Buffer, Buffer>(zlib.gzip);\nconst gzipDecompress = promisify<Buffer, Buffer>(zlib.gunzip);\n\nconst MARK_UNCOMPRESSED = Buffer.of(0);\n\nasync function compressValue(v: unknown, {\n  compressionThresholdBytes = 200,\n}: CompressOptions): Promise<Buffer> {\n  const serialised = serialiseValueBin(v);\n  if (serialised.length >= compressionThresholdBytes) {\n    const gzipped = await gzipCompress(serialised);\n    if (gzipped.length < serialised.length + 1) {\n      return gzipped;\n    }\n  }\n  return Buffer.concat([MARK_UNCOMPRESSED, serialised]);\n}\n\nasync function decompressValue(v: Buffer, {\n  allowRaw = true,\n  allowRawBuffer = false,\n}: CompressOptions): Promise<any> {\n  if (!(v instanceof Buffer)) {\n    if (allowRaw) {\n      return v; // probably an old record before compression was added\n    }\n    throw new Error('unknown compression type');\n  }\n  if (v[0] === 0x1F && v[1] === 0x8B) { // gzip \"magic number\"\n    return deserialiseValueBin(await gzipDecompress(v));\n  }\n  if (v[0] === MARK_UNCOMPRESSED[0]) {\n    return deserialiseValueBin(v.subarray(1));\n  }\n  if (allowRaw && allowRawBuffer) {\n    return v;\n  }\n  throw new Error('unknown compression type');\n}\n\nexport function compress<T extends IDable, F extends CompressableKeys<T>>(\n  fields: F,\n  baseCollection: Collection<Compressed<T, F[-1]>>,\n  options: CompressOptions = {},\n): Collection<T> {\n  return new WrappedCollection<T, F, Buffer, never>(baseCollection, fields, {\n    wrap: (k, v): Promise<Buffer> => compressValue(v, options),\n    unwrap: (k, v): Promise<any> => decompressValue(v, options),\n  });\n}\n","import type { Collection, UpdateOptions } from '../interfaces/Collection';\nimport type { IDable } from '../interfaces/IDable';\n\ntype MigrationFuncs<T, ExtraFetchFields extends readonly (keyof T & string)[]> = {\n  [K in keyof T]?: (\n    stored: T[K] | undefined,\n    record: Readonly<Pick<T, K | ExtraFetchFields[-1]>>,\n  ) => T[K];\n};\n\nclass MigratedCollection<\n  T extends IDable,\n  ExtraFetchFields extends readonly (keyof T & string)[],\n> implements Collection<T> {\n  public constructor(\n    private readonly baseCollection: Collection<T>,\n    private readonly migrations: MigrationFuncs<T, ExtraFetchFields>,\n    private readonly extraFetchFields?: ExtraFetchFields,\n  ) {}\n\n  public async add(entry: T): Promise<void> {\n    return this.baseCollection.add(entry);\n  }\n\n  public async get<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    searchAttribute: K,\n    searchValue: T[K],\n    returnAttributes?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    const raw = await this.baseCollection.get(\n      searchAttribute,\n      searchValue,\n      this.extendAttributes(returnAttributes)!,\n    );\n    return raw ? this.applyMigration(raw, returnAttributes) : null;\n  }\n\n  public async getAll<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[],\n  >(\n    searchAttribute?: K,\n    searchValue?: T[K],\n    returnAttributes?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    const raws = await this.baseCollection.getAll(\n      searchAttribute!,\n      searchValue as any,\n      this.extendAttributes(returnAttributes)!,\n    );\n    return raws.map((raw) => this.applyMigration(raw, returnAttributes));\n  }\n\n  public async update<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n    update: Partial<T>,\n    options?: UpdateOptions,\n  ): Promise<void> {\n    return this.baseCollection.update(searchAttribute, searchValue, update, options);\n  }\n\n  public async remove<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n  ): Promise<number> {\n    return this.baseCollection.remove(searchAttribute, searchValue);\n  }\n\n  private extendAttributes<\n    F extends readonly (keyof T & string)[]\n  >(returnAttributes?: F): readonly (keyof T & string)[] | undefined {\n    if (returnAttributes && this.extraFetchFields) {\n      return [...returnAttributes, ...this.extraFetchFields];\n    }\n    return returnAttributes;\n  }\n\n  private applyMigration<F extends readonly (keyof T & string)[]>(\n    raw: Readonly<Pick<T, ExtraFetchFields[-1] | F[-1]>>,\n    returnAttributes?: F,\n  ): Readonly<Pick<T, F[-1]>> {\n    if (returnAttributes && !returnAttributes.some((attr) => this.migrations[attr])) {\n      return raw;\n    }\n    const result: Pick<T, F[-1]> = { ...raw };\n    const attrs = returnAttributes || Object.keys(this.migrations);\n    attrs.forEach((key: string) => {\n      const attr = key as keyof Pick<T, F[-1]>;\n      const migration = this.migrations[attr];\n      if (migration) {\n        result[attr] = migration(raw[attr], raw);\n      }\n    });\n    return result;\n  }\n}\n\nfunction migrate<T extends IDable>(\n  migrations: MigrationFuncs<T, []>,\n  baseCollection: Collection<T>,\n): Collection<T>;\n\nfunction migrate<\n  T extends IDable,\n  ExtraFetchFields extends readonly (keyof T & string)[],\n>(\n  extraFetchFields: ExtraFetchFields,\n  migrations: MigrationFuncs<T, ExtraFetchFields>,\n  baseCollection: Collection<T>,\n): Collection<T>;\n\nfunction migrate<\n  T extends IDable,\n  ExtraFetchFields extends readonly (keyof T & string)[],\n>(\n  extraFetchFields: MigrationFuncs<T, []> | ExtraFetchFields,\n  migrations: MigrationFuncs<T, ExtraFetchFields> | Collection<T>,\n  baseCollection?: Collection<T>,\n): Collection<T> {\n  if (baseCollection) {\n    return new MigratedCollection(\n      baseCollection,\n      migrations as MigrationFuncs<T, ExtraFetchFields>,\n      extraFetchFields as ExtraFetchFields,\n    );\n  }\n  return new MigratedCollection(\n    migrations as Collection<T>,\n    extraFetchFields as MigrationFuncs<T, []>,\n  );\n}\n\nexport default migrate;\n","import CollectionStorage from './CollectionStorage';\nimport WrappedCollection, { Wrapped } from './wrappers/WrappedCollection';\nimport type Encryption from './wrappers/encryption/Encryption';\nimport {\n  encryptByKey,\n  encryptByRecord,\n  encryptByRecordWithMasterKey,\n  EncryptionOptions,\n  Encrypted,\n} from './wrappers/encrypted';\nimport { compress, Compressed, CompressOptions } from './wrappers/compressed';\nimport migrate from './wrappers/migrated';\nimport type { DB } from './interfaces/DB';\nimport type { Collection } from './interfaces/Collection';\n\nexport type {\n  DB,\n  Collection,\n  Wrapped,\n  Encryption,\n  Encrypted,\n  EncryptionOptions,\n  Compressed,\n  CompressOptions,\n};\n\nexport { default as MemoryDb } from './memory/MemoryDb';\nexport { default as MongoDb } from './mongo/MongoDb';\nexport { default as RedisDb } from './redis/RedisDb';\nexport { default as LruCache } from './helpers/LruCache';\nexport {\n  WrappedCollection,\n  encryptByKey,\n  encryptByRecord,\n  encryptByRecordWithMasterKey,\n  compress,\n  migrate,\n};\nexport {\n  default as nodeEncryptionSync,\n} from './wrappers/encryption/nodeEncryptionSync';\nexport default CollectionStorage;\n","import MemoryDb from './memory/MemoryDb';\nimport MongoDb from './mongo/MongoDb';\nimport RedisDb from './redis/RedisDb';\nimport PostgresDb from './postgresql/PostgresDb';\nimport type { DB } from './interfaces/DB';\n\nexport default class CollectionStorage {\n  public static async connect(url: string): Promise<DB> {\n    let dbClass;\n    if (url.startsWith('memory')) {\n      dbClass = MemoryDb;\n    } else if (url.startsWith('mongodb')) {\n      dbClass = MongoDb;\n    } else if (url.startsWith('redis')) {\n      dbClass = RedisDb;\n    } else if (url.startsWith('postgres')) {\n      dbClass = PostgresDb;\n    } else {\n      throw new Error(`Unsupported database connection string: ${url}`);\n    }\n\n    try {\n      return await dbClass.connect(url);\n    } catch (e) {\n      throw new Error(`Failed to connect to database \"${url}\": ${e.message}`);\n    }\n  }\n}\n"],"sourceRoot":""}