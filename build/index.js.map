{"version":3,"sources":["webpack://websocket-express/webpack/universalModuleDefinition","webpack://websocket-express/webpack/bootstrap","webpack://websocket-express/./src/interfaces/BaseCollection.ts","webpack://websocket-express/external \"crypto\"","webpack://websocket-express/./src/helpers/retry.ts","webpack://websocket-express/external \"mongodb\"","webpack://websocket-express/external \"url\"","webpack://websocket-express/./src/mongo/MongoCollection.ts","webpack://websocket-express/external \"ioredis\"","webpack://websocket-express/external \"pg\"","webpack://websocket-express/./src/helpers/serialiser.ts","webpack://websocket-express/./src/memory/MemoryCollection.ts","webpack://websocket-express/./src/memory/MemoryDb.ts","webpack://websocket-express/./src/mongo/MongoDb.ts","webpack://websocket-express/./src/redis/helpers.ts","webpack://websocket-express/./src/redis/RedisCollection.ts","webpack://websocket-express/./src/redis/scripts.ts","webpack://websocket-express/./src/redis/RedisConnectionPool.ts","webpack://websocket-express/./src/redis/RedisDb.ts","webpack://websocket-express/./src/postgresql/hstore.ts","webpack://websocket-express/./src/postgresql/sql.ts","webpack://websocket-express/./src/postgresql/PostgresCollection.ts","webpack://websocket-express/./src/postgresql/PostgresDb.ts","webpack://websocket-express/./src/wrappers/WrappedCollection.ts","webpack://websocket-express/./src/helpers/LruCache.ts","webpack://websocket-express/./src/wrappers/encryption/nodeEncryptionSync.ts","webpack://websocket-express/./src/wrappers/encrypted.ts","webpack://websocket-express/./src/index.ts","webpack://websocket-express/./src/CollectionStorage.ts"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","BaseCollection","constructor","keys","entry","this","preAct","internalAdd","searchAttribute","searchValue","returnAttributes","isIndexed","Error","internalGet","internalGetAll","update","options","undefined","id","upsert","withoutId","internalUpsert","isIndexUnique","some","k","internalUpdate","internalRemove","attribute","keyOptions","Boolean","unique","require","sleep","millis","Promise","resolve","setTimeout","shouldRetry","maxAttempts","baseDelayMillis","attemptDelayMillis","randomDelayMillis","async","attempt","fn","e","message","Math","random","MONGO_ID","ID","DOT_REG","fieldNameToMongo","encodeURIComponent","replace","withUpsertRetry","retry","includes","convertToMongo","converted","forEach","v","Buffer","MBinary","_bsontype","convertFromMongo","buffer","decodeURIComponent","fieldNameFromMongo","makeMongoProjection","names","projection","fieldName","MongoCollection","collection","stateRef","closed","super","keyName","mongoKey","createIndex","getCollection","insertOne","updateOne","$set","query","mongoUpdate","updateMany","findOne","cursor","find","result","raw","push","deleteMany","deletedCount","serialiseValue","toString","JSON","stringify","deserialiseValue","type","data","substr","from","parse","serialiseRecord","record","deserialiseRecord","MemoryCollection","simulatedLatency","Map","indices","serialised","internalCheckDuplicates","set","internalPopulateIndices","has","updates","internalGetSerialisedIds","map","sId","oldSerialised","oldValue","newValue","newSerialised","internalRemoveIndices","sIds","fields","field","applyFilter","delete","length","sKey","index","serialisedValue","checkId","Set","add","size","globalDbs","initial","existing","getGlobal","MemoryDb","url","parsedUrl","URL","hostname","params","searchParams","Number","db","mapTables","close","MongoDb","client","MongoClient","default","connect","useNewUrlParser","useUnifiedTopology","escapeName","getDb","minifyLuaScript","lines","argNames","combined","ln","trim","join","RegExp","notUndefined","item","makeIndexKeys","partialSerialisedValue","filter","prefix","parseItem","f","itemHasContent","values","unwatchAll","unwatch","mapAwaitSync","RedisCollection","pool","keyPrefix","keyPrefixes","keyInfo","uniqueKeys","nonUniqueKeys","withConnection","runAdd","patchSerialised","retryWithConnection","patch","getUpdatePatch","runUpdates","insertValue","getAndWatchBySerialisedKey","patches","getByKeysKeepWatches","makeKey","cut","indexedKeys","items","rawByKeyKeepWatches","pipeline","multi","remove","exec","serialisedId","checkWatch","keyCount","entries","flat","watch","argsList","makeUpdateArgs","results","updateArgs","checkUpdate","chain","updateWithoutCheck","diff","patchUniqueKeys","patchNonUniqueKeys","oldUniqueKeys","oldNonUniqueKeys","serialisedIds","commands","multiExec","exists","hmget","hgetall","parsed","keyAddress","smembers","SCRIPT_ADD","FRAG_CHECK_UPDATE","FRAG_UPDATE","SCRIPT_CHECK_UPDATE","SCRIPT_UPDATE_WITHOUT_CHECK","SCRIPT_UPDATE","SCRIPT_REMOVE","withRetry","RedisConnectionPool","RedisStatic","maxConnections","teardown","getConnection","returnConnection","inUse","doClose","closingFn","connections","disconnect","pop","defineCommand","lua","defineAllScripts","queue","q","shift","RedisDb","lazyConnect","getConnectionPool","quoteHValue","DQUOTE_REG","SQUOTE_REG","quoteValue","msg","ID_REG","withIdentifiers","base","identifiers","quoteIdentifier","STATEMENTS","CREATE_TABLE","CREATE_INDEX","CREATE_UNIQUE_INDEX","DROP_INDEX","INSERT","UPDATE","UPDATE_ID","UPSERT_ID","SELECT_ONE","SELECT_ALL","SELECT_ALL_BY","SELECT_ID","DELETE","DELETE_ID","toHStore","encodeHStore","fromHStore","rawMap","hstore","current","currentKey","quote","decodeHStore","PostgresCollection","tableName","T","keyEntries","I","release","configureTable","then","pending","catch","process","stderr","write","rest","runTableQuery","rowCount","rows","queryName","cached","cachedQueries","rowMode","text","PostgresDb","Pool","connectionString","end","hasAnyField","WrappedCollection","baseCollection","wrapper","wrapAll","unwrapAll","getAll","extra","all","preRemove","processed","preWrap","allFields","wrap","preUnwrap","unwrap","LruCache","capacity","storage","flush","next","ALG","ALG_BUF","nodeEncryptionSync","encrypt","iv","crypto","randomBytes","cipher","createCipheriv","part","final","concat","decrypt","slice","equals","encrypted","decipher","createDecipheriv","decrypted","generateKey","createSecretKey","serialiseKey","export","deserialiseKey","makeEncrypter","encryptByKey","cr","encryptByRecord","keyCollection","cacheSize","cache","loadKey","generateIfNeeded","removeKey","encryptByRecordWithMasterKey","sMasterKey","keyEnc","CollectionStorage","dbClass","startsWith"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"websocket-express\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"websocket-express\"] = factory();\n\telse\n\t\troot[\"websocket-express\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","import Collection, { UpdateOptions } from './Collection';\nimport IDable from './IDable';\nimport { DBKeys } from './DB';\n\nexport default abstract class BaseCollection<T extends IDable> implements Collection<T> {\n  protected constructor(\n    protected readonly keys: DBKeys<T>,\n  ) {}\n\n  public async add(entry: T): Promise<void> {\n    await this.preAct();\n    return this.internalAdd(entry);\n  }\n\n  public async get<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    searchAttribute: K,\n    searchValue: T[K],\n    returnAttributes?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    if (!this.isIndexed(searchAttribute)) {\n      throw new Error(`No index for ${searchAttribute}`);\n    }\n    await this.preAct();\n    return this.internalGet(searchAttribute, searchValue, returnAttributes);\n  }\n\n  public async getAll<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    searchAttribute?: K,\n    searchValue?: T[K],\n    returnAttributes?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    if (searchAttribute && !this.isIndexed(searchAttribute)) {\n      throw new Error(`No index for ${searchAttribute}`);\n    }\n    await this.preAct();\n    return this.internalGetAll(searchAttribute, searchValue, returnAttributes);\n  }\n\n  public async update<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n    update: Partial<T>,\n    options: UpdateOptions = {},\n  ): Promise<void> {\n    if (searchAttribute === 'id' && update.id !== undefined && update.id !== searchValue) {\n      throw new Error('Cannot update ID');\n    }\n    if (options.upsert) {\n      if (searchAttribute !== 'id') {\n        throw new Error(`Can only upsert by ID, not ${searchAttribute}`);\n      }\n      let withoutId = update;\n      if (Object.prototype.hasOwnProperty.call(update, 'id')) {\n        withoutId = { ...update };\n        delete withoutId.id;\n      }\n      await this.preAct();\n      return this.internalUpsert(searchValue as T['id'], withoutId, options);\n    }\n    if (!this.isIndexed(searchAttribute)) {\n      throw new Error(`No index for ${searchAttribute}`);\n    }\n    if (\n      !this.isIndexUnique(searchAttribute) &&\n      Object.keys(update).some((k) => this.isIndexUnique(k))\n    ) {\n      throw new Error('duplicate');\n    }\n\n    await this.preAct();\n    return this.internalUpdate(searchAttribute, searchValue, update, options);\n  }\n\n  public async remove<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n  ): Promise<number> {\n    if (!this.isIndexed(searchAttribute)) {\n      throw new Error(`No index for ${searchAttribute}`);\n    }\n    await this.preAct();\n    return this.internalRemove(searchAttribute, searchValue);\n  }\n\n  protected isIndexed(attribute: string): boolean {\n    return (\n      attribute === 'id' ||\n      this.keys[attribute as keyof DBKeys<T>] !== undefined\n    );\n  }\n\n  protected isIndexUnique(attribute: string): boolean {\n    const keyOptions = this.keys[attribute as keyof DBKeys<T>];\n    return (\n      attribute === 'id' ||\n      Boolean(keyOptions && keyOptions.unique)\n    );\n  }\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-empty-function\n  protected preAct(): Promise<void> | void {}\n\n  protected async internalGet<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    searchAttribute: K,\n    searchValue: T[K],\n    returnAttributes?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    const all = await this.internalGetAll(searchAttribute, searchValue, returnAttributes);\n    return all[0] ?? null;\n  }\n\n  protected internalUpsert(\n    id: T['id'],\n    update: Partial<T>,\n    options: UpdateOptions,\n  ): Promise<void> {\n    return this.internalUpdate('id', id, update, options);\n  }\n\n  protected abstract internalAdd(entry: T): Promise<void>;\n\n  protected abstract internalGetAll<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    searchAttribute?: K,\n    searchValue?: T[K],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]>;\n\n  protected abstract internalUpdate<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n    update: Partial<T>,\n    options: UpdateOptions,\n  ): Promise<void>;\n\n  protected abstract internalRemove<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n  ): Promise<number>;\n}\n","module.exports = require(\"crypto\");","function sleep(millis: number): Promise<void> | null {\n  return new Promise((resolve): any => setTimeout(resolve, millis));\n}\n\nexport default (\n  shouldRetry: (e: any) => boolean,\n  maxAttempts = 5,\n  baseDelayMillis = 20,\n  attemptDelayMillis = 200,\n  randomDelayMillis = 200,\n) => async <T>(fn: () => Promise<T> | T): Promise<T> => {\n  for (let attempt = 1; ; attempt += 1) {\n    try {\n      // eslint-disable-next-line no-await-in-loop\n      return await fn();\n    } catch (e) {\n      if (!shouldRetry(e)) {\n        throw e;\n      }\n      if (attempt >= maxAttempts) {\n        e.message += ` (attempted ${attempt} times)`;\n        throw e;\n      }\n    }\n    // eslint-disable-next-line no-await-in-loop\n    await sleep(\n      baseDelayMillis +\n      attempt * attemptDelayMillis +\n      Math.random() * randomDelayMillis,\n    );\n  }\n};\n","module.exports = require(\"mongodb\");","module.exports = require(\"url\");","import {\n  Collection as MCollection,\n  Binary as MBinary,\n} from 'mongodb';\nimport IDable from '../interfaces/IDable';\nimport BaseCollection from '../interfaces/BaseCollection';\nimport { DBKeys } from '../interfaces/DB';\nimport retry from '../helpers/retry';\n\nconst MONGO_ID = '_id';\nconst ID = 'id';\n\ninterface State {\n  closed: boolean;\n}\n\nconst DOT_REG = /\\./g;\nfunction fieldNameToMongo(name: string): string {\n  if (name === ID) {\n    return MONGO_ID;\n  }\n  return encodeURIComponent(name).replace(DOT_REG, '%2E');\n}\n\nfunction fieldNameFromMongo(name: string): string {\n  if (name === MONGO_ID) {\n    return ID;\n  }\n  return decodeURIComponent(name);\n}\n\nconst withUpsertRetry = retry((e) => (\n  typeof e === 'object' &&\n  e.message.includes('E11000')\n));\n\nfunction convertToMongo<T extends Partial<IDable>>(\n  value: T,\n): Record<string, unknown> {\n  const converted: Record<string, unknown> = {};\n  Object.keys(value).forEach((k) => {\n    let v = (value as any)[k];\n    if (v instanceof Buffer) {\n      v = new MBinary(v);\n      // eslint-disable-next-line no-underscore-dangle\n    } else if (typeof v === 'object' && v._bsontype) {\n      throw new Error('Must use Buffer to provide binary data');\n    }\n    converted[fieldNameToMongo(k)] = v;\n  });\n  return converted;\n}\n\nfunction convertFromMongo<T extends Partial<IDable>>(\n  value: Record<string, unknown> | null,\n): T | null {\n  if (!value) {\n    return null;\n  }\n  const converted: T = {} as any;\n  Object.keys(value).forEach((k) => {\n    let v = (value as any)[k];\n    // eslint-disable-next-line no-underscore-dangle\n    if (typeof v === 'object' && v._bsontype === 'Binary') {\n      v = v.buffer;\n    }\n    (converted as any)[fieldNameFromMongo(k)] = v;\n  });\n  return converted;\n}\n\nfunction makeMongoProjection(\n  names?: readonly string[],\n): Record<string, boolean> {\n  const projection: Record<string, boolean> = {};\n  if (names) {\n    projection[MONGO_ID] = false;\n    names.forEach((fieldName) => {\n      projection[fieldNameToMongo(fieldName)] = true;\n    });\n  }\n  return projection;\n}\n\nexport default class MongoCollection<T extends IDable> extends BaseCollection<T> {\n  public constructor(\n    private readonly collection: MCollection,\n    keys: DBKeys<T> = {},\n    private readonly stateRef: State = { closed: false },\n  ) {\n    super(keys);\n    Object.keys(keys).forEach((k) => {\n      const keyName = k as keyof DBKeys<T>;\n      const options = keys[keyName];\n      const mongoKey = fieldNameToMongo(keyName);\n      if (options?.unique) {\n        collection.createIndex({ [mongoKey]: 1 }, { unique: true });\n      } else {\n        collection.createIndex({ [mongoKey]: 'hashed' });\n      }\n    });\n  }\n\n  protected async internalAdd(value: T): Promise<void> {\n    await this.getCollection().insertOne(convertToMongo(value));\n  }\n\n  protected async internalUpsert(\n    id: T['id'],\n    update: Partial<T>,\n  ): Promise<void> {\n    await withUpsertRetry(() => this.getCollection().updateOne(\n      convertToMongo({ id }),\n      { $set: convertToMongo(update) },\n      { upsert: true },\n    ));\n  }\n\n  protected async internalUpdate<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n    update: Partial<T>,\n  ): Promise<void> {\n    const query = convertToMongo({ [searchAttribute]: searchValue });\n    const mongoUpdate = { $set: convertToMongo(update) };\n    if (this.isIndexUnique(searchAttribute)) {\n      await this.getCollection().updateOne(query, mongoUpdate);\n    } else {\n      await this.getCollection().updateMany(query, mongoUpdate);\n    }\n  }\n\n  protected async internalGet<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    searchAttribute: K,\n    searchValue: T[K],\n    returnAttributes?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    const raw = await this.getCollection().findOne(\n      convertToMongo({ [searchAttribute]: searchValue }),\n      { projection: makeMongoProjection(returnAttributes) },\n    );\n    return convertFromMongo<T>(raw);\n  }\n\n  protected async internalGetAll<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    searchAttribute?: K,\n    searchValue?: T[K],\n    returnAttributes?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    const cursor = this.getCollection().find(\n      searchAttribute ? convertToMongo({ [searchAttribute]: searchValue }) : {},\n      { projection: makeMongoProjection(returnAttributes) },\n    );\n\n    const result: Pick<T, F[-1]>[] = [];\n    await cursor.forEach((raw) => result.push(convertFromMongo<T>(raw)!));\n\n    return result;\n  }\n\n  protected async internalRemove<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n  ): Promise<number> {\n    const result = await this.getCollection().deleteMany(\n      convertToMongo({ [searchAttribute]: searchValue }),\n    );\n    return result.deletedCount || 0;\n  }\n\n  private getCollection(): MCollection {\n    if (this.stateRef.closed) {\n      throw new Error('Connection closed');\n    }\n    return this.collection;\n  }\n}\n","module.exports = require(\"ioredis\");","module.exports = require(\"pg\");","export function serialiseValue(\n  value: unknown,\n): string {\n  if (value instanceof Buffer) {\n    return `B${value.toString('base64')}`;\n  }\n  return `J${JSON.stringify(value)}`;\n}\n\nexport function deserialiseValue(\n  value: string,\n): unknown {\n  const type = value[0];\n  const data = value.substr(1);\n  if (type === 'B') {\n    return Buffer.from(data, 'base64');\n  }\n  if (type === 'J') {\n    return JSON.parse(data);\n  }\n  throw new Error(`Unknown data type ${type}`);\n}\n\nexport function serialiseRecord<T>(\n  record: T,\n): Record<string, string> {\n  const result: Record<string, string> = {};\n  Object.keys(record).forEach((k) => {\n    result[k] = serialiseValue((record as any)[k]);\n  });\n  return result;\n}\n\nexport function deserialiseRecord(\n  record: Record<string, string | null>,\n): Record<string, unknown> {\n  const result: Record<string, any> = {};\n  Object.keys(record).forEach((k) => {\n    const v = record[k];\n    if (v) {\n      result[k] = deserialiseValue(v);\n    }\n  });\n  return result;\n}\n","import IDable from '../interfaces/IDable';\nimport BaseCollection from '../interfaces/BaseCollection';\nimport { DBKeys } from '../interfaces/DB';\nimport {\n  serialiseValue,\n  serialiseRecord,\n  deserialiseRecord,\n} from '../helpers/serialiser';\n\nfunction sleep(millis: number): Promise<void> | void {\n  if (!millis) {\n    return undefined;\n  }\n\n  // Simulate data access delays to ensure non-flakey e2e tests, etc.\n  return new Promise((resolve): any => setTimeout(resolve, millis));\n}\n\nfunction applyFilter<T, F extends readonly (keyof T)[]>(\n  data: T,\n  fields?: F,\n): Pick<T, F[-1]> {\n  if (!fields) {\n    return data;\n  }\n  const result: Pick<T, F[-1]> = {} as any;\n  fields.forEach((field) => {\n    result[field] = data[field];\n  });\n  return result;\n}\n\ninterface State {\n  closed: boolean;\n}\n\nexport default class MemoryCollection<T extends IDable> extends BaseCollection<T> {\n  private readonly data: Map<string, Record<string, string>>;\n\n  private readonly indices: Partial<Record<keyof T, Map<string, Set<string>>>> = {};\n\n  public constructor(\n    keys: DBKeys<T> = {},\n    private readonly simulatedLatency = 0,\n    private readonly stateRef: State = { closed: false },\n  ) {\n    super(keys);\n\n    this.data = new Map();\n\n    Object.keys(keys).forEach((k) => {\n      this.indices[k as keyof T] = new Map();\n    });\n  }\n\n  protected preAct(): Promise<void> | void {\n    if (this.stateRef.closed) {\n      throw new Error('Connection closed');\n    }\n    return sleep(this.simulatedLatency);\n  }\n\n  protected async internalAdd(value: T): Promise<void> {\n    const serialised = serialiseRecord(value);\n    this.internalCheckDuplicates(serialised, true);\n    this.data.set(serialised.id, serialised);\n    this.internalPopulateIndices(serialised);\n  }\n\n  protected async internalUpsert(\n    id: T['id'],\n    update: Partial<T>,\n  ): Promise<void> {\n    if (this.data.has(serialiseValue(id))) {\n      await this.internalUpdate('id', id, update);\n    } else {\n      await this.internalAdd({ id, ...update } as T);\n    }\n  }\n\n  protected async internalUpdate<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n    update: Partial<T>,\n  ): Promise<void> {\n    const sIds = this.internalGetSerialisedIds(searchAttribute, searchValue);\n\n    const updates = sIds.map((sId) => {\n      const oldSerialised = this.data.get(sId)!;\n      const oldValue = deserialiseRecord(oldSerialised) as T;\n      const newValue = { ...oldValue, ...update };\n      if (newValue.id !== oldValue.id) {\n        throw new Error('Cannot update ID');\n      }\n      const newSerialised = serialiseRecord(newValue);\n      return { oldSerialised, newSerialised };\n    });\n\n    updates.forEach(({ oldSerialised }) => this.internalRemoveIndices(oldSerialised));\n    try {\n      updates.forEach(({ newSerialised }) => this.internalCheckDuplicates(newSerialised, false));\n    } catch (e) {\n      updates.forEach(({ oldSerialised }) => this.internalPopulateIndices(oldSerialised));\n      throw e;\n    }\n    updates.forEach(({ newSerialised }) => {\n      this.data.set(newSerialised.id, newSerialised);\n      this.internalPopulateIndices(newSerialised);\n    });\n  }\n\n  protected async internalGetAll<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    searchAttribute?: K,\n    searchValue?: T[K],\n    returnAttributes?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    let sIds: string[];\n    if (searchAttribute) {\n      sIds = this.internalGetSerialisedIds(searchAttribute, searchValue!);\n    } else {\n      sIds = [...this.data.keys()];\n    }\n    return sIds.map((sId) => applyFilter(\n      deserialiseRecord(this.data.get(sId)!) as T,\n      returnAttributes,\n    ));\n  }\n\n  protected async internalRemove<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n  ): Promise<number> {\n    const sIds = this.internalGetSerialisedIds(searchAttribute, searchValue);\n    sIds.forEach((sId) => {\n      const oldSerialised = this.data.get(sId)!;\n      this.internalRemoveIndices(oldSerialised);\n      this.data.delete(sId);\n    });\n\n    return sIds.length;\n  }\n\n  private internalGetSerialisedIds<K extends keyof T>(\n    searchAttribute: K,\n    searchValue: T[K],\n  ): string[] {\n    const sKey = serialiseValue(searchValue);\n    if (searchAttribute === 'id') {\n      return this.data.has(sKey) ? [sKey] : [];\n    }\n    const index = this.indices[searchAttribute];\n    if (!index) {\n      throw new Error(`Requested key ${searchAttribute} not indexed`);\n    }\n    const sIds = index.get(sKey);\n    return sIds ? [...sIds] : []; // convert set to array\n  }\n\n  private internalCheckDuplicates(\n    serialisedValue: Record<string, string>,\n    checkId: boolean,\n  ): void {\n    if (checkId && this.data.has(serialisedValue.id)) {\n      throw new Error('duplicate');\n    }\n    Object.keys(this.keys).forEach((key) => {\n      const index = this.indices[key as keyof T]!;\n      if (this.isIndexUnique(key) && index.has(serialisedValue[key])) {\n        throw new Error('duplicate');\n      }\n    });\n  }\n\n  private internalPopulateIndices(\n    serialisedValue: Record<string, string>,\n  ): void {\n    Object.keys(this.keys).forEach((key) => {\n      const index = this.indices[key as keyof T]!;\n      const v = serialisedValue[key];\n      let o = index.get(v);\n      if (!o) {\n        o = new Set<string>();\n        index.set(v, o);\n      }\n      o.add(serialisedValue.id);\n    });\n  }\n\n  private internalRemoveIndices(\n    serialisedValue: Record<string, string>,\n  ): void {\n    Object.keys(this.keys).forEach((key) => {\n      const index = this.indices[key as keyof T]!;\n      const v = serialisedValue[key];\n      const o = index.get(v)!;\n      o.delete(serialisedValue.id);\n      if (!o.size) {\n        index.delete(v);\n      }\n    });\n  }\n}\n","import { URL } from 'url';\nimport MemoryCollection from './MemoryCollection';\nimport DB, { DBKeys } from '../interfaces/DB';\nimport IDable from '../interfaces/IDable';\n\nfunction getGlobal<T>(name: string, initial: T): T {\n  const existing = (global as any)[name];\n  if (existing) {\n    return existing;\n  }\n\n  (global as any)[name] = initial;\n  return initial;\n}\n\nconst globalDbs = getGlobal(\n  'collectionStorageInMemory',\n  new Map<string, MemoryDb>(),\n);\n\nexport default class MemoryDb implements DB {\n  private readonly simulatedLatency: number;\n\n  private readonly mapTables = new Map<string, MemoryCollection<any>>();\n\n  private readonly stateRef = { closed: false };\n\n  public constructor({ simulatedLatency = 0 } = {}) {\n    this.simulatedLatency = simulatedLatency;\n  }\n\n  public static connect(url: string): MemoryDb {\n    const parsedUrl = new URL(url);\n    const name = parsedUrl.hostname;\n    if (name && globalDbs.has(name)) {\n      return globalDbs.get(name)!;\n    }\n    const params = parsedUrl.searchParams;\n    const simulatedLatency = Number(params.get('simulatedLatency'));\n    const db = new MemoryDb({ simulatedLatency });\n    if (name) {\n      globalDbs.set(name, db);\n    }\n    return db;\n  }\n\n  public getCollection<T extends IDable>(\n    name: string,\n    keys?: DBKeys<T>,\n  ): MemoryCollection<T> {\n    if (!this.mapTables.has(name)) {\n      this.mapTables.set(name, new MemoryCollection(\n        keys,\n        this.simulatedLatency,\n        this.stateRef,\n      ));\n    }\n    return this.mapTables.get(name)! as MemoryCollection<T>;\n  }\n\n  public close(): void {\n    this.stateRef.closed = true;\n  }\n}\n","import DB, { DBKeys } from '../interfaces/DB';\nimport IDable from '../interfaces/IDable';\n\nfunction escapeName(name: string): string {\n  return encodeURIComponent(name);\n}\n\nexport default class MongoDb implements DB {\n  private readonly stateRef = { closed: false };\n\n  private constructor(\n    private readonly client: import('mongodb').MongoClient,\n    private readonly MongoCollection: typeof import('./MongoCollection').default,\n  ) {}\n\n  public static async connect(url: string): Promise<MongoDb> {\n    const { MongoClient } = await import('mongodb');\n    const {\n      default: MongoCollection,\n    } = await import(/* webpackMode: \"eager\" */ './MongoCollection');\n    const client = await MongoClient.connect(url, {\n      useNewUrlParser: true,\n      useUnifiedTopology: true,\n    });\n    return new MongoDb(client, MongoCollection);\n  }\n\n  public getCollection<T extends IDable>(\n    name: string,\n    keys?: DBKeys<T>,\n  ): import('./MongoCollection').default<T> {\n    const collection = this.client.db().collection(escapeName(name));\n    return new this.MongoCollection(collection, keys, this.stateRef);\n  }\n\n  public async close(): Promise<void> {\n    this.stateRef.closed = true;\n    return this.client.close();\n  }\n\n  public getDb(): import('mongodb').Db {\n    return this.client.db();\n  }\n}\n","type Redis = import('ioredis').Redis;\ntype Pipeline = import('ioredis').Pipeline;\ntype MultiOptions = import('ioredis').MultiOptions;\n\n// Thanks, https://stackoverflow.com/a/50014868/1180785\ntype ArgumentTypes<T> = T extends (...args: infer U) => any ? U : never;\n\ntype PipelineVersions<I> = {\n  [K in keyof I]: (...args: ArgumentTypes<I[K]>) => Pipeline & PipelineVersions<I>;\n};\n\ninterface RedisWithExtendedPipeline<I> extends Redis {\n  multi(commands?: string[][], options?: MultiOptions): Pipeline & PipelineVersions<I>;\n  multi(options: { pipeline: false }): Promise<string>;\n}\n\nexport type ExtendedRedis<I> = I & RedisWithExtendedPipeline<I>;\n\nexport async function multiExec(\n  client: Redis,\n  commands: string[][],\n): Promise<[unknown, any][] | null> {\n  if (!commands.length) {\n    return [];\n  }\n  return client.multi(commands).exec();\n}\n\nexport function minifyLuaScript(\n  lines: string[],\n  ...argNames: string[]\n): string {\n  let combined = lines.map((ln) => ln.trim()).join(' ');\n  argNames.forEach((name, i) => {\n    combined = combined.replace(new RegExp(`\\\\$${name}\\\\b`, 'g'), `ARGV[${i + 1}]`);\n  });\n  return combined;\n}\n","import IDable from '../interfaces/IDable';\nimport BaseCollection from '../interfaces/BaseCollection';\nimport { UpdateOptions } from '../interfaces/Collection';\nimport { DBKeys } from '../interfaces/DB';\nimport {\n  serialiseValue,\n  serialiseRecord,\n  deserialiseRecord,\n} from '../helpers/serialiser';\nimport RedisConnectionPool from './RedisConnectionPool';\nimport { multiExec } from './helpers';\nimport { ERedis } from './scripts';\n\ninterface Key<T> {\n  key: keyof T & string;\n  prefix: string;\n}\n\ninterface InternalPatch {\n  sId: string;\n  oldSerialised: Record<string, string | null>;\n  newSerialised: Record<string, string>;\n}\n\nconst notUndefined = <T>(item?: T): item is T => (item !== undefined);\n\nfunction makeIndexKeys(\n  keys: Key<any>[],\n  partialSerialisedValue: Record<string, string | null>,\n): string[] {\n  return keys\n    .filter(({ key }) => partialSerialisedValue[key])\n    .map(({ key, prefix }) => `${prefix}:${partialSerialisedValue[key]}`);\n}\n\nfunction parseItem(\n  item: (string | null)[] | Record<string, string | null>,\n  fields?: readonly string[],\n): Record<string, string | null> {\n  if (!fields) {\n    return item as any;\n  }\n  const result: Record<string, string | null> = {};\n  for (let f = 0; f < fields.length; f += 1) {\n    result[fields[f]] = (item as any)[f];\n  }\n  return result;\n}\n\nfunction itemHasContent(item: Record<string, string | null>): boolean {\n  return Object.values(item).some((v) => (v !== null));\n}\n\nasync function unwatchAll(client: ERedis): Promise<void> {\n  await client.unwatch();\n}\n\nasync function mapAwaitSync<T, O>(\n  values: T[],\n  fn: (value: T) => Promise<O>,\n): Promise<O[]> {\n  const result: O[] = [];\n  for (let i = 0; i < values.length; i += 1) {\n    // eslint-disable-next-line no-await-in-loop\n    result.push(await fn(values[i]));\n  }\n  return result;\n}\n\nexport default class RedisCollection<T extends IDable> extends BaseCollection<T> {\n  private readonly keyPrefixes: { [K in keyof T]?: string } = {};\n\n  private readonly uniqueKeys: Key<T>[] = [];\n\n  private readonly nonUniqueKeys: Key<T>[] = [];\n\n  public constructor(\n    private readonly pool: RedisConnectionPool,\n    private readonly prefix: string,\n    keys: DBKeys<T> = {},\n  ) {\n    super(keys);\n\n    Object.keys(keys).forEach((k) => {\n      const key = k as keyof DBKeys<T>;\n      const keyPrefix = `${prefix}-${key}`;\n      this.keyPrefixes[key] = keyPrefix;\n      const keyInfo = { key, prefix: keyPrefix };\n      if (keys[key]!.unique) {\n        this.uniqueKeys.push(keyInfo);\n      } else {\n        this.nonUniqueKeys.push(keyInfo);\n      }\n    });\n  }\n\n  protected internalAdd(value: T): Promise<void> {\n    const serialised = serialiseRecord(value);\n    return this.pool.withConnection(async (client) => {\n      const added = await this.runAdd(client, serialised, false);\n      if (!added) {\n        throw new Error('duplicate');\n      }\n    });\n  }\n\n  protected internalUpdate<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n    update: Partial<T>,\n    { upsert }: UpdateOptions,\n  ): Promise<void> {\n    const patchSerialised = serialiseRecord(update);\n    const sKey = serialiseValue(searchValue);\n\n    if (searchAttribute === 'id') {\n      return this.pool.retryWithConnection(async (client) => {\n        const patch = await this.getUpdatePatch(client, sKey, patchSerialised);\n        if (patch) {\n          await this.runUpdates(client, [patch]);\n        } else if (upsert) {\n          const insertValue = { ...patchSerialised, id: sKey };\n          if (!await this.runAdd(client, insertValue, true)) {\n            throw new Error('duplicate');\n          }\n        }\n      }, unwatchAll);\n    }\n\n    return this.pool.retryWithConnection(async (client) => {\n      const sIds = await this.getAndWatchBySerialisedKey(client, searchAttribute, sKey);\n      const patches = (await mapAwaitSync(\n        sIds,\n        (sId) => this.getUpdatePatch(client, sId, patchSerialised),\n      )).filter(notUndefined);\n      await this.runUpdates(client, patches);\n    }, unwatchAll);\n  }\n\n  protected internalGet<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    searchAttribute: K,\n    searchValue: T[K],\n    returnAttributes?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    const sKey = serialiseValue(searchValue);\n    return this.pool.retryWithConnection(async (client) => {\n      const sId = (await this.getAndWatchBySerialisedKey(client, searchAttribute, sKey))[0];\n      if (sId === undefined) {\n        return null;\n      }\n      const results = await this.getByKeysKeepWatches(client, [sId], returnAttributes);\n      return results[0] ?? null;\n    }, unwatchAll);\n  }\n\n  protected internalGetAll<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    searchAttribute?: K,\n    searchValue?: T[K],\n    returnAttributes?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    return this.pool.retryWithConnection(async (client) => {\n      let sIds: string[];\n      if (searchAttribute) {\n        const sKey = serialiseValue(searchValue);\n        sIds = await this.getAndWatchBySerialisedKey(client, searchAttribute, sKey);\n      } else {\n        sIds = await client.keys(this.makeKey('*'));\n        const cut = this.prefix.length + 1;\n        sIds = sIds.map((v) => v.substr(cut));\n      }\n      return this.getByKeysKeepWatches(client, sIds, returnAttributes);\n    }, unwatchAll);\n  }\n\n  protected internalRemove<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n  ): Promise<number> {\n    const sKey = serialiseValue(searchValue);\n    const indexedKeys = Object.keys(this.keys);\n    indexedKeys.push('id');\n\n    return this.pool.retryWithConnection(async (client) => {\n      const sIds = await this.getAndWatchBySerialisedKey(client, searchAttribute, sKey);\n      const items = (await mapAwaitSync(\n        sIds,\n        (sId) => this.rawByKeyKeepWatches(client, sId, indexedKeys),\n      )).filter(notUndefined);\n\n      if (items.length === 0) {\n        return 0;\n      }\n\n      const pipeline = client.multi();\n      items.forEach((item) => {\n        const uniqueKeys = makeIndexKeys(this.uniqueKeys, item);\n        const nonUniqueKeys = makeIndexKeys(this.nonUniqueKeys, item);\n        pipeline.remove(\n          1 + uniqueKeys.length + nonUniqueKeys.length,\n          this.makeKey(item.id!),\n          ...uniqueKeys,\n          ...nonUniqueKeys,\n          item.id!,\n        );\n      });\n      await pipeline.exec();\n      return items.length;\n    }, unwatchAll);\n  }\n\n  private makeKey(serialisedId: string): string {\n    return `${this.prefix}:${serialisedId}`;\n  }\n\n  private async runAdd(\n    client: ERedis,\n    { id, ...serialised }: Record<string, string>,\n    checkWatch: boolean,\n  ): Promise<boolean> {\n    const uniqueKeys = makeIndexKeys(this.uniqueKeys, serialised);\n    const nonUniqueKeys = makeIndexKeys(this.nonUniqueKeys, serialised);\n\n    const keyCount = 1 + uniqueKeys.length + nonUniqueKeys.length;\n    const params = [\n      this.makeKey(id),\n      ...uniqueKeys,\n      ...nonUniqueKeys,\n      uniqueKeys.length,\n      'id', // ID is always first in flattened key/value pairs\n      id,\n      ...Object.entries(serialised).flat(),\n    ];\n\n    if (!checkWatch) {\n      return Boolean(await client.add(keyCount, ...params));\n    }\n\n    const result = await client\n      .multi()\n      .add(keyCount, ...params)\n      .exec();\n    if (!result) {\n      throw new Error('transient error');\n    }\n    return Boolean(result[0][1]);\n  }\n\n  private async getUpdatePatch(\n    client: ERedis,\n    sId: string,\n    patchSerialised: Record<string, string>,\n  ): Promise<InternalPatch | undefined> {\n    await client.watch(this.makeKey(sId));\n    const oldSerialised = await this.rawByKeyKeepWatches(\n      client,\n      sId,\n      Object.keys(this.keys).filter((k) => patchSerialised[k]),\n    );\n    if (!oldSerialised) {\n      return undefined;\n    }\n    const newSerialised = { ...patchSerialised };\n    Object.keys(newSerialised).forEach((k) => {\n      if (oldSerialised[k] === newSerialised[k]) {\n        delete newSerialised[k];\n        delete oldSerialised[k];\n      }\n    });\n    return { sId, newSerialised, oldSerialised };\n  }\n\n  private async runUpdates(\n    client: ERedis,\n    patches: InternalPatch[],\n  ): Promise<void> {\n    const argsList = patches\n      .map((patch) => this.makeUpdateArgs(patch))\n      .filter(notUndefined);\n\n    if (!argsList.length) {\n      return;\n    }\n\n    if (argsList.length === 1) {\n      const results = await client.multi()\n        .update(argsList[0][0], argsList[0][1])\n        .exec();\n\n      if (!results) {\n        throw new Error('transient error');\n      }\n      if (!results[0][1]) {\n        throw new Error('duplicate');\n      }\n      return;\n    }\n\n    const updateCheckResults = await mapAwaitSync(\n      argsList,\n      (updateArgs) => client.checkUpdate(updateArgs[0], updateArgs[1]),\n    );\n    if (updateCheckResults.some((r) => !r)) {\n      throw new Error('duplicate');\n    }\n\n    let chain = client.multi();\n    argsList.forEach((updateArgs) => {\n      chain = chain.updateWithoutCheck(updateArgs[0], updateArgs[1]);\n    });\n    const results = await chain.exec();\n\n    if (!results) {\n      throw new Error('transient error');\n    }\n  }\n\n  private makeUpdateArgs(\n    { sId, oldSerialised, newSerialised }: InternalPatch,\n  ): [number, any[]] | undefined {\n    const diff = Object.entries(newSerialised).flat();\n    if (!diff.length) {\n      return undefined; // nothing changed\n    }\n    const patchUniqueKeys = makeIndexKeys(this.uniqueKeys, newSerialised);\n    const patchNonUniqueKeys = makeIndexKeys(this.nonUniqueKeys, newSerialised);\n    const oldUniqueKeys = makeIndexKeys(this.uniqueKeys, oldSerialised);\n    const oldNonUniqueKeys = makeIndexKeys(this.nonUniqueKeys, oldSerialised);\n    if (\n      oldUniqueKeys.length !== patchUniqueKeys.length ||\n      oldNonUniqueKeys.length !== patchNonUniqueKeys.length\n    ) {\n      throw new Error('unexpected key mismatch with old value');\n    }\n    const keyCount = 1 + (patchUniqueKeys.length + patchNonUniqueKeys.length) * 2;\n    const params = [\n      this.makeKey(sId),\n      ...patchUniqueKeys,\n      ...patchNonUniqueKeys,\n      ...oldUniqueKeys,\n      ...oldNonUniqueKeys,\n      patchUniqueKeys.length,\n      patchUniqueKeys.length + patchNonUniqueKeys.length,\n      sId,\n      ...diff,\n    ];\n    return [keyCount, params];\n  }\n\n  private async getByKeysKeepWatches<F extends readonly (keyof T & string)[]>(\n    client: ERedis,\n    serialisedIds: string[],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    const results = await multiExec(\n      client,\n      serialisedIds\n        .map((sId) => this.makeKey(sId))\n        .map((k) => (fields ? ['hmget', k, ...fields] : ['hgetall', k])),\n    );\n    if (!results) {\n      throw new Error('transient error');\n    }\n    return results\n      .map(([, item]: [unknown, any]) => parseItem(item, fields))\n      .filter(itemHasContent)\n      .map(deserialiseRecord) as T[];\n  }\n\n  private async rawByKeyKeepWatches(\n    client: ERedis,\n    serialisedId: string,\n    fields?: readonly string[],\n  ): Promise<Record<string, string | null> | undefined> {\n    const key = this.makeKey(serialisedId);\n    let item;\n    if (fields) {\n      if (!fields.length) {\n        // just check existence\n        const exists = await client.exists(key);\n        return exists ? {} : undefined;\n      }\n      item = await client.hmget(key, ...fields);\n    } else {\n      item = await client.hgetall(key);\n    }\n    const parsed = parseItem(item, fields);\n    return itemHasContent(parsed) ? parsed : undefined;\n  }\n\n  private async getAndWatchBySerialisedKey(\n    client: ERedis,\n    keyName: keyof T,\n    serialisedValue: string,\n  ): Promise<string[]> {\n    if (keyName === 'id') {\n      return [serialisedValue];\n    }\n    const keyPrefix = this.keyPrefixes[keyName];\n    if (!keyPrefix) {\n      throw new Error(`Requested key ${keyName} not indexed`);\n    }\n    const keyAddress = `${keyPrefix}:${serialisedValue}`;\n    await client.watch(keyAddress);\n    return client.smembers(keyAddress);\n  }\n}\n","import { minifyLuaScript, ExtendedRedis } from './helpers';\n\nexport interface ScriptExtensions {\n  add(keyCount: number, ...keysAndArgs: any[]): Promise<number>;\n  update(keyCount: number, ...keysAndArgs: any[]): Promise<number>;\n  checkUpdate(keyCount: number, ...keysAndArgs: any[]): Promise<number>;\n  updateWithoutCheck(keyCount: number, ...keysAndArgs: any[]): Promise<void>;\n  remove(keyCount: number, ...keysAndArgs: any[]): Promise<void>;\n}\n\nexport type ERedis = ExtendedRedis<ScriptExtensions>;\n\n// KEYS = [id, ...uniqueKeys, ...nonUniqueKeys]\nconst SCRIPT_ADD = minifyLuaScript([\n  'if redis.call(\"exists\",KEYS[1])==1 then',\n  '  return 0',\n  'end',\n  'for k=2,1+tonumber($uniqueKeyCount) do',\n  '  if redis.call(\"exists\",KEYS[k])==1 then',\n  '    return 0',\n  '  end',\n  'end',\n  'redis.call(\"hset\",KEYS[1],unpack(ARGV, 2))',\n  'for k=2,#KEYS do',\n  '  redis.call(\"sadd\",KEYS[k],ARGV[3])',\n  'end',\n  'return 1',\n], 'uniqueKeyCount');\n\nconst FRAG_CHECK_UPDATE = [\n  'for k=2,1+tonumber($uniqueKeyCount) do',\n  '  if redis.call(\"exists\",KEYS[k])==1 then',\n  '    return 0',\n  '  end',\n  'end',\n];\n\nconst FRAG_UPDATE = [\n  'local tkc=tonumber($totalKeyCount)',\n  'redis.call(\"hset\",KEYS[1],unpack(ARGV, 4))',\n  'for k=1,tkc do',\n  '  redis.call(\"smove\",KEYS[1+tkc+k],KEYS[1+k],$id)',\n  'end',\n];\n\n// KEYS = [id, ...patchUniqueKeys, ...patchNonUniqueKeys, ...oldUniqueKeys, ...oldNonUniqueKeys]\nconst SCRIPT_CHECK_UPDATE = minifyLuaScript([\n  ...FRAG_CHECK_UPDATE,\n  'return 1',\n], 'uniqueKeyCount', 'totalKeyCount', 'id');\n\n// KEYS = [id, ...patchUniqueKeys, ...patchNonUniqueKeys, ...oldUniqueKeys, ...oldNonUniqueKeys]\nconst SCRIPT_UPDATE_WITHOUT_CHECK = minifyLuaScript([\n  ...FRAG_UPDATE,\n], 'uniqueKeyCount', 'totalKeyCount', 'id');\n\n// KEYS = [id, ...patchUniqueKeys, ...patchNonUniqueKeys, ...oldUniqueKeys, ...oldNonUniqueKeys]\nconst SCRIPT_UPDATE = minifyLuaScript([\n  ...FRAG_CHECK_UPDATE,\n  ...FRAG_UPDATE,\n  'return 1',\n], 'uniqueKeyCount', 'totalKeyCount', 'id');\n\n// KEYS = [id, ...keys]\nconst SCRIPT_REMOVE = minifyLuaScript([\n  'redis.call(\"del\",KEYS[1])',\n  'for k=2,#KEYS do',\n  '  redis.call(\"srem\",KEYS[k],$id)',\n  'end',\n], 'id');\n\nexport default function defineAllScripts(\n  client: import('ioredis').Redis,\n): ERedis {\n  client.defineCommand('add', { lua: SCRIPT_ADD });\n  client.defineCommand('update', { lua: SCRIPT_UPDATE });\n  client.defineCommand('checkUpdate', { lua: SCRIPT_CHECK_UPDATE });\n  client.defineCommand('updateWithoutCheck', { lua: SCRIPT_UPDATE_WITHOUT_CHECK });\n  client.defineCommand('remove', { lua: SCRIPT_REMOVE });\n\n  return client as ERedis;\n}\n","import defineAllScripts, { ERedis } from './scripts';\nimport retry from '../helpers/retry';\n\ntype RedisOptions = import('ioredis').RedisOptions;\ntype Redis = import('ioredis').Redis;\ntype RS = new(host?: string, options?: RedisOptions) => Redis;\n\nconst withRetry = retry((e) => (\n  typeof e === 'object' &&\n  e.message === 'transient error'\n));\n\nexport default class RedisConnectionPool {\n  private readonly connections: ERedis[] = [];\n\n  private inUse = 0;\n\n  private queue: ((client: ERedis) => void)[] = [];\n\n  private closingFn?: () => void;\n\n  private closed = false;\n\n  public constructor(\n    private readonly RedisStatic: RS,\n    private readonly url: string,\n    private readonly options: RedisOptions,\n    private readonly maxConnections: number,\n  ) {}\n\n  public async withConnection<T>(\n    fn: (c: ERedis) => Promise<T> | T,\n    teardown?: (c: ERedis) => Promise<void> | void,\n  ): Promise<T> {\n    const c = await this.getConnection();\n    try {\n      return await fn(c);\n    } finally {\n      await teardown?.(c);\n      this.returnConnection(c);\n    }\n  }\n\n  public async retryWithConnection<T>(\n    fn: (c: ERedis) => Promise<T> | T,\n    teardown?: (c: ERedis) => Promise<void> | void,\n  ): Promise<T> {\n    return withRetry(() => this.withConnection(fn, teardown));\n  }\n\n  public close(): Promise<void> {\n    if (this.closed) {\n      return Promise.resolve();\n    }\n\n    this.closed = true;\n    if (this.inUse === 0) {\n      this.doClose();\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve): void => {\n      this.closingFn = (): void => {\n        this.doClose();\n        resolve();\n      };\n    });\n  }\n\n  private doClose(): void {\n    this.connections.forEach((c) => c.disconnect());\n    this.connections.length = 0;\n  }\n\n  private async getConnection(): Promise<ERedis> {\n    if (this.closed) {\n      throw new Error('Connection closed');\n    }\n\n    const r = this.connections.pop();\n    if (r) {\n      this.inUse += 1;\n      return r;\n    }\n    if (this.inUse < this.maxConnections) {\n      this.inUse += 1;\n      const client = new this.RedisStatic(this.url, this.options);\n      await client.connect();\n      return defineAllScripts(client);\n    }\n    return new Promise((resolve): void => {\n      this.queue.push(resolve);\n    });\n  }\n\n  private returnConnection(c: ERedis): void {\n    const q = this.queue.shift();\n    if (q) {\n      q(c);\n    } else {\n      this.inUse -= 1;\n      this.connections.push(c);\n      if (this.inUse === 0) {\n        this.closingFn?.();\n      }\n    }\n  }\n}\n","import RedisCollection from './RedisCollection';\nimport DB, { DBKeys } from '../interfaces/DB';\nimport IDable from '../interfaces/IDable';\nimport RedisConnectionPool from './RedisConnectionPool';\n\nexport default class RedisDb implements DB {\n  private constructor(\n    private readonly pool: RedisConnectionPool,\n  ) {}\n\n  public static async connect(url: string): Promise<RedisDb> {\n    const { default: RedisStatic } = await import('ioredis');\n    const connectionPoolSize = 5;\n    return new RedisDb(new RedisConnectionPool(\n      RedisStatic,\n      url,\n      { lazyConnect: true },\n      connectionPoolSize,\n    ));\n  }\n\n  public getCollection<T extends IDable>(\n    name: string,\n    keys?: DBKeys<T>,\n  ): RedisCollection<T> {\n    return new RedisCollection(this.pool, name, keys);\n  }\n\n  public close(): Promise<void> {\n    return this.pool.close();\n  }\n\n  public getConnectionPool(): RedisConnectionPool {\n    return this.pool;\n  }\n}\n","export function quoteHValue(v: string): string {\n  return `\"${v.replace(/([\"\\\\])/g, '\\\\$1')}\"`;\n}\n\nexport function encodeHStore(record: Record<string, string>): string {\n  const result: string[] = [];\n  Object.keys(record).forEach((k) => {\n    result.push(`${quoteHValue(k)}=>${quoteHValue(record[k])}`);\n  });\n  return result.join(',');\n}\n\nexport function decodeHStore(hstore: string): Record<string, string> {\n  const result: Record<string, string> = {};\n  let current = '';\n  let currentKey = '';\n  let quote = false;\n  for (let p = 0; p < hstore.length;) {\n    const c = hstore[p];\n    switch (c) {\n      case ' ':\n      case '\\r':\n      case '\\n':\n      case '\\t':\n        if (quote) {\n          current += c;\n        }\n        break;\n      case '\\\\':\n        current += hstore[p + 1];\n        p += 1;\n        break;\n      case '\"':\n        quote = !quote;\n        break;\n      case '=':\n        if (quote) {\n          current += c;\n        } else if (hstore[p + 1] === '>') {\n          currentKey = current;\n          current = '';\n          p += 1;\n        }\n        break;\n      case ',':\n        if (quote) {\n          current += c;\n        } else {\n          result[currentKey] = current;\n          currentKey = '';\n          current = '';\n        }\n        break;\n      default:\n        current += c;\n        break;\n    }\n    p += 1;\n  }\n  if (currentKey) {\n    result[currentKey] = current;\n  }\n  return result;\n}\n","const DQUOTE_REG = /\"/g;\nexport function quoteIdentifier(msg: string): string {\n  return `\"${msg.replace(DQUOTE_REG, '\"\"')}\"`;\n}\n\nconst SQUOTE_REG = /'/g;\nexport function quoteValue(msg: string): string {\n  // only used for creating indices,\n  // because prepared statements do not support CREATE\n  return `'${msg.replace(SQUOTE_REG, '\\'\\'')}'`;\n}\n\nconst ID_REG = /\\$[A-Z]/g;\nexport function withIdentifiers(\n  base: string,\n  identifiers: Record<string, string>,\n): string {\n  return base.replace(\n    ID_REG,\n    (v) => quoteIdentifier(identifiers[v.substr(1)]),\n  );\n}\n","import IDable from '../interfaces/IDable';\nimport BaseCollection from '../interfaces/BaseCollection';\nimport { DBKeys } from '../interfaces/DB';\nimport { serialiseValue, deserialiseValue, serialiseRecord } from '../helpers/serialiser';\nimport { encodeHStore, decodeHStore } from './hstore';\nimport { withIdentifiers, quoteValue } from './sql';\n\ntype PPool = import('pg').Pool;\ntype QueryArrayResult<R> = import('pg').QueryArrayResult<R>;\n\nconst STATEMENTS = {\n  CREATE_TABLE: [\n    'CREATE TABLE IF NOT EXISTS $T (',\n    'id TEXT NOT NULL PRIMARY KEY,',\n    'data HSTORE NOT NULL',\n    ')',\n  ].join(''),\n\n  CREATE_INDEX: 'CREATE INDEX IF NOT EXISTS $I ON $T USING HASH ((data->$1))',\n  CREATE_UNIQUE_INDEX: 'CREATE UNIQUE INDEX IF NOT EXISTS $I ON $T ((data->$1))',\n  DROP_INDEX: 'DROP INDEX IF EXISTS $I',\n\n  INSERT: 'INSERT INTO $T (id, data) VALUES ($1, $2::hstore)',\n\n  UPDATE: 'UPDATE $T SET data=data||$1::hstore WHERE data->$2=$3 RETURNING id',\n  UPDATE_ID: 'UPDATE $T SET data=data||$1::hstore WHERE id=$2',\n\n  UPSERT_ID: 'INSERT INTO $T (id, data) VALUES ($1, $2::hstore) ON CONFLICT (id) DO UPDATE SET data=$T.data||$2::hstore',\n\n  SELECT_ONE: 'SELECT id, data FROM $T WHERE data->$1=$2 LIMIT 1',\n  SELECT_ALL: 'SELECT id, data FROM $T',\n  SELECT_ALL_BY: 'SELECT id, data FROM $T WHERE data->$1=$2',\n  SELECT_ID: 'SELECT id, data FROM $T WHERE id=$1',\n\n  DELETE: 'DELETE FROM $T WHERE data->$1=$2',\n  DELETE_ID: 'DELETE FROM $T WHERE id=$1',\n};\n\ninterface State {\n  closed: boolean;\n}\n\nasync function configureTable(\n  pool: PPool,\n  tableName: string,\n  keys: DBKeys<any> = {},\n): Promise<void> {\n  const c = await pool.connect();\n  try {\n    await c.query(withIdentifiers(STATEMENTS.CREATE_TABLE, {\n      T: tableName,\n    }));\n\n    // PostgreSQL does not support prepared statements for CREATE statements,\n    // so we must escape the values manually using quoteValue.\n    const keyEntries = Object.entries(keys);\n    for (let i = 0; i < keyEntries.length; i += 1) {\n      /* eslint-disable no-await-in-loop */ // client cannot multitask\n      const [k, v] = keyEntries[i];\n      if (v && v.unique) {\n        await c.query(withIdentifiers(STATEMENTS.DROP_INDEX, {\n          T: tableName,\n          I: `${tableName}_i${k}`,\n        }));\n        await c.query(withIdentifiers(STATEMENTS.CREATE_UNIQUE_INDEX, {\n          T: tableName,\n          I: `${tableName}_u${k}`,\n        }).replace(/\\$1/g, quoteValue(k)));\n      } else {\n        await c.query(withIdentifiers(STATEMENTS.DROP_INDEX, {\n          T: tableName,\n          I: `${tableName}_u${k}`,\n        }));\n        await c.query(withIdentifiers(STATEMENTS.CREATE_INDEX, {\n          T: tableName,\n          I: `${tableName}_i${k}`,\n        }).replace(/\\$1/g, quoteValue(k)));\n      }\n      /* eslint-enable no-await-in-loop */\n    }\n  } finally {\n    c.release();\n  }\n}\n\nfunction toHStore(record: Record<string, unknown>): string {\n  return encodeHStore(serialiseRecord(record));\n}\n\nfunction fromHStore<T>(\n  [id, data]: readonly any[],\n  fields?: readonly string[],\n): T {\n  const rawMap = decodeHStore(data);\n  rawMap.id = id;\n\n  const result: Record<string, unknown> = {};\n\n  if (!fields) {\n    Object.entries(rawMap).forEach(([k, v]) => {\n      result[k] = deserialiseValue(v);\n    });\n    return result as T;\n  }\n\n  fields.forEach((f) => {\n    result[f] = deserialiseValue(rawMap[f]);\n  });\n  return result as T;\n}\n\nexport default class PostgresCollection<T extends IDable> extends BaseCollection<T> {\n  private readonly tableName: string;\n\n  private readonly cachedQueries: Partial<Record<keyof typeof STATEMENTS, string>> = {};\n\n  private pending?: (() => void)[] = [];\n\n  public constructor(\n    private readonly pool: PPool,\n    name: string,\n    keys: DBKeys<T> = {},\n    private readonly stateRef: State = { closed: false },\n  ) {\n    super(keys);\n\n    this.tableName = name;\n    configureTable(pool, this.tableName, keys)\n      .then(() => {\n        if (this.pending) {\n          this.pending.forEach((f) => f());\n          this.pending = undefined;\n        }\n      })\n      .catch((e) => {\n        process.stderr.write(`Failed to prepare table ${name}: ${e}`);\n      });\n  }\n\n  protected preAct(): void {\n    if (this.stateRef.closed) {\n      throw new Error('Connection closed');\n    }\n  }\n\n  protected async internalAdd({ id, ...rest }: T): Promise<void> {\n    await this.runTableQuery('INSERT', serialiseValue(id), toHStore(rest));\n  }\n\n  protected async internalUpsert(\n    id: T['id'],\n    update: Partial<T>,\n  ): Promise<void> {\n    await this.runTableQuery('UPSERT_ID', serialiseValue(id), toHStore(update));\n  }\n\n  protected async internalUpdate<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n    { id, ...rest }: Partial<T>,\n  ): Promise<void> {\n    const sId = serialiseValue(searchValue);\n    const hstore = toHStore(rest);\n\n    if (searchAttribute === 'id') {\n      await this.runTableQuery('UPDATE_ID', hstore, sId);\n    } else {\n      const r = await this.runTableQuery('UPDATE', hstore, searchAttribute, sId);\n      if (id !== undefined && r.rowCount > 0 && r.rows[0][0] !== id) {\n        throw new Error('Cannot update ID');\n      }\n    }\n  }\n\n  protected async internalGet<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    searchAttribute: K,\n    searchValue: T[K],\n    returnAttributes?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    let raw;\n    if (searchAttribute === 'id') {\n      raw = await this.runTableQuery('SELECT_ID', serialiseValue(searchValue));\n    } else {\n      raw = await this.runTableQuery('SELECT_ONE', searchAttribute, serialiseValue(searchValue));\n    }\n    if (!raw.rowCount) {\n      return null;\n    }\n    return fromHStore<T>(raw.rows[0], returnAttributes);\n  }\n\n  protected async internalGetAll<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    searchAttribute?: K,\n    searchValue?: T[K],\n    returnAttributes?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    let raw;\n    if (!searchAttribute) {\n      raw = await this.runTableQuery('SELECT_ALL');\n    } else if (searchAttribute === 'id') {\n      raw = await this.runTableQuery('SELECT_ID', serialiseValue(searchValue));\n    } else {\n      raw = await this.runTableQuery('SELECT_ALL_BY', searchAttribute, serialiseValue(searchValue));\n    }\n    return raw.rows.map((v) => fromHStore<T>(v, returnAttributes));\n  }\n\n  protected async internalRemove<K extends keyof T & string>(\n    searchAttribute: K,\n    searchValue: T[K],\n  ): Promise<number> {\n    let raw;\n    if (searchAttribute === 'id') {\n      raw = await this.runTableQuery('DELETE_ID', serialiseValue(searchValue));\n    } else {\n      raw = await this.runTableQuery('DELETE', searchAttribute, serialiseValue(searchValue));\n    }\n    return raw.rowCount;\n  }\n\n  private async runTableQuery(\n    queryName: keyof typeof STATEMENTS,\n    ...values: any[]\n  ): Promise<QueryArrayResult<any[]>> {\n    if (this.pending) {\n      await new Promise((resolve): void => {\n        this.pending!.push(resolve);\n      });\n    }\n\n    let cached = this.cachedQueries[queryName];\n    if (!cached) {\n      cached = withIdentifiers(STATEMENTS[queryName], { T: this.tableName });\n      this.cachedQueries[queryName] = cached;\n    }\n\n    return this.pool.query({\n      name: `${this.tableName}_${queryName}`,\n      rowMode: 'array',\n      text: cached,\n      values,\n    });\n  }\n}\n","import PostgresCollection from './PostgresCollection';\nimport DB, { DBKeys } from '../interfaces/DB';\nimport IDable from '../interfaces/IDable';\n\nexport default class PostgresDb implements DB {\n  private readonly stateRef = { closed: false };\n\n  private constructor(\n    private readonly pool: import('pg').Pool,\n  ) {}\n\n  public static async connect(url: string): Promise<PostgresDb> {\n    const { Pool } = await import('pg');\n    const pool = new Pool({ connectionString: url });\n    await pool.query('CREATE EXTENSION IF NOT EXISTS hstore');\n    return new PostgresDb(pool);\n  }\n\n  public getCollection<T extends IDable>(\n    name: string,\n    keys?: DBKeys<T>,\n  ): PostgresCollection<T> {\n    return new PostgresCollection(this.pool, name, keys, this.stateRef);\n  }\n\n  public close(): Promise<void> {\n    if (this.stateRef.closed) {\n      return Promise.resolve();\n    }\n    this.stateRef.closed = true;\n    return this.pool.end();\n  }\n\n  public getConnectionPool(): import('pg').Pool {\n    return this.pool;\n  }\n}\n","import IDable from '../interfaces/IDable';\nimport Collection, { UpdateOptions } from '../interfaces/Collection';\n\nexport type Wrapped<T extends IDable, WF extends keyof T, W> = {\n  [K in keyof T]: K extends 'id' ? T[K] : K extends WF ? W : T[K];\n};\n\nexport interface Wrapper<T extends IDable, K extends keyof T, W, E> {\n  wrap: (\n    key: K,\n    value: T[K],\n    processed: E,\n  ) => Promise<W> | W;\n\n  unwrap: (\n    key: K,\n    value: W,\n    processed: E,\n  ) => Promise<T[K]> | T[K];\n\n  preWrap?: (\n    record: Readonly<Partial<T>>,\n  ) => Promise<E> | E;\n\n  preUnwrap?: (\n    record: Readonly<Partial<Wrapped<T, K, W>>>,\n  ) => Promise<E> | E;\n\n  preRemove?: (\n    record: Readonly<Pick<Wrapped<T, K, W>, 'id'>>,\n  ) => Promise<void> | void;\n}\n\nfunction hasAnyField(value: object, fields: readonly string[]): boolean {\n  return fields\n    .some((field) => Object.prototype.hasOwnProperty.call(value, field));\n}\n\nexport default class WrappedCollection<\n  T extends IDable,\n  WF extends readonly (keyof Omit<T, 'id'> & string)[],\n  W,\n  E,\n  Inner extends Wrapped<T, WF[-1], W> = Wrapped<T, WF[-1], W>\n> implements Collection<T> {\n  public constructor(\n    private readonly baseCollection: Collection<Inner>,\n    private readonly fields: WF,\n    private readonly wrapper: Wrapper<T, WF[-1], W, E>,\n  ) {}\n\n  public async add(entry: T): Promise<void> {\n    return this.baseCollection.add(await this.wrapAll(entry));\n  }\n\n  public async get<\n    K extends keyof T & keyof Inner & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    key: K,\n    value: T[K] & Inner[K],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    if (this.fields.includes(key as any)) {\n      throw new Error('Cannot get by encrypted value');\n    }\n    const raw = await this.baseCollection.get(key, value, fields!);\n    return raw ? this.unwrapAll(raw, { [key]: value }) : null;\n  }\n\n  public async getAll<\n    K extends keyof T & keyof Inner & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    key?: K,\n    value?: T[K] & Inner[NonNullable<K>],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    if (key !== undefined && this.fields.includes(key as any)) {\n      throw new Error('Cannot get by encrypted value');\n    }\n    const raw = await this.baseCollection.getAll(key!, value!, fields!);\n    const extra = (key !== undefined) ? { [key]: value } : undefined;\n    return Promise.all(raw.map((v) => this.unwrapAll(v, extra)));\n  }\n\n  public async update<K extends keyof T & keyof Inner & string>(\n    key: K,\n    value: T[K] & Inner[K],\n    update: Partial<T>,\n    options?: UpdateOptions,\n  ): Promise<void> {\n    if (this.fields.includes(key as any)) {\n      throw new Error('Cannot update by encrypted value');\n    }\n    const converted = await this.wrapAll(update, { [key]: value });\n    return this.baseCollection.update(key, value, converted, options);\n  }\n\n  public async remove<K extends keyof T & string>(\n    key: K,\n    value: T[K] & Inner[K],\n  ): Promise<number> {\n    if (this.fields.includes(key as any)) {\n      throw new Error('Cannot remove by encrypted value');\n    }\n    if (!this.wrapper.preRemove) {\n      return this.baseCollection.remove(key, value);\n    }\n\n    const items = await this.baseCollection.getAll(key, value, ['id']);\n    await Promise.all(items.map(async (item) => {\n      await this.wrapper.preRemove!(item);\n      await this.baseCollection.remove('id', item.id);\n    }));\n    return items.length;\n  }\n\n  private async wrapAll(\n    v: Readonly<T>,\n    extra?: object,\n  ): Promise<Inner>;\n\n  private async wrapAll(\n    v: Readonly<Partial<T>>,\n    extra?: object,\n  ): Promise<Partial<Inner>>;\n\n  private async wrapAll(\n    v: Readonly<Partial<T>>,\n    extra?: object,\n  ): Promise<Partial<Inner>> {\n    let processed: E;\n    if (this.wrapper.preWrap && hasAnyField(v, this.fields)) {\n      const allFields = extra ? { ...extra, ...v } : v;\n      processed = await this.wrapper.preWrap(allFields);\n    }\n    const converted = { ...v } as any;\n    await Promise.all(this.fields.map(async (k) => {\n      if (Object.prototype.hasOwnProperty.call(v, k)) {\n        converted[k] = await this.wrapper.wrap(k, (v as any)[k], processed);\n      }\n    }));\n    return converted;\n  }\n\n  private async unwrapAll(\n    v: Readonly<Inner>,\n    extra?: object,\n  ): Promise<T>;\n\n  private async unwrapAll<K extends keyof T>(\n    v: Readonly<Pick<Inner, K>>,\n    extra?: object,\n  ): Promise<Pick<T, K>>;\n\n  private async unwrapAll<K extends keyof T>(\n    v: Readonly<Pick<Inner, K>>,\n    extra?: object,\n  ): Promise<Pick<T, K>> {\n    let processed: E;\n    if (this.wrapper.preUnwrap && hasAnyField(v, this.fields)) {\n      const allFields = extra ? { ...extra, ...v } : v;\n      processed = await this.wrapper.preUnwrap(allFields as any);\n    }\n    const converted = { ...v } as any;\n    await Promise.all(this.fields.map(async (k) => {\n      if (Object.prototype.hasOwnProperty.call(v, k)) {\n        converted[k] = await this.wrapper.unwrap(k, (v as any)[k], processed);\n      }\n    }));\n    return converted;\n  }\n}\n","export default class LruCache<K, V> {\n  private readonly storage = new Map<K, V>();\n\n  public constructor(\n    private readonly capacity: number,\n  ) {}\n\n  public set(key: K, value: V): void {\n    this.storage.delete(key);\n    this.storage.set(key, value);\n    this.flush();\n  }\n\n  public get(key: K): V | undefined {\n    const value = this.storage.get(key);\n    if (this.storage.delete(key)) {\n      this.storage.set(key, value!);\n    }\n    return value;\n  }\n\n  public remove(key: K): void {\n    this.storage.delete(key);\n  }\n\n  private flush(): void {\n    while (this.storage.size > this.capacity) {\n      this.storage.delete(this.storage.keys().next().value);\n    }\n  }\n}\n","import crypto, { KeyObject } from 'crypto';\nimport Encryption from './Encryption';\n\nconst ALG = 'aes-256-cbc';\nconst ALG_BUF = Buffer.from(`${ALG}:`, 'utf8');\nconst IV_LEN = 16;\n\nconst nodeEncryptionSync: Encryption<Buffer, KeyObject, Buffer> = {\n  encrypt: (key: KeyObject, v: string): Buffer => {\n    const iv = crypto.randomBytes(IV_LEN);\n    const cipher = crypto.createCipheriv(ALG, key, iv);\n    const part = cipher.update(v, 'utf8');\n    const final = cipher.final();\n    return Buffer.concat([ALG_BUF, iv, part, final]);\n  },\n\n  decrypt: (key: KeyObject, v: Buffer): string => {\n    if (!v.slice(0, ALG_BUF.length).equals(ALG_BUF)) {\n      throw new Error('Unknown encryption algorithm');\n    }\n\n    const iv = v.slice(ALG_BUF.length, ALG_BUF.length + IV_LEN);\n    const encrypted = v.slice(ALG_BUF.length + IV_LEN);\n\n    const decipher = crypto.createDecipheriv(ALG, key as any, iv);\n    let decrypted = decipher.update(encrypted, undefined, 'utf8');\n    decrypted += decipher.final('utf8');\n\n    return decrypted;\n  },\n\n  generateKey: (): KeyObject => crypto\n    .createSecretKey(crypto.randomBytes(32)),\n\n  serialiseKey: (key: KeyObject): Buffer => key.export(),\n\n  deserialiseKey: (data: Buffer): KeyObject => crypto.createSecretKey(data),\n};\n\nexport default nodeEncryptionSync;\n","import IDable, { IDableBy, IDType } from '../interfaces/IDable';\nimport Collection from '../interfaces/Collection';\nimport LruCache from '../helpers/LruCache';\nimport { serialiseValue, deserialiseValue } from '../helpers/serialiser';\nimport WrappedCollection, { Wrapped } from './WrappedCollection';\nimport Encryption from './encryption/Encryption';\nimport nodeEncryptionSync from './encryption/nodeEncryptionSync';\n\nexport interface KeyRecord<ID extends IDType, KeyT> {\n  id: ID;\n  key: KeyT;\n}\n\ntype EncryptableKeys<T> = readonly (keyof Omit<T, 'id'> & string)[];\n\ntype Encrypter<EncT, ID extends IDType> = <T extends IDableBy<ID>>(\n) => <F extends EncryptableKeys<T>>(\n  fields: F,\n  baseCollection: Collection<Wrapped<T, F[-1], EncT>>,\n) => Collection<T>;\n\n// makeEncrypter provides optional 2-tier function call due to\n// https://github.com/Microsoft/TypeScript/issues/26242\n\nfunction makeEncrypter<EncT, ID extends IDType>(\n  wrapper: <T extends IDableBy<ID>, F extends EncryptableKeys<T>>(\n    fields: F,\n    baseCollection: Collection<Wrapped<T, F[-1], EncT>>,\n  ) => Collection<T>,\n): Encrypter<EncT, ID> {\n  return (fields?: any, baseCollection?: Collection<any>): any => {\n    if (fields && baseCollection) {\n      // non-typescript API (remove need for extra ())\n      return wrapper(fields, baseCollection) as any;\n    }\n    return wrapper;\n  };\n}\n\nfunction encryptByKey(sKey: Buffer): Encrypter<Buffer, IDType>;\n\nfunction encryptByKey<EncT, KeyT, SerialisedKeyT>(\n  sKey: SerialisedKeyT,\n  cr: Encryption<EncT, KeyT, SerialisedKeyT>,\n): Encrypter<EncT, IDType>;\n\nfunction encryptByKey<EncT, KeyT, SerialisedKeyT>(\n  sKey: SerialisedKeyT,\n  cr: Encryption<EncT, KeyT, SerialisedKeyT> = nodeEncryptionSync as any,\n): Encrypter<EncT, IDType> {\n  const key = cr.deserialiseKey(sKey);\n\n  return makeEncrypter(<T extends IDable, F extends EncryptableKeys<T>>(\n    fields: F,\n    baseCollection: Collection<Wrapped<T, F[-1], EncT>>,\n  ) => new WrappedCollection<T, F, EncT, never>(baseCollection, fields, {\n    wrap: (k, v): Promise<EncT> | EncT => cr.encrypt(key, serialiseValue(v)),\n    unwrap: async (k, v): Promise<any> => deserialiseValue(await cr.decrypt(key, v)),\n  }));\n}\n\nfunction encryptByRecord<ID extends IDType>(\n  keyCollection: Collection<KeyRecord<ID, Buffer>>,\n  cacheSize?: number,\n): Encrypter<Buffer, ID>;\n\nfunction encryptByRecord<ID extends IDType, EncT, KeyT, SerialisedKeyT>(\n  keyCollection: Collection<KeyRecord<ID, SerialisedKeyT>>,\n  cacheSize: number,\n  cr: Encryption<EncT, KeyT, SerialisedKeyT>,\n): Encrypter<EncT, ID>;\n\nfunction encryptByRecord<ID extends IDType, EncT, KeyT, SerialisedKeyT>(\n  keyCollection: Collection<KeyRecord<ID, SerialisedKeyT>>,\n  cacheSize = 0,\n  cr: Encryption<EncT, KeyT, SerialisedKeyT> = nodeEncryptionSync as any,\n): Encrypter<EncT, ID> {\n  const cache = new LruCache<ID, KeyT>(cacheSize);\n\n  const loadKey = async (\n    generateIfNeeded: boolean,\n    record: { id?: ID },\n  ): Promise<KeyT> => {\n    const { id } = record;\n\n    if (id === undefined) {\n      throw new Error('Must provide ID for encryption');\n    }\n\n    const cached = cache.get(id);\n    if (cached) {\n      return cached;\n    }\n    let key: KeyT;\n    const item = await keyCollection.get('id', id, ['key']);\n    if (item) {\n      key = cr.deserialiseKey(item.key);\n    } else {\n      if (!generateIfNeeded) {\n        throw new Error('No encryption key found for record');\n      }\n      key = await cr.generateKey();\n      await keyCollection.add({ id, key: cr.serialiseKey(key) });\n    }\n    cache.set(id, key);\n    return key;\n  };\n\n  const removeKey = async ({ id }: { id: ID }): Promise<void> => {\n    await keyCollection.remove('id', id);\n    cache.remove(id);\n  };\n\n  return makeEncrypter(<T extends IDableBy<ID>, F extends EncryptableKeys<T>>(\n    fields: F,\n    baseCollection: Collection<Wrapped<T, F[-1], EncT>>,\n  ) => new WrappedCollection<T, F, EncT, KeyT>(baseCollection, fields, {\n    wrap: (k, v, key): Promise<EncT> | EncT => cr.encrypt(key, JSON.stringify(v)),\n    unwrap: async (k, v, key): Promise<any> => JSON.parse(await cr.decrypt(key, v)),\n    preWrap: loadKey.bind(null, true),\n    preUnwrap: loadKey.bind(null, false),\n    preRemove: removeKey,\n  }));\n}\n\nfunction encryptByRecordWithMasterKey<ID extends IDType>(\n  sMasterKey: Buffer,\n  keyCollection: Collection<KeyRecord<ID, Buffer>>,\n  cacheSize?: number,\n): Encrypter<Buffer, ID>;\n\nfunction encryptByRecordWithMasterKey<ID extends IDType, EncT, KeyT, SerialisedKeyT>(\n  sMasterKey: SerialisedKeyT,\n  keyCollection: Collection<KeyRecord<ID, EncT>>,\n  cacheSize: number,\n  cr: Encryption<EncT, KeyT, SerialisedKeyT>,\n): Encrypter<EncT, ID>;\n\nfunction encryptByRecordWithMasterKey<ID extends IDType, EncT, KeyT, SerialisedKeyT>(\n  sMasterKey: SerialisedKeyT,\n  keyCollection: Collection<KeyRecord<ID, EncT>>,\n  cacheSize = 0,\n  cr: Encryption<EncT, KeyT, SerialisedKeyT> = nodeEncryptionSync as any,\n): Encrypter<EncT, ID> {\n  const keyEnc = encryptByKey(sMasterKey, cr);\n  const encKeyCollection = keyEnc<KeyRecord<ID, SerialisedKeyT>>()(\n    ['key'],\n    keyCollection,\n  );\n  return encryptByRecord(encKeyCollection, cacheSize, cr);\n}\n\nexport {\n  encryptByKey,\n  encryptByRecord,\n  encryptByRecordWithMasterKey,\n};\n","import CollectionStorage from './CollectionStorage';\nimport WrappedCollection, { Wrapped as TypeWrapped } from './wrappers/WrappedCollection';\nimport TypeEncryption from './wrappers/encryption/Encryption';\nimport {\n  encryptByKey,\n  encryptByRecord,\n  encryptByRecordWithMasterKey,\n} from './wrappers/encrypted';\nimport TypeDB from './interfaces/DB';\nimport TypeCollection from './interfaces/Collection';\nimport IDable from './interfaces/IDable';\n\n// https://github.com/microsoft/TypeScript/issues/34750\nexport type DB = TypeDB;\nexport type Collection<T extends IDable> = TypeCollection<T>;\nexport type Wrapped<T extends IDable, WF extends keyof T, W> =\n  TypeWrapped<T, WF, W>;\nexport type Encrypted<T extends IDable, WF extends keyof T> =\n  TypeWrapped<T, WF, Buffer>;\nexport type Encryption<EncT, KeyT, SerialisedKeyT> =\n  TypeEncryption<EncT, KeyT, SerialisedKeyT>;\n\nexport { default as MemoryDb } from './memory/MemoryDb';\nexport { default as MongoDb } from './mongo/MongoDb';\nexport { default as RedisDb } from './redis/RedisDb';\nexport { default as LruCache } from './helpers/LruCache';\nexport {\n  WrappedCollection,\n  encryptByKey,\n  encryptByRecord,\n  encryptByRecordWithMasterKey,\n};\nexport {\n  default as nodeEncryptionSync,\n} from './wrappers/encryption/nodeEncryptionSync';\nexport default CollectionStorage;\n","import MemoryDb from './memory/MemoryDb';\nimport MongoDb from './mongo/MongoDb';\nimport RedisDb from './redis/RedisDb';\nimport PostgresDb from './postgresql/PostgresDb';\nimport DB from './interfaces/DB';\n\nexport default class CollectionStorage {\n  public static async connect(url: string): Promise<DB> {\n    let dbClass;\n    if (url.startsWith('memory')) {\n      dbClass = MemoryDb;\n    } else if (url.startsWith('mongodb')) {\n      dbClass = MongoDb;\n    } else if (url.startsWith('redis')) {\n      dbClass = RedisDb;\n    } else if (url.startsWith('postgres')) {\n      dbClass = PostgresDb;\n    } else {\n      throw new Error(`Unsupported database connection string: ${url}`);\n    }\n\n    try {\n      return await dbClass.connect(url);\n    } catch (e) {\n      throw new Error(`Failed to connect to database \"${url}\": ${e.message}`);\n    }\n  }\n}\n"],"sourceRoot":""}