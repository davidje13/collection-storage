{"version":3,"sources":["webpack://websocket-express/webpack/universalModuleDefinition","webpack://websocket-express/webpack/bootstrap","webpack://websocket-express/external \"crypto\"","webpack://websocket-express/external \"mongodb\"","webpack://websocket-express/external \"url\"","webpack://websocket-express/external \"ioredis\"","webpack://websocket-express/./src/helpers/serialiser.ts","webpack://websocket-express/./src/memory/MemoryCollection.ts","webpack://websocket-express/./src/memory/MemoryDb.ts","webpack://websocket-express/./src/helpers/retry.ts","webpack://websocket-express/./src/mongo/MongoCollection.ts","webpack://websocket-express/./src/mongo/MongoDb.ts","webpack://websocket-express/./src/redis/helpers.ts","webpack://websocket-express/./src/redis/RedisCollection.ts","webpack://websocket-express/./src/redis/scripts.ts","webpack://websocket-express/./src/redis/RedisConnectionPool.ts","webpack://websocket-express/./src/redis/RedisDb.ts","webpack://websocket-express/./src/wrappers/WrappedCollection.ts","webpack://websocket-express/./src/helpers/LruCache.ts","webpack://websocket-express/./src/wrappers/encryption/nodeEncryptionSync.ts","webpack://websocket-express/./src/wrappers/encrypted.ts","webpack://websocket-express/./src/index.ts","webpack://websocket-express/./src/CollectionStorage.ts"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","serialiseValue","Buffer","toString","JSON","stringify","deserialiseValue","type","data","substr","from","parse","Error","serialiseRecord","record","result","keys","forEach","k","deserialiseRecord","v","MemoryCollection","constructor","simulatedLatency","stateRef","closed","this","Map","map","options","simulateDbConnection","serialised","internalCheckDuplicates","set","id","internalPopulateIndices","keyName","upsert","undefined","sId","internalGetSerialisedIds","assign","oldSerialised","oldValue","newValue","newSerialised","internalRemoveIndices","e","fields","all","getAll","length","sIds","field","applyFilter","delete","millis","Promise","resolve","setTimeout","sKey","has","keyInfo","serialisedValue","checkId","entries","unique","Set","add","size","globalDbs","initial","existing","getGlobal","MemoryDb","url","parsedUrl","URL","hostname","params","searchParams","Number","db","getCollection","mapTables","close","sleep","shouldRetry","maxAttempts","baseDelayMillis","attemptDelayMillis","randomDelayMillis","async","attempt","fn","message","Math","random","MONGO_ID","ID","DOT_REG","fieldNameToMongo","encodeURIComponent","replace","withUpsertRetry","retry","includes","convertToMongo","converted","MBinary","_bsontype","convertFromMongo","buffer","decodeURIComponent","fieldNameFromMongo","makeMongoFields","names","fieldName","MongoCollection","collection","mongoKey","createIndex","insertOne","checkIndexExists","updateOne","$set","findOne","projection","cursor","mFields","find","raw","push","deleteMany","deletedCount","MongoDb","client","MongoClient","connect","useNewUrlParser","useUnifiedTopology","escapeName","getDb","minifyLuaScript","lines","argNames","combined","ln","trim","join","RegExp","makeIndexKeys","partialSerialisedValue","filter","prefix","parseItem","item","f","itemHasContent","values","some","unwatchAll","unwatch","RedisCollection","pool","keyPrefix","keyPrefixes","uniqueKeys","nonUniqueKeys","withConnection","internalAdd","update","patchSerialised","retryWithConnection","getAndWatchBySerialisedKey","rKey","makeKey","watch","rawByKeyKeepWatches","diff","flat","patchUniqueKeys","patchNonUniqueKeys","oldUniqueKeys","oldNonUniqueKeys","keyCount","updated","multi","exec","getByKeysKeepWatches","cut","remove","indexedKeys","items","pipeline","serialisedId","checkWatch","Boolean","serialisedIds","results","commands","multiExec","exists","hmget","hgetall","parsed","keyAddress","smembers","SCRIPT_ADD_ITEM","SCRIPT_UPDATE_ITEM","SCRIPT_REMOVE_ITEM","withRetry","RedisConnectionPool","RedisStatic","maxConnections","teardown","getConnection","returnConnection","inUse","doClose","closingFn","connections","disconnect","pop","defineCommand","lua","defineAllScripts","queue","q","shift","RedisDb","default","lazyConnect","getConnectionPool","hasAnyField","WrappedCollection","baseCollection","wrapper","entry","wrapAll","unwrapAll","extra","preRemove","processed","preWrap","allFields","wrap","preUnwrap","unwrap","LruCache","capacity","storage","flush","next","ALG","ALG_BUF","nodeEncryptionSync","encrypt","iv","crypto","randomBytes","cipher","createCipheriv","part","final","concat","decrypt","slice","equals","encrypted","decipher","createDecipheriv","decrypted","generateKey","createSecretKey","serialiseKey","export","deserialiseKey","makeEncrypter","encryptByKey","cr","encryptByRecord","keyCollection","cacheSize","cache","loadKey","generateIfNeeded","cached","removeKey","encryptByRecordWithMasterKey","sMasterKey","keyEnc","CollectionStorage","dbClass","startsWith"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"websocket-express\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"websocket-express\"] = factory();\n\telse\n\t\troot[\"websocket-express\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","module.exports = require(\"crypto\");","module.exports = require(\"mongodb\");","module.exports = require(\"url\");","module.exports = require(\"ioredis\");","export function serialiseValue(\n  value: unknown,\n): string {\n  if (value instanceof Buffer) {\n    return `B${value.toString('base64')}`;\n  }\n  return `J${JSON.stringify(value)}`;\n}\n\nexport function deserialiseValue(\n  value: string,\n): unknown {\n  const type = value[0];\n  const data = value.substr(1);\n  if (type === 'B') {\n    return Buffer.from(data, 'base64');\n  }\n  if (type === 'J') {\n    return JSON.parse(data);\n  }\n  throw new Error(`Unknown data type ${type}`);\n}\n\nexport function serialiseRecord<T>(\n  record: T,\n): Record<string, string> {\n  const result: Record<string, string> = {};\n  Object.keys(record).forEach((k) => {\n    result[k] = serialiseValue((record as any)[k]);\n  });\n  return result;\n}\n\nexport function deserialiseRecord(\n  record: Record<string, string | null>,\n): Record<string, unknown> {\n  const result: Record<string, any> = {};\n  Object.keys(record).forEach((k) => {\n    const v = record[k];\n    if (v) {\n      result[k] = deserialiseValue(v);\n    }\n  });\n  return result;\n}\n","import Collection, { KeyOptions } from '../interfaces/Collection';\nimport IDable from '../interfaces/IDable';\nimport { DBKeys } from '../interfaces/DB';\nimport {\n  serialiseValue,\n  serialiseRecord,\n  deserialiseRecord,\n} from '../helpers/serialiser';\n\nfunction sleep(millis: number): Promise<void> | null {\n  if (!millis) {\n    return null;\n  }\n\n  // Simulate data access delays to ensure non-flakey e2e tests, etc.\n  return new Promise((resolve): any => setTimeout(resolve, millis));\n}\n\nfunction applyFilter<T, F extends readonly (keyof T)[]>(\n  data: T,\n  fields?: F,\n): Pick<T, F[-1]> {\n  if (!fields) {\n    return data;\n  }\n  const result: Pick<T, F[-1]> = {} as any;\n  fields.forEach((field) => {\n    result[field] = data[field];\n  });\n  return result;\n}\n\ninterface KeyInfo {\n  map: Map<string, Set<string>>;\n  options: KeyOptions;\n}\n\ninterface State {\n  closed: boolean;\n}\n\nexport default class MemoryCollection<T extends IDable> implements Collection<T> {\n  private readonly data: Map<string, Record<string, string>>;\n\n  private readonly keys: { [K in keyof T]?: KeyInfo } = {};\n\n  public constructor(\n    keys: DBKeys<T> = {},\n    private readonly simulatedLatency = 0,\n    private readonly stateRef: State = { closed: false },\n  ) {\n    this.data = new Map();\n\n    Object.keys(keys).forEach((k) => {\n      const key = k as keyof DBKeys<T>;\n      this.keys[key] = { map: new Map(), options: keys[key]! };\n    });\n  }\n\n  public async add(value: T): Promise<void> {\n    await this.simulateDbConnection();\n\n    const serialised = serialiseRecord(value);\n    this.internalCheckDuplicates(serialised, true);\n    this.data.set(serialised.id, serialised);\n    this.internalPopulateIndices(serialised);\n  }\n\n  public async update<K extends keyof T & string>(\n    keyName: K,\n    key: T[K],\n    value: Partial<T>,\n    { upsert = false } = {},\n  ): Promise<void> {\n    if (upsert && keyName !== 'id' && value.id === undefined) {\n      throw new Error('Cannot upsert without ID');\n    }\n\n    await this.simulateDbConnection();\n\n    const sId = this.internalGetSerialisedIds(keyName, key)[0];\n    if (sId === undefined) {\n      if (upsert) {\n        const fullValue = Object.assign({ [keyName]: key }, value as T);\n        const serialised = serialiseRecord(fullValue);\n        this.internalCheckDuplicates(serialised, true);\n        this.data.set(serialised.id, serialised);\n        this.internalPopulateIndices(serialised);\n      }\n      return;\n    }\n    const oldSerialised = this.data.get(sId)!;\n    const oldValue = deserialiseRecord(oldSerialised) as T;\n    const newValue = Object.assign({}, oldValue, value);\n    if (newValue.id !== oldValue.id) {\n      throw new Error('Cannot update id');\n    }\n    const newSerialised = serialiseRecord(newValue);\n    this.internalRemoveIndices(oldSerialised);\n    try {\n      this.internalCheckDuplicates(newSerialised, false);\n    } catch (e) {\n      this.internalPopulateIndices(oldSerialised);\n      throw e;\n    }\n    this.data.set(newSerialised.id, newSerialised);\n    this.internalPopulateIndices(newSerialised);\n  }\n\n  public async get<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    keyName: K,\n    key: T[K],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    const all = await this.getAll(keyName, key, fields);\n    if (!all.length) {\n      return null;\n    }\n    return all[0];\n  }\n\n  public async getAll<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    keyName?: K,\n    key?: T[K],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    await this.simulateDbConnection();\n\n    let sIds: string[];\n    if (keyName) {\n      sIds = this.internalGetSerialisedIds(keyName, key!);\n    } else {\n      sIds = [...this.data.keys()];\n    }\n    return sIds.map((sId) => applyFilter(\n      deserialiseRecord(this.data.get(sId)!) as T,\n      fields,\n    ));\n  }\n\n  public async remove<K extends keyof T & string>(\n    key: K,\n    value: T[K],\n  ): Promise<number> {\n    await this.simulateDbConnection();\n\n    const sIds = this.internalGetSerialisedIds(key, value);\n    sIds.forEach((sId) => {\n      const oldSerialised = this.data.get(sId)!;\n      this.internalRemoveIndices(oldSerialised);\n      this.data.delete(sId);\n    });\n\n    return sIds.length;\n  }\n\n  private async simulateDbConnection(): Promise<void> {\n    if (this.stateRef.closed) {\n      throw new Error('Connection closed');\n    }\n    await sleep(this.simulatedLatency);\n  }\n\n  private internalGetSerialisedIds<K extends keyof T>(\n    keyName: K,\n    key: T[K],\n  ): string[] {\n    const sKey = serialiseValue(key);\n    if (keyName === 'id') {\n      return this.data.has(sKey) ? [sKey] : [];\n    }\n    const keyInfo = this.keys[keyName];\n    if (!keyInfo) {\n      throw new Error(`Requested key ${keyName} not indexed`);\n    }\n    const sIds = keyInfo.map.get(sKey);\n    return sIds ? [...sIds] : []; // convert set to array\n  }\n\n  private internalCheckDuplicates(\n    serialisedValue: Record<string, string>,\n    checkId: boolean,\n  ): void {\n    if (checkId && this.data.has(serialisedValue.id)) {\n      throw new Error('duplicate');\n    }\n    Object.entries(this.keys).forEach(([key, keyInfo]) => {\n      const { map, options } = keyInfo!;\n      if (options.unique && map.has(serialisedValue[key])) {\n        throw new Error('duplicate');\n      }\n    });\n  }\n\n  private internalPopulateIndices(\n    serialisedValue: Record<string, string>,\n  ): void {\n    Object.entries(this.keys).forEach(([key, keyInfo]) => {\n      const { map } = keyInfo!;\n      const v = serialisedValue[key];\n      let o = map.get(v);\n      if (!o) {\n        o = new Set<string>();\n        map.set(v, o);\n      }\n      o.add(serialisedValue.id);\n    });\n  }\n\n  private internalRemoveIndices(\n    serialisedValue: Record<string, string>,\n  ): void {\n    Object.entries(this.keys).forEach(([key, keyInfo]) => {\n      const { map } = keyInfo!;\n      const v = serialisedValue[key];\n      const o = map.get(v)!;\n      o.delete(serialisedValue.id);\n      if (!o.size) {\n        map.delete(v);\n      }\n    });\n  }\n}\n","import { URL } from 'url';\nimport MemoryCollection from './MemoryCollection';\nimport DB, { DBKeys } from '../interfaces/DB';\nimport IDable from '../interfaces/IDable';\n\nfunction getGlobal<T>(name: string, initial: T): T {\n  const existing = (global as any)[name];\n  if (existing) {\n    return existing;\n  }\n\n  (global as any)[name] = initial;\n  return initial;\n}\n\nconst globalDbs = getGlobal(\n  'collectionStorageInMemory',\n  new Map<string, MemoryDb>(),\n);\n\nexport default class MemoryDb implements DB {\n  private readonly simulatedLatency: number;\n\n  private readonly mapTables = new Map<string, MemoryCollection<any>>();\n\n  private readonly stateRef = { closed: false };\n\n  public constructor({ simulatedLatency = 0 } = {}) {\n    this.simulatedLatency = simulatedLatency;\n  }\n\n  public static connect(url: string): MemoryDb {\n    const parsedUrl = new URL(url);\n    const name = parsedUrl.hostname;\n    if (name && globalDbs.has(name)) {\n      return globalDbs.get(name)!;\n    }\n    const params = parsedUrl.searchParams;\n    const simulatedLatency = Number(params.get('simulatedLatency'));\n    const db = new MemoryDb({ simulatedLatency });\n    if (name) {\n      globalDbs.set(name, db);\n    }\n    return db;\n  }\n\n  public getCollection<T extends IDable>(\n    name: string,\n    keys?: DBKeys<T>,\n  ): MemoryCollection<T> {\n    if (!this.mapTables.has(name)) {\n      this.mapTables.set(name, new MemoryCollection(\n        keys,\n        this.simulatedLatency,\n        this.stateRef,\n      ));\n    }\n    return this.mapTables.get(name)! as MemoryCollection<T>;\n  }\n\n  public close(): void {\n    this.stateRef.closed = true;\n  }\n}\n","function sleep(millis: number): Promise<void> | null {\n  return new Promise((resolve): any => setTimeout(resolve, millis));\n}\n\nexport default (\n  shouldRetry: (e: any) => boolean,\n  maxAttempts = 5,\n  baseDelayMillis = 20,\n  attemptDelayMillis = 200,\n  randomDelayMillis = 200,\n) => async <T>(fn: () => Promise<T> | T): Promise<T> => {\n  for (let attempt = 1; ; attempt += 1) {\n    try {\n      // eslint-disable-next-line no-await-in-loop\n      return await fn();\n    } catch (e) {\n      if (!shouldRetry(e)) {\n        throw e;\n      }\n      if (attempt >= maxAttempts) {\n        e.message += ` (attempted ${attempt} times)`;\n        throw e;\n      }\n    }\n    // eslint-disable-next-line no-await-in-loop\n    await sleep(\n      baseDelayMillis +\n      attempt * attemptDelayMillis +\n      Math.random() * randomDelayMillis,\n    );\n  }\n};\n","import {\n  Collection as MCollection,\n  Cursor as MCursor,\n  Binary as MBinary,\n} from 'mongodb';\nimport IDable from '../interfaces/IDable';\nimport Collection from '../interfaces/Collection';\nimport { DBKeys } from '../interfaces/DB';\nimport retry from '../helpers/retry';\n\nconst MONGO_ID = '_id';\nconst ID = 'id';\n\ninterface State {\n  closed: boolean;\n}\n\nconst DOT_REG = /\\./g;\nfunction fieldNameToMongo(name: string): string {\n  if (name === ID) {\n    return MONGO_ID;\n  }\n  return encodeURIComponent(name).replace(DOT_REG, '%2E');\n}\n\nfunction fieldNameFromMongo(name: string): string {\n  if (name === MONGO_ID) {\n    return ID;\n  }\n  return decodeURIComponent(name);\n}\n\nconst withUpsertRetry = retry((e) => (\n  typeof e === 'object' &&\n  e.message.includes('E11000')\n));\n\nfunction convertToMongo<T extends Partial<IDable>>(\n  value: T,\n): Record<string, unknown> {\n  const converted: Record<string, unknown> = {};\n  Object.keys(value).forEach((k) => {\n    let v = (value as any)[k];\n    if (v instanceof Buffer) {\n      v = new MBinary(v);\n      // eslint-disable-next-line no-underscore-dangle\n    } else if (typeof v === 'object' && v._bsontype) {\n      throw new Error('Must use Buffer to provide binary data');\n    }\n    converted[fieldNameToMongo(k)] = v;\n  });\n  return converted;\n}\n\nfunction convertFromMongo<T extends Partial<IDable>>(\n  value: Record<string, unknown> | null,\n): T | null {\n  if (!value) {\n    return null;\n  }\n  const converted: T = {} as any;\n  Object.keys(value).forEach((k) => {\n    let v = (value as any)[k];\n    // eslint-disable-next-line no-underscore-dangle\n    if (typeof v === 'object' && v._bsontype === 'Binary') {\n      v = v.buffer;\n    }\n    (converted as any)[fieldNameFromMongo(k)] = v;\n  });\n  return converted;\n}\n\nfunction makeMongoFields(names?: readonly string[]): Record<string, boolean> {\n  const fields: Record<string, boolean> = {};\n  if (names) {\n    fields[MONGO_ID] = false;\n    names.forEach((fieldName) => {\n      fields[fieldNameToMongo(fieldName)] = true;\n    });\n  }\n  return fields;\n}\n\nexport default class MongoCollection<T extends IDable> implements Collection<T> {\n  public constructor(\n    private readonly collection: MCollection,\n    private readonly keys: DBKeys<T> = {},\n    private readonly stateRef: State = { closed: false },\n  ) {\n    Object.keys(keys).forEach((k) => {\n      const keyName = k as keyof DBKeys<T>;\n      const options = keys[keyName];\n      const mongoKey = fieldNameToMongo(keyName);\n      if (options && options.unique) {\n        collection.createIndex({ [mongoKey]: 1 }, { unique: true });\n      } else {\n        collection.createIndex({ [mongoKey]: 'hashed' });\n      }\n    });\n  }\n\n  public async add(value: T): Promise<void> {\n    await this.getCollection().insertOne(convertToMongo(value));\n  }\n\n  public async update<K extends keyof T & string>(\n    keyName: K,\n    key: T[K],\n    value: Partial<T>,\n    { upsert = false } = {},\n  ): Promise<void> {\n    if (upsert && keyName !== 'id' && value.id === undefined) {\n      throw new Error('Cannot upsert without ID');\n    }\n\n    this.checkIndexExists(keyName);\n\n    if (upsert) {\n      // special handling due to https://jira.mongodb.org/browse/SERVER-14322\n      await withUpsertRetry(() => this.getCollection().updateOne(\n        convertToMongo({ [keyName]: key }),\n        { $set: convertToMongo(value) },\n        { upsert: true },\n      ));\n    } else {\n      await this.getCollection().updateOne(\n        convertToMongo({ [keyName]: key }),\n        { $set: convertToMongo(value) },\n      );\n    }\n  }\n\n  public async get<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    keyName: K,\n    key: T[K],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    this.checkIndexExists(keyName);\n\n    const raw = await this.getCollection().findOne(\n      convertToMongo({ [keyName]: key }),\n      { projection: makeMongoFields(fields) },\n    );\n    return convertFromMongo<T>(raw);\n  }\n\n  public async getAll<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    keyName?: K,\n    key?: T[K],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    const result: Pick<T, F[-1]>[] = [];\n\n    let cursor: MCursor;\n    const mFields = makeMongoFields(fields);\n    if (keyName) {\n      this.checkIndexExists(keyName);\n\n      cursor = this.getCollection().find(\n        convertToMongo({ [keyName]: key }),\n        { projection: mFields },\n      );\n    } else {\n      cursor = this.getCollection().find({}, { projection: mFields });\n    }\n    await cursor.forEach((raw) => result.push(convertFromMongo<T>(raw)!));\n\n    return result;\n  }\n\n  public async remove<K extends keyof T & string>(\n    key: K,\n    value: T[K],\n  ): Promise<number> {\n    this.checkIndexExists(key);\n\n    const result = await this.getCollection().deleteMany(\n      convertToMongo({ [key]: value }),\n    );\n    return result.deletedCount || 0;\n  }\n\n  private checkIndexExists(key: string): void {\n    if (key !== 'id' && !(this.keys as any)[key]) {\n      throw new Error(`No index for ${key}`);\n    }\n  }\n\n  private getCollection(): MCollection {\n    if (this.stateRef.closed) {\n      throw new Error('Connection closed');\n    }\n    return this.collection;\n  }\n}\n","import { MongoClient as MClient, Db as MDb } from 'mongodb';\nimport MongoCollection from './MongoCollection';\nimport DB, { DBKeys } from '../interfaces/DB';\nimport IDable from '../interfaces/IDable';\n\nfunction escapeName(name: string): string {\n  return encodeURIComponent(name);\n}\n\nexport default class MongoDb implements DB {\n  private readonly stateRef = { closed: false };\n\n  private constructor(\n    private readonly client: MClient,\n  ) {}\n\n  public static async connect(url: string): Promise<MongoDb> {\n    const { MongoClient } = await import('mongodb');\n    const client = await MongoClient.connect(url, {\n      useNewUrlParser: true,\n      useUnifiedTopology: true,\n    });\n    return new MongoDb(client);\n  }\n\n  public getCollection<T extends IDable>(\n    name: string,\n    keys?: DBKeys<T>,\n  ): MongoCollection<T> {\n    const collection = this.client.db().collection(escapeName(name));\n    return new MongoCollection(collection, keys, this.stateRef);\n  }\n\n  public async close(): Promise<void> {\n    this.stateRef.closed = true;\n    return this.client.close();\n  }\n\n  public getDb(): MDb {\n    return this.client.db();\n  }\n}\n","import { Redis, Pipeline, MultiOptions } from 'ioredis';\n\n// Thanks, https://stackoverflow.com/a/50014868/1180785\ntype ArgumentTypes<T> = T extends (...args: infer U) => any ? U: never;\n\ntype PipelineVersions<I> = {\n  [K in keyof I]: (...args: ArgumentTypes<I[K]>) => Pipeline & PipelineVersions<I>;\n};\n\ninterface RedisWithExtendedPipeline<I> extends Redis {\n  multi(commands?: string[][], options?: MultiOptions): Pipeline & PipelineVersions<I>;\n  multi(options: { pipeline: false }): Promise<string>;\n}\n\nexport type ExtendedRedis<I> = I & RedisWithExtendedPipeline<I>;\n\nexport async function multiExec(\n  client: Redis,\n  commands: string[][],\n): Promise<[unknown, any][] | null> {\n  if (!commands.length) {\n    return [];\n  }\n  return client.multi(commands).exec();\n}\n\nexport function minifyLuaScript(\n  lines: string[],\n  ...argNames: string[]\n): string {\n  let combined = lines.map((ln) => ln.trim()).join(' ');\n  argNames.forEach((name, i) => {\n    combined = combined.replace(new RegExp(`\\\\$${name}\\\\b`, 'g'), `ARGV[${i + 1}]`);\n  });\n  return combined;\n}\n","import IDable from '../interfaces/IDable';\nimport Collection from '../interfaces/Collection';\nimport { DBKeys } from '../interfaces/DB';\nimport {\n  serialiseValue,\n  serialiseRecord,\n  deserialiseRecord,\n} from '../helpers/serialiser';\nimport RedisConnectionPool from './RedisConnectionPool';\nimport { multiExec } from './helpers';\nimport { ERedis } from './scripts';\n\ninterface Key<T> {\n  key: keyof T & string;\n  prefix: string;\n}\n\nfunction makeIndexKeys(\n  keys: Key<any>[],\n  partialSerialisedValue: Record<string, string | null>,\n): string[] {\n  return keys\n    .filter(({ key }) => partialSerialisedValue[key])\n    .map(({ key, prefix }) => `${prefix}:${partialSerialisedValue[key]}`);\n}\n\nfunction parseItem(\n  item: (string | null)[] | Record<string, string | null>,\n  fields?: readonly string[],\n): Record<string, string | null> {\n  if (!fields) {\n    return item as any;\n  }\n  const result: Record<string, string | null> = {};\n  for (let f = 0; f < fields.length; f += 1) {\n    result[fields[f]] = (item as any)[f];\n  }\n  return result;\n}\n\nfunction itemHasContent(item: Record<string, string | null>): boolean {\n  return Object.values(item).some((v) => (v !== null));\n}\n\nasync function unwatchAll(client: ERedis): Promise<void> {\n  await client.unwatch();\n}\n\nexport default class RedisCollection<T extends IDable> implements Collection<T> {\n  private readonly keyPrefixes: { [K in keyof T]?: string } = {};\n\n  private readonly keys: Key<T>[] = [];\n\n  private readonly uniqueKeys: Key<T>[] = [];\n\n  private readonly nonUniqueKeys: Key<T>[] = [];\n\n  public constructor(\n    private readonly pool: RedisConnectionPool,\n    private readonly prefix: string,\n    keys: DBKeys<T> = {},\n  ) {\n    Object.keys(keys).forEach((k) => {\n      const key = k as keyof DBKeys<T>;\n      const keyPrefix = `${prefix}-${key}`;\n      this.keyPrefixes[key] = keyPrefix;\n      const keyInfo = { key, prefix: keyPrefix };\n      this.keys.push(keyInfo);\n      if (keys[key]!.unique) {\n        this.uniqueKeys.push(keyInfo);\n      } else {\n        this.nonUniqueKeys.push(keyInfo);\n      }\n    });\n  }\n\n  public add(value: T): Promise<void> {\n    const serialised = serialiseRecord(value);\n    return this.pool.withConnection(async (client) => {\n      const added = await this.internalAdd(client, serialised, false);\n      if (!added) {\n        throw new Error('duplicate');\n      }\n    });\n  }\n\n  public update<K extends keyof T & string>(\n    keyName: K,\n    key: T[K],\n    value: Partial<T>,\n    { upsert = false } = {},\n  ): Promise<void> {\n    const { id, ...patchSerialised } = serialiseRecord(value);\n    const sKey = serialiseValue(key);\n    if (upsert && keyName !== 'id' && !id) {\n      throw new Error('Cannot upsert without ID');\n    }\n\n    return this.pool.retryWithConnection(async (client) => {\n      const sId = (await this.getAndWatchBySerialisedKey(client, keyName, sKey))[0];\n      if (sId) {\n        if (id && id !== sId) {\n          throw new Error('Cannot update id');\n        }\n      } else if (!upsert) {\n        return;\n      }\n      const rKey = this.makeKey(sId || id);\n      await client.watch(rKey);\n      const oldSerialised = sId && await this.rawByKeyKeepWatches(\n        client,\n        sId,\n        this.keys.map((k) => k.key).filter((k) => patchSerialised[k]),\n      );\n      if (!oldSerialised) {\n        if (upsert) {\n          await this.internalAdd(\n            client,\n            { id, [keyName]: sKey, ...patchSerialised },\n            true,\n          );\n        }\n        return;\n      }\n      Object.keys(patchSerialised).forEach((k) => {\n        if (oldSerialised[k] === patchSerialised[k]) {\n          delete patchSerialised[k];\n          delete oldSerialised[k];\n        }\n      });\n      const diff = Object.entries(patchSerialised).flat();\n      if (!diff.length) {\n        return; // nothing changed\n      }\n      const patchUniqueKeys = makeIndexKeys(this.uniqueKeys, patchSerialised);\n      const patchNonUniqueKeys = makeIndexKeys(this.nonUniqueKeys, patchSerialised);\n      const oldUniqueKeys = makeIndexKeys(this.uniqueKeys, oldSerialised);\n      const oldNonUniqueKeys = makeIndexKeys(this.nonUniqueKeys, oldSerialised);\n      if (\n        oldUniqueKeys.length !== patchUniqueKeys.length ||\n        oldNonUniqueKeys.length !== patchNonUniqueKeys.length\n      ) {\n        throw new Error('unexpected key mismatch with old value');\n      }\n      const keyCount = 1 + (patchUniqueKeys.length + patchNonUniqueKeys.length) * 2;\n      const params = [\n        rKey,\n        ...patchUniqueKeys,\n        ...patchNonUniqueKeys,\n        ...oldUniqueKeys,\n        ...oldNonUniqueKeys,\n        patchUniqueKeys.length,\n        patchUniqueKeys.length + patchNonUniqueKeys.length,\n        sId,\n        ...diff,\n      ];\n      const updated = await client\n        .multi()\n        .update(keyCount, params)\n        .exec();\n      if (!updated) {\n        throw new Error('transient error');\n      }\n      if (!updated[0][1]) {\n        throw new Error('duplicate');\n      }\n    }, unwatchAll);\n  }\n\n  public get<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    keyName: K,\n    key: T[K],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    const sKey = serialiseValue(key);\n    return this.pool.retryWithConnection(async (client) => {\n      const sId = (await this.getAndWatchBySerialisedKey(client, keyName, sKey))[0];\n      if (sId === undefined) {\n        return null;\n      }\n      const results = await this.getByKeysKeepWatches(client, [sId], fields);\n      return results[0] || null;\n    }, unwatchAll);\n  }\n\n  public getAll<\n    K extends keyof T & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    keyName?: K,\n    key?: T[K],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    return this.pool.retryWithConnection(async (client) => {\n      let sIds: string[];\n      if (keyName) {\n        const sKey = serialiseValue(key);\n        sIds = await this.getAndWatchBySerialisedKey(client, keyName, sKey);\n      } else {\n        sIds = await client.keys(this.makeKey('*'));\n        const cut = this.prefix.length + 1;\n        sIds = sIds.map((v) => v.substr(cut));\n      }\n      return this.getByKeysKeepWatches(client, sIds, fields);\n    }, unwatchAll);\n  }\n\n  public remove<K extends keyof T & string>(\n    key: K,\n    value: T[K],\n  ): Promise<number> {\n    const sKey = serialiseValue(value);\n    const indexedKeys = this.keys.map((k) => k.key);\n    indexedKeys.push('id');\n\n    return this.pool.retryWithConnection(async (client) => {\n      const sIds = await this.getAndWatchBySerialisedKey(client, key, sKey);\n      const items = (await Promise.all(\n        sIds.map((sId) => this.rawByKeyKeepWatches(client, sId, indexedKeys)),\n      )).filter(<T>(item?: T): item is T => (item !== undefined));\n\n      if (items.length === 0) {\n        return 0;\n      }\n\n      const pipeline = client.multi();\n      items.forEach((item) => {\n        const keys = makeIndexKeys(this.keys, item);\n        pipeline.remove(\n          1 + keys.length,\n          this.makeKey(item.id!),\n          ...keys,\n          item.id!,\n        );\n      });\n      await pipeline.exec();\n      return items.length;\n    }, unwatchAll);\n  }\n\n  private makeKey(serialisedId: string): string {\n    return `${this.prefix}:${serialisedId}`;\n  }\n\n  private async internalAdd(\n    client: ERedis,\n    { id, ...serialised }: Record<string, string>,\n    checkWatch: boolean,\n  ): Promise<boolean> {\n    const uniqueKeys = makeIndexKeys(this.uniqueKeys, serialised);\n    const nonUniqueKeys = makeIndexKeys(this.nonUniqueKeys, serialised);\n\n    const keyCount = 1 + uniqueKeys.length + nonUniqueKeys.length;\n    const params = [\n      this.makeKey(id),\n      ...uniqueKeys,\n      ...nonUniqueKeys,\n      uniqueKeys.length,\n      'id', // ID is always first in flattened key/value pairs\n      id,\n      ...Object.entries(serialised).flat(),\n    ];\n\n    if (!checkWatch) {\n      return Boolean(await client.add(keyCount, ...params));\n    }\n\n    const result = await client\n      .multi()\n      .add(keyCount, ...params)\n      .exec();\n    if (!result) {\n      throw new Error('transient error');\n    }\n    return Boolean(result[0][1]);\n  }\n\n  private async getByKeysKeepWatches<F extends readonly (keyof T & string)[]>(\n    client: ERedis,\n    serialisedIds: string[],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    const results = await multiExec(\n      client,\n      serialisedIds\n        .map((sId) => this.makeKey(sId))\n        .map((k) => (fields ? ['hmget', k, ...fields] : ['hgetall', k])),\n    );\n    if (!results) {\n      throw new Error('transient error');\n    }\n    return results\n      .map(([, item]: [unknown, any]) => parseItem(item, fields))\n      .filter(itemHasContent)\n      .map(deserialiseRecord) as T[];\n  }\n\n  private async rawByKeyKeepWatches(\n    client: ERedis,\n    serialisedId: string,\n    fields?: readonly (keyof T & string)[],\n  ): Promise<Record<string, string | null> | undefined> {\n    const key = this.makeKey(serialisedId);\n    let item;\n    if (fields) {\n      if (!fields.length) {\n        // just check existence\n        const exists = await client.exists(key);\n        return exists ? {} : undefined;\n      }\n      item = await client.hmget(key, ...fields);\n    } else {\n      item = await client.hgetall(key);\n    }\n    const parsed = parseItem(item, fields);\n    return itemHasContent(parsed) ? parsed : undefined;\n  }\n\n  private async getAndWatchBySerialisedKey(\n    client: ERedis,\n    keyName: keyof T,\n    serialisedValue: string,\n  ): Promise<string[]> {\n    if (keyName === 'id') {\n      return [serialisedValue];\n    }\n    const keyPrefix = this.keyPrefixes[keyName];\n    if (!keyPrefix) {\n      throw new Error(`Requested key ${keyName} not indexed`);\n    }\n    const keyAddress = `${keyPrefix}:${serialisedValue}`;\n    await client.watch(keyAddress);\n    return client.smembers(keyAddress);\n  }\n}\n","import { Redis } from 'ioredis';\nimport { minifyLuaScript, ExtendedRedis } from './helpers';\n\nexport interface ScriptExtensions {\n  add(keyCount: number, ...keysAndArgs: any[]): Promise<number>;\n  update(keyCount: number, ...keysAndArgs: any[]): Promise<number>;\n  remove(keyCount: number, ...keysAndArgs: any[]): Promise<void>;\n}\n\nexport type ERedis = ExtendedRedis<ScriptExtensions>;\n\n// KEYS = [id, ...uniqueKeys, ...nonUniqueKeys]\nconst SCRIPT_ADD_ITEM = minifyLuaScript([\n  'if redis.call(\"exists\",KEYS[1])==1 then',\n  '  return 0',\n  'end',\n  'for k=2,1+tonumber($uniqueKeyCount) do',\n  '  if redis.call(\"exists\",KEYS[k])==1 then',\n  '    return 0',\n  '  end',\n  'end',\n  'redis.call(\"hset\",KEYS[1],unpack(ARGV, 2))',\n  'for k=2,#KEYS do',\n  '  redis.call(\"sadd\",KEYS[k],ARGV[3])',\n  'end',\n  'return 1',\n], 'uniqueKeyCount');\n\n// KEYS = [id, ...patchUniqueKeys, ...patchNonUniqueKeys, ...oldUniqueKeys, ...oldNonUniqueKeys]\nconst SCRIPT_UPDATE_ITEM = minifyLuaScript([\n  'local tkc=tonumber($totalKeyCount)',\n  'for k=2,1+tonumber($uniqueKeyCount) do',\n  '  if redis.call(\"exists\",KEYS[k])==1 then',\n  '    return 0',\n  '  end',\n  'end',\n  'redis.call(\"hset\",KEYS[1],unpack(ARGV, 4))',\n  'for k=1,tkc do',\n  '  redis.call(\"smove\",KEYS[1+tkc+k],KEYS[1+k],$id)',\n  'end',\n  'return 1',\n], 'uniqueKeyCount', 'totalKeyCount', 'id');\n\n// KEYS = [id, ...keys]\nconst SCRIPT_REMOVE_ITEM = minifyLuaScript([\n  'redis.call(\"del\",KEYS[1])',\n  'for k=2,#KEYS do',\n  '  redis.call(\"srem\",KEYS[k],$id)',\n  'end',\n], 'id');\n\nexport default async function defineAllScripts(\n  client: Redis,\n): Promise<ERedis> {\n  await client.defineCommand('add', { lua: SCRIPT_ADD_ITEM });\n  await client.defineCommand('update', { lua: SCRIPT_UPDATE_ITEM });\n  await client.defineCommand('remove', { lua: SCRIPT_REMOVE_ITEM });\n\n  return client as ERedis;\n}\n","import IORedis from 'ioredis';\nimport defineAllScripts, { ERedis } from './scripts';\nimport retry from '../helpers/retry';\n\ntype RS = new(host?: string, options?: IORedis.RedisOptions) => IORedis.Redis;\n\nconst withRetry = retry((e) => (\n  typeof e === 'object' &&\n  e.message === 'transient error'\n));\n\nexport default class RedisConnectionPool {\n  private readonly connections: ERedis[] = [];\n\n  private inUse: number = 0;\n\n  private queue: ((client: ERedis) => void)[] = [];\n\n  private closingFn?: () => void;\n\n  private closed = false;\n\n  public constructor(\n    private readonly RedisStatic: RS,\n    private readonly url: string,\n    private readonly options: IORedis.RedisOptions,\n    private readonly maxConnections: number,\n  ) {}\n\n  public async withConnection<T>(\n    fn: (c: ERedis) => Promise<T> | T,\n    teardown?: (c: ERedis) => Promise<void> | void,\n  ): Promise<T> {\n    const c = await this.getConnection();\n    try {\n      return await fn(c);\n    } finally {\n      if (teardown) {\n        await teardown(c);\n      }\n      this.returnConnection(c);\n    }\n  }\n\n  public async retryWithConnection<T>(\n    fn: (c: ERedis) => Promise<T> | T,\n    teardown?: (c: ERedis) => Promise<void> | void,\n  ): Promise<T> {\n    return withRetry(() => this.withConnection(fn, teardown));\n  }\n\n  public close(): Promise<void> {\n    if (this.closed) {\n      return Promise.resolve();\n    }\n\n    this.closed = true;\n    if (this.inUse === 0) {\n      this.doClose();\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve): void => {\n      this.closingFn = (): void => {\n        this.doClose();\n        resolve();\n      };\n    });\n  }\n\n  private doClose(): void {\n    this.connections.forEach((c) => c.disconnect());\n    this.connections.length = 0;\n  }\n\n  private async getConnection(): Promise<ERedis> {\n    if (this.closed) {\n      throw new Error('Connection closed');\n    }\n\n    const r = this.connections.pop();\n    if (r) {\n      this.inUse += 1;\n      return r;\n    }\n    if (this.inUse < this.maxConnections) {\n      this.inUse += 1;\n      const client = new this.RedisStatic(this.url, this.options);\n      await client.connect();\n      return defineAllScripts(client);\n    }\n    return new Promise((resolve): void => {\n      this.queue.push(resolve);\n    });\n  }\n\n  private returnConnection(c: ERedis): void {\n    const q = this.queue.shift();\n    if (q) {\n      q(c);\n    } else {\n      this.inUse -= 1;\n      this.connections.push(c);\n      if (this.closingFn && this.inUse === 0) {\n        this.closingFn();\n      }\n    }\n  }\n}\n","import RedisCollection from './RedisCollection';\nimport DB, { DBKeys } from '../interfaces/DB';\nimport IDable from '../interfaces/IDable';\nimport RedisConnectionPool from './RedisConnectionPool';\n\nexport default class RedisDb implements DB {\n  private constructor(\n    private readonly pool: RedisConnectionPool,\n  ) {}\n\n  public static async connect(url: string): Promise<RedisDb> {\n    const { default: RedisStatic } = await import('ioredis');\n    const connectionPoolSize = 5;\n    return new RedisDb(new RedisConnectionPool(\n      RedisStatic,\n      url,\n      { lazyConnect: true },\n      connectionPoolSize,\n    ));\n  }\n\n  public getCollection<T extends IDable>(\n    name: string,\n    keys?: DBKeys<T>,\n  ): RedisCollection<T> {\n    return new RedisCollection(this.pool, name, keys);\n  }\n\n  public close(): Promise<void> {\n    return this.pool.close();\n  }\n\n  public getConnectionPool(): RedisConnectionPool {\n    return this.pool;\n  }\n}\n","import IDable from '../interfaces/IDable';\nimport Collection, { UpdateOptions } from '../interfaces/Collection';\n\nexport type Wrapped<T extends IDable, WF extends keyof T, W> = {\n  [K in keyof T]: K extends 'id' ? T[K] : K extends WF ? W : T[K];\n};\n\nexport interface Wrapper<T extends IDable, K extends keyof T, W, E> {\n  wrap: (\n    key: K,\n    value: T[K],\n    processed: E,\n  ) => Promise<W> | W;\n\n  unwrap: (\n    key: K,\n    value: W,\n    processed: E,\n  ) => Promise<T[K]> | T[K];\n\n  preWrap?: (\n    record: Readonly<Partial<T>>,\n  ) => Promise<E> | E;\n\n  preUnwrap?: (\n    record: Readonly<Partial<Wrapped<T, K, W>>>,\n  ) => Promise<E> | E;\n\n  preRemove?: (\n    record: Readonly<Pick<Wrapped<T, K, W>, 'id'>>,\n  ) => Promise<void> | void;\n}\n\nfunction hasAnyField(value: object, fields: readonly string[]): boolean {\n  return fields\n    .some((field) => Object.prototype.hasOwnProperty.call(value, field));\n}\n\nexport default class WrappedCollection<\n  T extends IDable,\n  WF extends readonly (keyof Omit<T, 'id'> & string)[],\n  W,\n  E,\n  Inner extends Wrapped<T, WF[-1], W> = Wrapped<T, WF[-1], W>\n> implements Collection<T> {\n  public constructor(\n    private readonly baseCollection: Collection<Inner>,\n    private readonly fields: WF,\n    private readonly wrapper: Wrapper<T, WF[-1], W, E>,\n  ) {}\n\n  public async add(entry: T): Promise<void> {\n    return this.baseCollection.add(await this.wrapAll(entry));\n  }\n\n  public async get<\n    K extends keyof T & keyof Inner & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    key: K,\n    value: T[K] & Inner[K],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>> | null> {\n    if (this.fields.includes(key as any)) {\n      throw new Error('Cannot get by encrypted value');\n    }\n    const raw = await this.baseCollection.get(key, value, fields!);\n    return raw ? this.unwrapAll(raw, { [key]: value }) : null;\n  }\n\n  public async getAll<\n    K extends keyof T & keyof Inner & string,\n    F extends readonly (keyof T & string)[]\n  >(\n    key?: K,\n    value?: T[K] & Inner[NonNullable<K>],\n    fields?: F,\n  ): Promise<Readonly<Pick<T, F[-1]>>[]> {\n    if (key !== undefined && this.fields.includes(key as any)) {\n      throw new Error('Cannot get by encrypted value');\n    }\n    const raw = await this.baseCollection.getAll(key!, value!, fields!);\n    const extra = (key !== undefined) ? { [key]: value } : undefined;\n    return Promise.all(raw.map((v) => this.unwrapAll(v, extra)));\n  }\n\n  public async update<K extends keyof T & keyof Inner & string>(\n    key: K,\n    value: T[K] & Inner[K],\n    update: Partial<T>,\n    options?: UpdateOptions,\n  ): Promise<void> {\n    if (this.fields.includes(key as any)) {\n      throw new Error('Cannot update by encrypted value');\n    }\n    const converted = await this.wrapAll(update, { [key]: value });\n    return this.baseCollection.update(key, value, converted, options);\n  }\n\n  public async remove<K extends keyof T & string>(\n    key: K,\n    value: T[K] & Inner[K],\n  ): Promise<number> {\n    if (this.fields.includes(key as any)) {\n      throw new Error('Cannot remove by encrypted value');\n    }\n    if (!this.wrapper.preRemove) {\n      return this.baseCollection.remove(key, value);\n    }\n\n    const items = await this.baseCollection.getAll(key, value, ['id']);\n    await Promise.all(items.map(async (item) => {\n      await this.wrapper.preRemove!(item);\n      await this.baseCollection.remove('id', item.id);\n    }));\n    return items.length;\n  }\n\n  private async wrapAll(\n    v: Readonly<T>,\n    extra?: object,\n  ): Promise<Inner>;\n\n  private async wrapAll(\n    v: Readonly<Partial<T>>,\n    extra?: object,\n  ): Promise<Partial<Inner>>;\n\n  private async wrapAll(\n    v: Readonly<Partial<T>>,\n    extra?: object,\n  ): Promise<Partial<Inner>> {\n    let processed: E;\n    if (this.wrapper.preWrap && hasAnyField(v, this.fields)) {\n      const allFields = extra ? Object.assign({}, extra, v) : v;\n      processed = await this.wrapper.preWrap(allFields);\n    }\n    const converted = Object.assign({}, v) as any;\n    await Promise.all(this.fields.map(async (k) => {\n      if (Object.prototype.hasOwnProperty.call(v, k)) {\n        converted[k] = await this.wrapper.wrap(k, (v as any)[k], processed);\n      }\n    }));\n    return converted;\n  }\n\n  private async unwrapAll(\n    v: Readonly<Inner>,\n    extra?: object,\n  ): Promise<T>;\n\n  private async unwrapAll<K extends keyof T>(\n    v: Readonly<Pick<Inner, K>>,\n    extra?: object,\n  ): Promise<Pick<T, K>>;\n\n  private async unwrapAll<K extends keyof T>(\n    v: Readonly<Pick<Inner, K>>,\n    extra?: object,\n  ): Promise<Pick<T, K>> {\n    let processed: E;\n    if (this.wrapper.preUnwrap && hasAnyField(v, this.fields)) {\n      const allFields = extra ? Object.assign({}, extra, v) : v;\n      processed = await this.wrapper.preUnwrap(allFields as any);\n    }\n    const converted = Object.assign({}, v) as any;\n    await Promise.all(this.fields.map(async (k) => {\n      if (Object.prototype.hasOwnProperty.call(v, k)) {\n        converted[k] = await this.wrapper.unwrap(k, (v as any)[k], processed);\n      }\n    }));\n    return converted;\n  }\n}\n","export default class LruCache<K, V> {\n  private readonly storage = new Map<K, V>();\n\n  public constructor(\n    private readonly capacity: number,\n  ) {}\n\n  public set(key: K, value: V): void {\n    this.storage.delete(key);\n    this.storage.set(key, value);\n    this.flush();\n  }\n\n  public get(key: K): V | undefined {\n    const value = this.storage.get(key);\n    if (this.storage.delete(key)) {\n      this.storage.set(key, value!);\n    }\n    return value;\n  }\n\n  public remove(key: K): void {\n    this.storage.delete(key);\n  }\n\n  private flush(): void {\n    while (this.storage.size > this.capacity) {\n      this.storage.delete(this.storage.keys().next().value);\n    }\n  }\n}\n","import crypto, { KeyObject } from 'crypto';\nimport Encryption from './Encryption';\n\nconst ALG = 'aes-256-cbc';\nconst ALG_BUF = Buffer.from(`${ALG}:`, 'utf8');\nconst IV_LEN = 16;\n\nconst nodeEncryptionSync: Encryption<Buffer, KeyObject, Buffer> = {\n  encrypt: (key: KeyObject, v: string): Buffer => {\n    const iv = crypto.randomBytes(IV_LEN);\n    const cipher = crypto.createCipheriv(ALG, key, iv);\n    const part = cipher.update(v, 'utf8');\n    const final = cipher.final();\n    return Buffer.concat([ALG_BUF, iv, part, final]);\n  },\n\n  decrypt: (key: KeyObject, v: Buffer): string => {\n    if (!v.slice(0, ALG_BUF.length).equals(ALG_BUF)) {\n      throw new Error('Unknown encryption algorithm');\n    }\n\n    const iv = v.slice(ALG_BUF.length, ALG_BUF.length + IV_LEN);\n    const encrypted = v.slice(ALG_BUF.length + IV_LEN);\n\n    const decipher = crypto.createDecipheriv(ALG, key as any, iv);\n    let decrypted = decipher.update(encrypted, undefined, 'utf8');\n    decrypted += decipher.final('utf8');\n\n    return decrypted;\n  },\n\n  generateKey: (): KeyObject => crypto\n    .createSecretKey(crypto.randomBytes(32)),\n\n  serialiseKey: (key: KeyObject): Buffer => key.export(),\n\n  deserialiseKey: (data: Buffer): KeyObject => crypto.createSecretKey(data),\n};\n\nexport default nodeEncryptionSync;\n","import IDable, { IDableBy, IDType } from '../interfaces/IDable';\nimport Collection from '../interfaces/Collection';\nimport LruCache from '../helpers/LruCache';\nimport { serialiseValue, deserialiseValue } from '../helpers/serialiser';\nimport WrappedCollection, { Wrapped } from './WrappedCollection';\nimport Encryption from './encryption/Encryption';\nimport nodeEncryptionSync from './encryption/nodeEncryptionSync';\n\nexport interface KeyRecord<ID extends IDType, KeyT> {\n  id: ID;\n  key: KeyT;\n}\n\ntype EncryptableKeys<T> = readonly (keyof Omit<T, 'id'> & string)[];\n\ntype Encrypter<EncT, ID extends IDType> = <T extends IDableBy<ID>>(\n) => <F extends EncryptableKeys<T>>(\n  fields: F,\n  baseCollection: Collection<Wrapped<T, F[-1], EncT>>,\n) => Collection<T>;\n\n// makeEncrypter provides optional 2-tier function call due to\n// https://github.com/Microsoft/TypeScript/issues/26242\n\nfunction makeEncrypter<EncT, ID extends IDType>(\n  wrapper: <T extends IDableBy<ID>, F extends EncryptableKeys<T>>(\n    fields: F,\n    baseCollection: Collection<Wrapped<T, F[-1], EncT>>,\n  ) => Collection<T>,\n): Encrypter<EncT, ID> {\n  return (fields?: any, baseCollection?: Collection<any>): any => {\n    if (fields && baseCollection) {\n      // non-typescript API (remove need for extra ())\n      return wrapper(fields, baseCollection) as any;\n    }\n    return wrapper;\n  };\n}\n\nfunction encryptByKey(sKey: Buffer): Encrypter<Buffer, IDType>;\n\nfunction encryptByKey<EncT, KeyT, SerialisedKeyT>(\n  sKey: SerialisedKeyT,\n  cr: Encryption<EncT, KeyT, SerialisedKeyT>,\n): Encrypter<EncT, IDType>;\n\nfunction encryptByKey<EncT, KeyT, SerialisedKeyT>(\n  sKey: SerialisedKeyT,\n  cr: Encryption<EncT, KeyT, SerialisedKeyT> = nodeEncryptionSync as any,\n): Encrypter<EncT, IDType> {\n  const key = cr.deserialiseKey(sKey);\n\n  return makeEncrypter(<T extends IDable, F extends EncryptableKeys<T>>(\n    fields: F,\n    baseCollection: Collection<Wrapped<T, F[-1], EncT>>,\n  ) => new WrappedCollection<T, F, EncT, never>(baseCollection, fields, {\n    wrap: (k, v): Promise<EncT> | EncT => cr.encrypt(key, serialiseValue(v)),\n    unwrap: async (k, v): Promise<any> => deserialiseValue(await cr.decrypt(key, v)),\n  }));\n}\n\nfunction encryptByRecord<ID extends IDType>(\n  keyCollection: Collection<KeyRecord<ID, Buffer>>,\n  cacheSize?: number,\n): Encrypter<Buffer, ID>;\n\nfunction encryptByRecord<ID extends IDType, EncT, KeyT, SerialisedKeyT>(\n  keyCollection: Collection<KeyRecord<ID, SerialisedKeyT>>,\n  cacheSize: number,\n  cr: Encryption<EncT, KeyT, SerialisedKeyT>,\n): Encrypter<EncT, ID>;\n\nfunction encryptByRecord<ID extends IDType, EncT, KeyT, SerialisedKeyT>(\n  keyCollection: Collection<KeyRecord<ID, SerialisedKeyT>>,\n  cacheSize: number = 0,\n  cr: Encryption<EncT, KeyT, SerialisedKeyT> = nodeEncryptionSync as any,\n): Encrypter<EncT, ID> {\n  const cache = new LruCache<ID, KeyT>(cacheSize);\n\n  const loadKey = async (\n    generateIfNeeded: boolean,\n    record: { id?: ID },\n  ): Promise<KeyT> => {\n    const { id } = record;\n\n    if (id === undefined) {\n      throw new Error('Must provide ID for encryption');\n    }\n\n    const cached = cache.get(id);\n    if (cached) {\n      return cached;\n    }\n    let key: KeyT;\n    const item = await keyCollection.get('id', id, ['key']);\n    if (item) {\n      key = cr.deserialiseKey(item.key);\n    } else {\n      if (!generateIfNeeded) {\n        throw new Error('No encryption key found for record');\n      }\n      key = await cr.generateKey();\n      await keyCollection.add({ id, key: cr.serialiseKey(key) });\n    }\n    cache.set(id, key);\n    return key;\n  };\n\n  const removeKey = async ({ id }: { id: ID }): Promise<void> => {\n    await keyCollection.remove('id', id);\n    cache.remove(id);\n  };\n\n  return makeEncrypter(<T extends IDableBy<ID>, F extends EncryptableKeys<T>>(\n    fields: F,\n    baseCollection: Collection<Wrapped<T, F[-1], EncT>>,\n  ) => new WrappedCollection<T, F, EncT, KeyT>(baseCollection, fields, {\n    wrap: (k, v, key): Promise<EncT> | EncT => cr.encrypt(key, JSON.stringify(v)),\n    unwrap: async (k, v, key): Promise<any> => JSON.parse(await cr.decrypt(key, v)),\n    preWrap: loadKey.bind(null, true),\n    preUnwrap: loadKey.bind(null, false),\n    preRemove: removeKey,\n  }));\n}\n\nfunction encryptByRecordWithMasterKey<ID extends IDType>(\n  sMasterKey: Buffer,\n  keyCollection: Collection<KeyRecord<ID, Buffer>>,\n  cacheSize?: number,\n): Encrypter<Buffer, ID>;\n\nfunction encryptByRecordWithMasterKey<ID extends IDType, EncT, KeyT, SerialisedKeyT>(\n  sMasterKey: SerialisedKeyT,\n  keyCollection: Collection<KeyRecord<ID, EncT>>,\n  cacheSize: number,\n  cr: Encryption<EncT, KeyT, SerialisedKeyT>,\n): Encrypter<EncT, ID>;\n\nfunction encryptByRecordWithMasterKey<ID extends IDType, EncT, KeyT, SerialisedKeyT>(\n  sMasterKey: SerialisedKeyT,\n  keyCollection: Collection<KeyRecord<ID, EncT>>,\n  cacheSize: number = 0,\n  cr: Encryption<EncT, KeyT, SerialisedKeyT> = nodeEncryptionSync as any,\n): Encrypter<EncT, ID> {\n  const keyEnc = encryptByKey(sMasterKey, cr);\n  const encKeyCollection = keyEnc<KeyRecord<ID, SerialisedKeyT>>()(\n    ['key'],\n    keyCollection,\n  );\n  return encryptByRecord(encKeyCollection, cacheSize, cr);\n}\n\nexport {\n  encryptByKey,\n  encryptByRecord,\n  encryptByRecordWithMasterKey,\n};\n","import CollectionStorage from './CollectionStorage';\nimport WrappedCollection, { Wrapped } from './wrappers/WrappedCollection';\nimport Encryption from './wrappers/encryption/Encryption';\nimport {\n  encryptByKey,\n  encryptByRecord,\n  encryptByRecordWithMasterKey,\n} from './wrappers/encrypted';\nimport DB from './interfaces/DB';\nimport Collection from './interfaces/Collection';\nimport IDable from './interfaces/IDable';\n\nexport type DB = DB;\nexport type Collection<T extends IDable> = Collection<T>;\nexport type Wrapped<T extends IDable, WF extends keyof T, W> =\n  Wrapped<T, WF, W>;\nexport type Encrypted<T extends IDable, WF extends keyof T> =\n  Wrapped<T, WF, Buffer>;\nexport type Encryption<EncT, KeyT, SerialisedKeyT> =\n  Encryption<EncT, KeyT, SerialisedKeyT>;\n\nexport { default as MemoryDb } from './memory/MemoryDb';\nexport { default as MongoDb } from './mongo/MongoDb';\nexport { default as RedisDb } from './redis/RedisDb';\nexport { default as LruCache } from './helpers/LruCache';\nexport {\n  WrappedCollection,\n  encryptByKey,\n  encryptByRecord,\n  encryptByRecordWithMasterKey,\n};\nexport {\n  default as nodeEncryptionSync,\n} from './wrappers/encryption/nodeEncryptionSync';\nexport default CollectionStorage;\n","import MemoryDb from './memory/MemoryDb';\nimport MongoDb from './mongo/MongoDb';\nimport RedisDb from './redis/RedisDb';\nimport DB from './interfaces/DB';\n\nexport default class CollectionStorage {\n  public static async connect(url: string): Promise<DB> {\n    let dbClass;\n    if (url.startsWith('memory')) {\n      dbClass = MemoryDb;\n    } else if (url.startsWith('mongodb')) {\n      dbClass = MongoDb;\n    } else if (url.startsWith('redis')) {\n      dbClass = RedisDb;\n    } else {\n      throw new Error(`Unsupported database connection string: ${url}`);\n    }\n\n    try {\n      return await dbClass.connect(url);\n    } catch (e) {\n      throw new Error(`Failed to connect to database \"${url}\": ${e.message}`);\n    }\n  }\n}\n"],"sourceRoot":""}