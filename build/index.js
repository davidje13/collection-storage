!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("websocket-express",[],t):"object"==typeof exports?exports["websocket-express"]=t():e["websocket-express"]=t()}(global,function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=2)}([function(e,t){e.exports=require("crypto")},function(e,t){e.exports=require("url")},function(e,t,r){e.exports=r(7)},function(e,t){e.exports=require("mongodb")},function(e,t){},function(e,t){},function(e,t){},function(e,t,r){"use strict";r.r(t);var n=r(1);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e){return e?new Promise(t=>setTimeout(t,e)):null}class s{constructor(e={},t=0){this.simulatedLatency=t,i(this,"data",void 0),i(this,"keyList",[]),i(this,"keys",{}),this.data=new Map,Object.keys(e).forEach(t=>{const r=t;this.keyList.push(r),this.keys[r]={map:new Map,options:e[r]}})}async add(e){await a(this.simulatedLatency),this.internalCheckDuplicates(e,!0),this.data.set(e.id,JSON.stringify(e)),this.internalPopulateIndices(e)}async update(e,t,r,{upsert:n=!1}={}){await a(this.simulatedLatency);const i=this.internalGetIds(e,t)[0];if(void 0===i)return void(n&&await this.add(Object.assign({[e]:t},r)));const s=JSON.parse(this.data.get(i)),o=Object.assign({},s,r);if(o.id!==s.id)throw new Error("Cannot update id");this.internalRemoveIndices(s);try{this.internalCheckDuplicates(o,!1)}catch(e){throw this.internalPopulateIndices(s),e}this.data.set(o.id,JSON.stringify(o)),this.internalPopulateIndices(o)}async get(e,t,r){const n=await this.getAll(e,t,r);return n.length?n[0]:null}async getAll(e,t,r){let n;return await a(this.simulatedLatency),(n=e?this.internalGetIds(e,t):[...this.data.keys()]).map(e=>(function(e,t){if(!t)return e;const r={};return t.forEach(t=>{r[t]=e[t]}),r})(JSON.parse(this.data.get(e)),r))}async remove(e,t){await a(this.simulatedLatency);const r=this.internalGetIds(e,t);return r.forEach(e=>{const t=JSON.parse(this.data.get(e));this.internalRemoveIndices(t),this.data.delete(e)}),r.length}internalGetIds(e,t){if("id"===e){const e=t;return this.data.has(e)?[e]:[]}const r=this.keys[e];if(!r)throw new Error(`Requested key ${e} not indexed`);const n=r.map.get(t);return n?[...n]:[]}internalCheckDuplicates(e,t){if(t&&this.data.has(e.id))throw new Error("duplicate");this.keyList.forEach(t=>{const{map:r,options:n}=this.keys[t];if(n.unique&&r.has(e[t]))throw new Error("duplicate")})}internalPopulateIndices(e){this.keyList.forEach(t=>{const{map:r}=this.keys[t],n=e[t];let i=r.get(n);i||(i=new Set,r.set(n,i)),i.add(e.id)})}internalRemoveIndices(e){this.keyList.forEach(t=>{const{map:r}=this.keys[t],n=e[t],i=r.get(n);i.delete(e.id),i.size||r.delete(n)})}}function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}const c=function(e,t){const r=global[e];return r||(global[e]=t,t)}("collectionStorageInMemory",new Map);class l{constructor({simulatedLatency:e=0}={}){o(this,"simulatedLatency",void 0),o(this,"mapTables",new Map),this.simulatedLatency=e}static connect(e){const t=new n.URL(e),r=t.hostname;if(r&&c.has(r))return c.get(r);const i=t.searchParams,a=Number(i.get("simulatedLatency")),s=new l({simulatedLatency:a});return r&&c.set(r,s),s}getCollection(e,t){return this.mapTables.has(e)||this.mapTables.set(e,new s(t,this.simulatedLatency)),this.mapTables.get(e)}}function u(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),r.push.apply(r,n)}return r}function p(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?u(r,!0).forEach(function(t){d(e,t,r[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):u(r).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))})}return e}function d(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function f(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}function h(e){var t=function(e,t){if("object"!=typeof e||null===e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==typeof t?t:String(t)}const y="_id",w="id";function b(e){return e===w?y:e}function m(e){if(!e||void 0===e[w])return e;const{[w]:t}=e,r=f(e,[w].map(h));return p({[y]:t},r)}function g(e){if(!e||void 0===e[y])return e;const{[y]:t}=e,r=f(e,[y].map(h));return p({[w]:t},r)}function v(e){const t={};return e&&(t[y]=!1,e.forEach(e=>{t[b(e)]=!0})),t}class O{constructor(e,t={}){this.collection=e,Object.keys(t).forEach(r=>{const n=r,i=t[n];i&&i.unique?e.createIndex({[n]:1},{unique:!0}):e.createIndex({[n]:"hashed"})})}async add(e){await this.collection.insertOne(m(e))}async update(e,t,r,{upsert:n=!1}={}){await this.collection.updateOne({[b(e)]:t},{$set:m(r)},{upsert:n})}async get(e,t,r){return g(await this.collection.findOne({[b(e)]:t},{projection:v(r)}))}async getAll(e,t,r){const n=[];let i;const a=v(r);return i=e?this.collection.find({[b(e)]:t},{projection:a}):this.collection.find({},{projection:a}),await i.forEach(e=>n.push(g(e))),n}async remove(e,t){return(await this.collection.deleteMany({[b(e)]:t})).deletedCount||0}}class j{constructor(e){this.db=e}static async connect(e){const{MongoClient:t}=await Promise.resolve().then(()=>r(3)),n=await t.connect(e,{useNewUrlParser:!0,useUnifiedTopology:!0});return new j(n.db())}getCollection(e,t){const r=this.db.collection(e);return new O(r,t)}}function P(e,t){return t.some(t=>Object.prototype.hasOwnProperty.call(e,t))}class k{constructor(e,t,r){this.baseCollection=e,this.fields=t,this.wrapper=r}async add(e){return this.baseCollection.add(await this.wrapAll(e))}async get(e,t,r){if(this.fields.includes(e))throw new Error("Cannot get by encrypted value");const n=await this.baseCollection.get(e,t,r);return n?this.unwrapAll(n):null}async getAll(e,t,r){if(void 0!==e&&this.fields.includes(e))throw new Error("Cannot get by encrypted value");const n=await this.baseCollection.getAll(e,t,r);return Promise.all(n.map(e=>this.unwrapAll(e)))}async update(e,t,r,n){if(this.fields.includes(e))throw new Error("Cannot update by encrypted value");const i=await this.wrapAll(r);return this.baseCollection.update(e,t,i,n)}async remove(e,t){if(this.fields.includes(e))throw new Error("Cannot remove by encrypted value");if(!this.wrapper.preRemove)return this.baseCollection.remove(e,t);const r=await this.baseCollection.getAll(e,t,["id"]);return await Promise.all(r.map(async e=>{await this.wrapper.preRemove(e),await this.baseCollection.remove("id",e.id)})),r.length}async wrapAll(e){let t;this.wrapper.preWrap&&P(e,this.fields)&&(t=await this.wrapper.preWrap(e));const r=Object.assign({},e);return await Promise.all(this.fields.map(async n=>{Object.prototype.hasOwnProperty.call(e,n)&&(r[n]=await this.wrapper.wrap(n,e[n],t))})),r}async unwrapAll(e){let t;this.wrapper.preUnwrap&&P(e,this.fields)&&(t=await this.wrapper.preUnwrap(e));const r=Object.assign({},e);return await Promise.all(this.fields.map(async n=>{Object.prototype.hasOwnProperty.call(e,n)&&(r[n]=await this.wrapper.unwrap(n,e[n],t))})),r}}r(4),r(5),r(6);class S{constructor(e){var t,r,n;this.capacity=e,t=this,r="storage",n=new Map,r in t?Object.defineProperty(t,r,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[r]=n}set(e,t){this.storage.delete(e),this.storage.set(e,t),this.flush()}get(e){const t=this.storage.get(e);return this.storage.delete(e)&&this.storage.set(e,t),t}remove(e){this.storage.delete(e)}flush(){for(;this.storage.size>this.capacity;)this.storage.delete(this.storage.keys().next().value)}}var E=r(0),x=r.n(E);const C="aes-256-cbc";var L={encrypt:(e,t)=>{const r=x.a.randomBytes(16),n=x.a.createCipheriv(C,e,r),i=n.update(t,"utf8","base64");return`${C}:${r.toString("base64")}:${i}${n.final("base64")}`},decrypt:(e,t)=>{const[r,n,i]=t.split(":");if(r!==C)throw new Error("Unknown encryption algorithm");const a=x.a.createDecipheriv(C,e,Buffer.from(n,"base64"));let s=a.update(i,"base64","utf8");return s+=a.final("utf8")},generateKey:()=>x.a.createSecretKey(x.a.randomBytes(32)),serialiseKey:e=>e.export().toString("base64"),deserialiseKey:e=>x.a.createSecretKey(Buffer.from(e,"base64"))};const I=(e,t=L)=>(r,n)=>{const i=t.deserialiseKey(e);return new k(n,r,{wrap:(e,r)=>t.encrypt(i,JSON.stringify(r)),unwrap:async(e,r)=>JSON.parse(await t.decrypt(i,r))})},M=(e,t=0,r=L)=>(n,i)=>{const a=new S(t),s=async(t,n)=>{const{id:i}=n;if(void 0===i)throw new Error("Must provide ID for encryption");const s=a.get(i);if(s)return s;let o;const c=await e.get("id",i,["key"]);if(c)o=r.deserialiseKey(c.key);else{if(!t)throw new Error("No encryption key found for record");o=await r.generateKey(),await e.add({id:i,key:r.serialiseKey(o)})}return a.set(i,o),o};return new k(i,n,{wrap:(e,t,n)=>r.encrypt(n,JSON.stringify(t)),unwrap:async(e,t,n)=>JSON.parse(await r.decrypt(n,t)),preWrap:s.bind(null,!0),preUnwrap:s.bind(null,!1),preRemove:async({id:t})=>{await e.remove("id",t),a.remove(t)}})},N=(e,t,r=0,n=L)=>(i,a)=>M(I(e,n)(["key"],t),r,n)(i,a);r.d(t,"MemoryDb",function(){return l}),r.d(t,"MongoDb",function(){return j}),r.d(t,"LruCache",function(){return S}),r.d(t,"WrappedCollection",function(){return k}),r.d(t,"encryptByKey",function(){return I}),r.d(t,"encryptByRecord",function(){return M}),r.d(t,"encryptByRecordWithMasterKey",function(){return N}),r.d(t,"nodeEncryptionSync",function(){return L});t.default=class{static async connect(e){let t;if(e.startsWith("memory"))t=l;else{if(!e.startsWith("mongodb"))throw new Error(`Unsupported database connection string: ${e}`);t=j}try{return await t.connect(e)}catch(t){throw new Error(`Failed to connect to database "${e}": ${t.message}`)}}}}])});
//# sourceMappingURL=index.js.map