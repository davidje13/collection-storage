!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("websocket-express",[],t):"object"==typeof exports?exports["websocket-express"]=t():e["websocket-express"]=t()}(global,(function(){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var i=t[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(r,i,function(t){return e[t]}.bind(null,i));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=3)}([function(e,t){e.exports=require("crypto")},function(e,t){e.exports=require("mongodb")},function(e,t){e.exports=require("url")},function(e,t,n){e.exports=n(8)},function(e,t){e.exports=require("ioredis")},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){"use strict";n.r(t);var r=n(2);function i(e){return e instanceof Buffer?`B${e.toString("base64")}`:`J${JSON.stringify(e)}`}function s(e){const t=e[0],n=e.substr(1);if("B"===t)return Buffer.from(n,"base64");if("J"===t)return JSON.parse(n);throw new Error(`Unknown data type ${t}`)}function o(e){const t={};return Object.keys(e).forEach(n=>{t[n]=i(e[n])}),t}function a(e){const t={};return Object.keys(e).forEach(n=>{const r=e[n];r&&(t[n]=s(r))}),t}function c(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class l{constructor(e={},t=0,n={closed:!1}){this.simulatedLatency=t,this.stateRef=n,c(this,"data",void 0),c(this,"keys",{}),this.data=new Map,Object.keys(e).forEach(t=>{const n=t;this.keys[n]={map:new Map,options:e[n]}})}async add(e){await this.simulateDbConnection();const t=o(e);this.internalCheckDuplicates(t,!0),this.data.set(t.id,t),this.internalPopulateIndices(t)}async update(e,t,n,{upsert:r=!1}={}){if(r&&"id"!==e&&void 0===n.id)throw new Error("Cannot upsert without ID");await this.simulateDbConnection();const i=this.internalGetSerialisedIds(e,t)[0];if(void 0===i){if(r){const r=o(Object.assign({[e]:t},n));this.internalCheckDuplicates(r,!0),this.data.set(r.id,r),this.internalPopulateIndices(r)}return}const s=this.data.get(i),c=a(s),l=Object.assign({},c,n);if(l.id!==c.id)throw new Error("Cannot update id");const u=o(l);this.internalRemoveIndices(s);try{this.internalCheckDuplicates(u,!1)}catch(e){throw this.internalPopulateIndices(s),e}this.data.set(u.id,u),this.internalPopulateIndices(u)}async get(e,t,n){const r=await this.getAll(e,t,n);return r.length?r[0]:null}async getAll(e,t,n){let r;return await this.simulateDbConnection(),(r=e?this.internalGetSerialisedIds(e,t):[...this.data.keys()]).map(e=>(function(e,t){if(!t)return e;const n={};return t.forEach(t=>{n[t]=e[t]}),n})(a(this.data.get(e)),n))}async remove(e,t){await this.simulateDbConnection();const n=this.internalGetSerialisedIds(e,t);return n.forEach(e=>{const t=this.data.get(e);this.internalRemoveIndices(t),this.data.delete(e)}),n.length}async simulateDbConnection(){if(this.stateRef.closed)throw new Error("Connection closed");var e;await(e=this.simulatedLatency,e?new Promise(t=>setTimeout(t,e)):null)}internalGetSerialisedIds(e,t){const n=i(t);if("id"===e)return this.data.has(n)?[n]:[];const r=this.keys[e];if(!r)throw new Error(`Requested key ${e} not indexed`);const s=r.map.get(n);return s?[...s]:[]}internalCheckDuplicates(e,t){if(t&&this.data.has(e.id))throw new Error("duplicate");Object.entries(this.keys).forEach(([t,n])=>{const{map:r,options:i}=n;if(i.unique&&r.has(e[t]))throw new Error("duplicate")})}internalPopulateIndices(e){Object.entries(this.keys).forEach(([t,n])=>{const{map:r}=n,i=e[t];let s=r.get(i);s||(s=new Set,r.set(i,s)),s.add(e.id)})}internalRemoveIndices(e){Object.entries(this.keys).forEach(([t,n])=>{const{map:r}=n,i=e[t],s=r.get(i);s.delete(e.id),s.size||r.delete(i)})}}function u(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}const h=function(e,t){const n=global[e];return n||(global[e]=t,t)}("collectionStorageInMemory",new Map);class d{constructor({simulatedLatency:e=0}={}){u(this,"simulatedLatency",void 0),u(this,"mapTables",new Map),u(this,"stateRef",{closed:!1}),this.simulatedLatency=e}static connect(e){const t=new r.URL(e),n=t.hostname;if(n&&h.has(n))return h.get(n);const i=t.searchParams,s=Number(i.get("simulatedLatency")),o=new d({simulatedLatency:s});return n&&h.set(n,o),o}getCollection(e,t){return this.mapTables.has(e)||this.mapTables.set(e,new l(t,this.simulatedLatency,this.stateRef)),this.mapTables.get(e)}close(){this.stateRef.closed=!0}}var f=n(1);function p(e){return new Promise(t=>setTimeout(t,e))}var y=(e,t=5,n=20,r=200,i=200)=>async s=>{for(let o=1;;o+=1){try{return await s()}catch(n){if(!e(n))throw n;if(o>=t)throw n.message+=` (attempted ${o} times)`,n}await p(n+o*r+Math.random()*i)}};const w="_id",g="id",m=/\./g;function b(e){return e===g?w:encodeURIComponent(e).replace(m,"%2E")}const k=y(e=>"object"==typeof e&&e.message.includes("E11000"));function v(e){const t={};return Object.keys(e).forEach(n=>{let r=e[n];if(r instanceof Buffer)r=new f.Binary(r);else if("object"==typeof r&&r._bsontype)throw new Error("Must use Buffer to provide binary data");t[b(n)]=r}),t}function C(e){if(!e)return null;const t={};return Object.keys(e).forEach(n=>{let r=e[n];"object"==typeof r&&"Binary"===r._bsontype&&(r=r.buffer),t[function(e){return e===w?g:decodeURIComponent(e)}(n)]=r}),t}function E(e){const t={};return e&&(t[w]=!1,e.forEach(e=>{t[b(e)]=!0})),t}class O{constructor(e,t={},n={closed:!1}){this.collection=e,this.keys=t,this.stateRef=n,Object.keys(t).forEach(n=>{const r=n,i=t[r],s=b(r);i&&i.unique?e.createIndex({[s]:1},{unique:!0}):e.createIndex({[s]:"hashed"})})}async add(e){await this.getCollection().insertOne(v(e))}async update(e,t,n,{upsert:r=!1}={}){if(r&&"id"!==e&&void 0===n.id)throw new Error("Cannot upsert without ID");this.checkIndexExists(e),r?await k(()=>this.getCollection().updateOne(v({[e]:t}),{$set:v(n)},{upsert:!0})):await this.getCollection().updateOne(v({[e]:t}),{$set:v(n)})}async get(e,t,n){return this.checkIndexExists(e),C(await this.getCollection().findOne(v({[e]:t}),{projection:E(n)}))}async getAll(e,t,n){const r=[];let i;const s=E(n);return e?(this.checkIndexExists(e),i=this.getCollection().find(v({[e]:t}),{projection:s})):i=this.getCollection().find({},{projection:s}),await i.forEach(e=>r.push(C(e))),r}async remove(e,t){return this.checkIndexExists(e),(await this.getCollection().deleteMany(v({[e]:t}))).deletedCount||0}checkIndexExists(e){if("id"!==e&&!this.keys[e])throw new Error(`No index for ${e}`)}getCollection(){if(this.stateRef.closed)throw new Error("Connection closed");return this.collection}}class K{constructor(e){var t,n,r;this.client=e,r={closed:!1},(n="stateRef")in(t=this)?Object.defineProperty(t,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[n]=r}static async connect(e){const{MongoClient:t}=await Promise.resolve().then(()=>n(1)),r=await t.connect(e,{useNewUrlParser:!0,useUnifiedTopology:!0});return new K(r)}getCollection(e,t){const n=this.client.db().collection(function(e){return encodeURIComponent(e)}(e));return new O(n,t,this.stateRef)}async close(){return this.stateRef.closed=!0,this.client.close()}getDb(){return this.client.db()}}function j(e,...t){let n=e.map(e=>e.trim()).join(" ");return t.forEach((e,t)=>{n=n.replace(new RegExp(`\\$${e}\\b`,"g"),`ARGV[${t+1}]`)}),n}function x(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function P(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}function S(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function R(e,t){return e.filter(({key:e})=>t[e]).map(({key:e,prefix:n})=>`${n}:${t[e]}`)}function $(e,t){if(!t)return e;const n={};for(let r=0;r<t.length;r+=1)n[t[r]]=e[r];return n}function q(e){return Object.values(e).some(e=>null!==e)}async function B(e){await e.unwatch()}class I{constructor(e,t,n={}){this.pool=e,this.prefix=t,S(this,"keyPrefixes",{}),S(this,"keys",[]),S(this,"uniqueKeys",[]),S(this,"nonUniqueKeys",[]),Object.keys(n).forEach(e=>{const r=e,i=`${t}-${r}`;this.keyPrefixes[r]=i;const s={key:r,prefix:i};this.keys.push(s),n[r].unique?this.uniqueKeys.push(s):this.nonUniqueKeys.push(s)})}add(e){const t=o(e);return this.pool.withConnection(async e=>{if(!await this.internalAdd(e,t,!1))throw new Error("duplicate")})}update(e,t,n,{upsert:r=!1}={}){const s=o(n),{id:a}=s,c=P(s,["id"]),l=i(t);if(r&&"id"!==e&&!a)throw new Error("Cannot upsert without ID");return this.pool.retryWithConnection(async t=>{const n=(await this.getAndWatchBySerialisedKey(t,e,l))[0];if(n){if(a&&a!==n)throw new Error("Cannot update id")}else if(!r)return;const i=this.makeKey(n||a);await t.watch(i);const s=n&&await this.rawByKeyKeepWatches(t,n,this.keys.map(e=>e.key).filter(e=>c[e]));if(!s)return void(r&&await this.internalAdd(t,function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?x(n,!0).forEach((function(t){S(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):x(n).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({id:a,[e]:l},c),!0));Object.keys(c).forEach(e=>{s[e]===c[e]&&(delete c[e],delete s[e])});const o=Object.entries(c).flat();if(!o.length)return;const u=R(this.uniqueKeys,c),h=R(this.nonUniqueKeys,c),d=R(this.uniqueKeys,s),f=R(this.nonUniqueKeys,s);if(d.length!==u.length||f.length!==h.length)throw new Error("unexpected key mismatch with old value");const p=1+2*(u.length+h.length),y=[i,...u,...h,...d,...f,u.length,u.length+h.length,n,...o],w=await t.multi().update(p,y).exec();if(!w)throw new Error("transient error");if(!w[0][1])throw new Error("duplicate")},B)}get(e,t,n){const r=i(t);return this.pool.retryWithConnection(async t=>{const i=(await this.getAndWatchBySerialisedKey(t,e,r))[0];return void 0===i?null:(await this.getByKeysKeepWatches(t,[i],n))[0]||null},B)}getAll(e,t,n){return this.pool.retryWithConnection(async r=>{let s;if(e){const n=i(t);s=await this.getAndWatchBySerialisedKey(r,e,n)}else{s=await r.keys(this.makeKey("*"));const e=this.prefix.length+1;s=s.map(t=>t.substr(e))}return this.getByKeysKeepWatches(r,s,n)},B)}remove(e,t){const n=i(t),r=this.keys.map(e=>e.key);return r.push("id"),this.pool.retryWithConnection(async t=>{const i=await this.getAndWatchBySerialisedKey(t,e,n),s=(await Promise.all(i.map(e=>this.rawByKeyKeepWatches(t,e,r)))).filter(e=>void 0!==e);if(0===s.length)return 0;const o=t.multi();return s.forEach(e=>{const t=R(this.keys,e);o.remove(1+t.length,this.makeKey(e.id),...t,e.id)}),await o.exec(),s.length},B)}makeKey(e){return`${this.prefix}:${e}`}async internalAdd(e,t,n){let{id:r}=t,i=P(t,["id"]);const s=R(this.uniqueKeys,i),o=R(this.nonUniqueKeys,i),a=1+s.length+o.length,c=[this.makeKey(r),...s,...o,s.length,"id",r,...Object.entries(i).flat()];if(!n)return Boolean(await e.add(a,...c));const l=await e.multi().add(a,...c).exec();if(!l)throw new Error("transient error");return Boolean(l[0][1])}async getByKeysKeepWatches(e,t,n){const r=await async function(e,t){return t.length?e.multi(t).exec():[]}(e,t.map(e=>this.makeKey(e)).map(e=>n?["hmget",e,...n]:["hgetall",e]));if(!r)throw new Error("transient error");return r.map(([,e])=>$(e,n)).filter(q).map(a)}async rawByKeyKeepWatches(e,t,n){const r=this.makeKey(t);let i;if(n){if(!n.length){return await e.exists(r)?{}:void 0}i=await e.hmget(r,...n)}else i=await e.hgetall(r);const s=$(i,n);return q(s)?s:void 0}async getAndWatchBySerialisedKey(e,t,n){if("id"===t)return[n];const r=this.keyPrefixes[t];if(!r)throw new Error(`Requested key ${t} not indexed`);const i=`${r}:${n}`;return await e.watch(i),e.smembers(i)}}const A=j(['if redis.call("exists",KEYS[1])==1 then',"  return 0","end","for k=2,1+tonumber($uniqueKeyCount) do",'  if redis.call("exists",KEYS[k])==1 then',"    return 0","  end","end",'redis.call("hset",KEYS[1],unpack(ARGV, 2))',"for k=2,#KEYS do",'  redis.call("sadd",KEYS[k],ARGV[3])',"end","return 1"],"uniqueKeyCount"),U=j(["local tkc=tonumber($totalKeyCount)","for k=2,1+tonumber($uniqueKeyCount) do",'  if redis.call("exists",KEYS[k])==1 then',"    return 0","  end","end",'redis.call("hset",KEYS[1],unpack(ARGV, 4))',"for k=1,tkc do",'  redis.call("smove",KEYS[1+tkc+k],KEYS[1+k],$id)',"end","return 1"],"uniqueKeyCount","totalKeyCount","id"),W=j(['redis.call("del",KEYS[1])',"for k=2,#KEYS do",'  redis.call("srem",KEYS[k],$id)',"end"],"id");function D(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}const M=y(e=>"object"==typeof e&&"transient error"===e.message);class Y{constructor(e,t,n,r){this.RedisStatic=e,this.url=t,this.options=n,this.maxConnections=r,D(this,"connections",[]),D(this,"inUse",0),D(this,"queue",[]),D(this,"closingFn",void 0),D(this,"closed",!1)}async withConnection(e,t){const n=await this.getConnection();try{return await e(n)}finally{t&&await t(n),this.returnConnection(n)}}async retryWithConnection(e,t){return M(()=>this.withConnection(e,t))}close(){return this.closed?Promise.resolve():(this.closed=!0,0===this.inUse?(this.doClose(),Promise.resolve()):new Promise(e=>{this.closingFn=()=>{this.doClose(),e()}}))}doClose(){this.connections.forEach(e=>e.disconnect()),this.connections.length=0}async getConnection(){if(this.closed)throw new Error("Connection closed");const e=this.connections.pop();if(e)return this.inUse+=1,e;if(this.inUse<this.maxConnections){this.inUse+=1;const e=new this.RedisStatic(this.url,this.options);return await e.connect(),async function(e){return await e.defineCommand("add",{lua:A}),await e.defineCommand("update",{lua:U}),await e.defineCommand("remove",{lua:W}),e}(e)}return new Promise(e=>{this.queue.push(e)})}returnConnection(e){const t=this.queue.shift();t?t(e):(this.inUse-=1,this.connections.push(e),this.closingFn&&0===this.inUse&&this.closingFn())}}class L{constructor(e){this.pool=e}static async connect(e){const{default:t}=await Promise.resolve().then(()=>n(4));return new L(new Y(t,e,{lazyConnect:!0},5))}getCollection(e,t){return new I(this.pool,e,t)}close(){return this.pool.close()}getConnectionPool(){return this.pool}}function T(e,t){return t.some(t=>Object.prototype.hasOwnProperty.call(e,t))}class _{constructor(e,t,n){this.baseCollection=e,this.fields=t,this.wrapper=n}async add(e){return this.baseCollection.add(await this.wrapAll(e))}async get(e,t,n){if(this.fields.includes(e))throw new Error("Cannot get by encrypted value");const r=await this.baseCollection.get(e,t,n);return r?this.unwrapAll(r,{[e]:t}):null}async getAll(e,t,n){if(void 0!==e&&this.fields.includes(e))throw new Error("Cannot get by encrypted value");const r=await this.baseCollection.getAll(e,t,n),i=void 0!==e?{[e]:t}:void 0;return Promise.all(r.map(e=>this.unwrapAll(e,i)))}async update(e,t,n,r){if(this.fields.includes(e))throw new Error("Cannot update by encrypted value");const i=await this.wrapAll(n,{[e]:t});return this.baseCollection.update(e,t,i,r)}async remove(e,t){if(this.fields.includes(e))throw new Error("Cannot remove by encrypted value");if(!this.wrapper.preRemove)return this.baseCollection.remove(e,t);const n=await this.baseCollection.getAll(e,t,["id"]);return await Promise.all(n.map(async e=>{await this.wrapper.preRemove(e),await this.baseCollection.remove("id",e.id)})),n.length}async wrapAll(e,t){let n;if(this.wrapper.preWrap&&T(e,this.fields)){const r=t?Object.assign({},t,e):e;n=await this.wrapper.preWrap(r)}const r=Object.assign({},e);return await Promise.all(this.fields.map(async t=>{Object.prototype.hasOwnProperty.call(e,t)&&(r[t]=await this.wrapper.wrap(t,e[t],n))})),r}async unwrapAll(e,t){let n;if(this.wrapper.preUnwrap&&T(e,this.fields)){const r=t?Object.assign({},t,e):e;n=await this.wrapper.preUnwrap(r)}const r=Object.assign({},e);return await Promise.all(this.fields.map(async t=>{Object.prototype.hasOwnProperty.call(e,t)&&(r[t]=await this.wrapper.unwrap(t,e[t],n))})),r}}n(5);class G{constructor(e){var t,n,r;this.capacity=e,t=this,n="storage",r=new Map,n in t?Object.defineProperty(t,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[n]=r}set(e,t){this.storage.delete(e),this.storage.set(e,t),this.flush()}get(e){const t=this.storage.get(e);return this.storage.delete(e)&&this.storage.set(e,t),t}remove(e){this.storage.delete(e)}flush(){for(;this.storage.size>this.capacity;)this.storage.delete(this.storage.keys().next().value)}}var N=n(0),J=n.n(N);const F="aes-256-cbc",V=Buffer.from(`${F}:`,"utf8");var z={encrypt:(e,t)=>{const n=J.a.randomBytes(16),r=J.a.createCipheriv(F,e,n),i=r.update(t,"utf8"),s=r.final();return Buffer.concat([V,n,i,s])},decrypt:(e,t)=>{if(!t.slice(0,V.length).equals(V))throw new Error("Unknown encryption algorithm");const n=t.slice(V.length,V.length+16),r=t.slice(V.length+16),i=J.a.createDecipheriv(F,e,n);let s=i.update(r,void 0,"utf8");return s+=i.final("utf8")},generateKey:()=>J.a.createSecretKey(J.a.randomBytes(32)),serialiseKey:e=>e.export(),deserialiseKey:e=>J.a.createSecretKey(e)};function H(e){return(t,n)=>t&&n?e(t,n):e}function Q(e,t=z){const n=t.deserialiseKey(e);return H((e,r)=>new _(r,e,{wrap:(e,r)=>t.encrypt(n,i(r)),unwrap:async(e,r)=>s(await t.decrypt(n,r))}))}function X(e,t=0,n=z){const r=new G(t),i=async(t,i)=>{const{id:s}=i;if(void 0===s)throw new Error("Must provide ID for encryption");const o=r.get(s);if(o)return o;let a;const c=await e.get("id",s,["key"]);if(c)a=n.deserialiseKey(c.key);else{if(!t)throw new Error("No encryption key found for record");a=await n.generateKey(),await e.add({id:s,key:n.serialiseKey(a)})}return r.set(s,a),a},s=async({id:t})=>{await e.remove("id",t),r.remove(t)};return H((e,t)=>new _(t,e,{wrap:(e,t,r)=>n.encrypt(r,JSON.stringify(t)),unwrap:async(e,t,r)=>JSON.parse(await n.decrypt(r,t)),preWrap:i.bind(null,!0),preUnwrap:i.bind(null,!1),preRemove:s}))}function Z(e,t,n=0,r=z){return X(Q(e,r)()(["key"],t),n,r)}n(6),n(7);n.d(t,"MemoryDb",(function(){return d})),n.d(t,"MongoDb",(function(){return K})),n.d(t,"RedisDb",(function(){return L})),n.d(t,"LruCache",(function(){return G})),n.d(t,"WrappedCollection",(function(){return _})),n.d(t,"encryptByKey",(function(){return Q})),n.d(t,"encryptByRecord",(function(){return X})),n.d(t,"encryptByRecordWithMasterKey",(function(){return Z})),n.d(t,"nodeEncryptionSync",(function(){return z}));t.default=class{static async connect(e){let t;if(e.startsWith("memory"))t=d;else if(e.startsWith("mongodb"))t=K;else{if(!e.startsWith("redis"))throw new Error(`Unsupported database connection string: ${e}`);t=L}try{return await t.connect(e)}catch(t){throw new Error(`Failed to connect to database "${e}": ${t.message}`)}}}}])}));
//# sourceMappingURL=index.js.map