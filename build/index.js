!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define("websocket-express",[],e):"object"==typeof exports?exports["websocket-express"]=e():t["websocket-express"]=e()}(global,function(){return function(t){var e={};function n(r){if(e[r])return e[r].exports;var i=e[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=t,n.c=e,n.d=function(t,e,r){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)n.d(r,i,function(e){return t[e]}.bind(null,i));return r},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=1)}([function(t,e){t.exports=require("url")},function(t,e,n){t.exports=n(5)},function(t,e){t.exports=require("mongodb")},function(t,e){},function(t,e){},function(t,e,n){"use strict";n.r(e);var r=n(0);function i(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t){return t?new Promise(e=>setTimeout(e,t)):null}class s{constructor(t={},e=0){this.simulatedLatency=e,i(this,"data",void 0),i(this,"keyList",[]),i(this,"keys",{}),this.data=new Map,Object.keys(t).forEach(e=>{const n=e;this.keyList.push(n),this.keys[n]={map:new Map,options:t[n]}})}async add(t){await o(this.simulatedLatency),this.internalCheckDuplicates(t,!0),this.data.set(t.id,JSON.stringify(t)),this.internalPopulateIndices(t)}async update(t,e,n,{upsert:r=!1}={}){await o(this.simulatedLatency);const i=this.internalGetIds(t,e)[0];if(void 0===i)return void(r&&await this.add(Object.assign({[t]:e},n)));const s=JSON.parse(this.data.get(i)),a=Object.assign({},s,n);if(a.id!==s.id)throw new Error("Cannot update id");this.internalRemoveIndices(s);try{this.internalCheckDuplicates(a,!1)}catch(t){throw this.internalPopulateIndices(s),t}this.data.set(a.id,JSON.stringify(a)),this.internalPopulateIndices(a)}async get(t,e,n){const r=await this.getAll(t,e,n);return r.length?r[0]:null}async getAll(t,e,n){let r;return await o(this.simulatedLatency),(r=t?this.internalGetIds(t,e):[...this.data.keys()]).map(t=>(function(t,e){if(!e)return t;const n={};return e.forEach(e=>{n[e]=t[e]}),n})(JSON.parse(this.data.get(t)),n))}internalGetIds(t,e){if("id"===t){const t=e;return this.data.has(t)?[t]:[]}const n=this.keys[t];if(!n)throw new Error(`Requested key ${t} not indexed`);const r=n.map.get(e);return r?[...r]:[]}internalCheckDuplicates(t,e){if(e&&this.data.has(t.id))throw new Error("duplicate");this.keyList.forEach(e=>{const{map:n,options:r}=this.keys[e];if(r.unique&&n.has(t[e]))throw new Error("duplicate")})}internalPopulateIndices(t){this.keyList.forEach(e=>{const{map:n}=this.keys[e],r=t[e];let i=n.get(r);i||(i=new Set,n.set(r,i)),i.add(t.id)})}internalRemoveIndices(t){this.keyList.forEach(e=>{const{map:n}=this.keys[e],r=t[e],i=n.get(r);i.delete(t.id),i.size||n.delete(r)})}}function a(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}const c=function(t,e){const n=global[t];return n||(global[t]=e,e)}("collectionStorageInMemory",new Map);class u{constructor({simulatedLatency:t=0}={}){a(this,"simulatedLatency",void 0),a(this,"mapTables",new Map),this.simulatedLatency=t}static connect(t){const e=new r.URL(t),n=e.hostname;if(n&&c.has(n))return c.get(n);const i=e.searchParams,o=Number(i.get("simulatedLatency")),s=new u({simulatedLatency:o});return n&&c.set(n,s),s}getCollection(t,e){return this.mapTables.has(t)||this.mapTables.set(t,new s(e,this.simulatedLatency)),this.mapTables.get(t)}}function l(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable})),n.push.apply(n,r)}return n}function f(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?l(n,!0).forEach(function(e){d(t,e,n[e])}):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):l(n).forEach(function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))})}return t}function d(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function p(t,e){if(null==t)return{};var n,r,i=function(t,e){if(null==t)return{};var n,r,i={},o=Object.keys(t);for(r=0;r<o.length;r++)n=o[r],e.indexOf(n)>=0||(i[n]=t[n]);return i}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(r=0;r<o.length;r++)n=o[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(i[n]=t[n])}return i}function h(t){var e=function(t,e){if("object"!=typeof t||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var r=n.call(t,e||"default");if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"==typeof e?e:String(e)}const y="_id",b="id";function m(t){return t===b?y:t}function g(t){if(!t||void 0===t[b])return t;const{[b]:e}=t,n=p(t,[b].map(h));return f({[y]:e},n)}function w(t){if(!t||void 0===t[y])return t;const{[y]:e}=t,n=p(t,[y].map(h));return f({[b]:e},n)}function O(t){const e={};return t&&(e[y]=!1,t.forEach(t=>{e[m(t)]=!0})),e}class v{constructor(t,e={}){this.collection=t,Object.keys(e).forEach(n=>{const r=n,i=e[r];i&&i.unique?t.createIndex({[r]:1},{unique:!0}):t.createIndex({[r]:"hashed"})})}async add(t){await this.collection.insertOne(g(t))}async update(t,e,n,{upsert:r=!1}={}){await this.collection.updateOne({[m(t)]:e},{$set:g(n)},{upsert:r})}async get(t,e,n){return w(await this.collection.findOne({[m(t)]:e},{projection:O(n)}))}async getAll(t,e,n){const r=[];let i;const o=O(n);return i=t?this.collection.find({[m(t)]:e},{projection:o}):this.collection.find({},{projection:o}),await i.forEach(t=>r.push(w(t))),r}}class j{constructor(t){this.db=t}static async connect(t){const{MongoClient:e}=await Promise.resolve().then(()=>n(2)),r=await e.connect(t,{useNewUrlParser:!0,useUnifiedTopology:!0});return new j(r.db())}getCollection(t,e){const n=this.db.collection(t);return new v(n,e)}}n(3),n(4);n.d(e,"MemoryDb",function(){return u}),n.d(e,"MongoDb",function(){return j});e.default=class{static async connect(t){let e;if(t.startsWith("memory"))e=u;else{if(!t.startsWith("mongodb"))throw new Error(`Unsupported database connection string: ${t}`);e=j}try{return await e.connect(t)}catch(e){throw new Error(`Failed to connect to database "${t}": ${e.message}`)}}}}])});
//# sourceMappingURL=index.js.map