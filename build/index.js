!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define("websocket-express",[],e):"object"==typeof exports?exports["websocket-express"]=e():t["websocket-express"]=e()}(global,function(){return function(t){var e={};function n(r){if(e[r])return e[r].exports;var i=e[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=t,n.c=e,n.d=function(t,e,r){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)n.d(r,i,function(e){return t[e]}.bind(null,i));return r},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=1)}([function(t,e){t.exports=require("url")},function(t,e,n){t.exports=n(3)},function(t,e){t.exports=require("mongodb")},function(t,e,n){"use strict";n.r(e);var r=n(0);function i(t){return t?new Promise(e=>setTimeout(e,t)):null}class o{constructor(t={},e=0){this.data=new Map,this.keys=new Map,this.simulatedLatency=e,Object.keys(t).forEach(e=>{this.keys.set(e,{map:new Map,options:t[e]})})}internalGetIds(t,e){if("id"===t)return this.data.has(e)?[e]:[];const n=this.keys.get(t);if(!n)throw new Error(`Requested key ${t} not indexed`);const r=n.map.get(e);return r?[...r]:[]}internalCheckDuplicates(t,e){if(e&&this.data.has(t.id))throw new Error("duplicate");this.keys.forEach(({map:e,options:n},r)=>{if(n.unique&&e.has(t[r]))throw new Error("duplicate")})}internalPopulateIndices(t){this.keys.forEach(({map:e},n)=>{const r=t[n];let i=e.get(r);i||(i=new Set,e.set(r,i)),i.add(t.id)})}internalRemoveIndices(t){this.keys.forEach(({map:e},n)=>{const r=t[n],i=e.get(r);i.delete(t.id),i.length||e.delete(r)})}async add(t){await i(this.simulatedLatency),this.internalCheckDuplicates(t,!0),this.data.set(t.id,JSON.stringify(t)),this.internalPopulateIndices(t)}async update(t,e,n,{upsert:r=!1}={}){await i(this.simulatedLatency);const o=this.internalGetIds(t,e)[0];if(void 0===o)return void(r&&await this.add(Object.assign({[t]:e},n)));const s=JSON.parse(this.data.get(o)),a=Object.assign({},s,n);if(a.id!==s.id)throw new Error("Cannot update id");this.internalRemoveIndices(s);try{this.internalCheckDuplicates(n,!1)}catch(t){throw this.internalPopulateIndices(s),t}this.data.set(a.id,JSON.stringify(a)),this.internalPopulateIndices(a)}async get(t,e,n=null){const r=await this.getAll(t,e,n);return r.length?r[0]:null}async getAll(t,e,n=null){let r;return await i(this.simulatedLatency),(r=t?this.internalGetIds(t,e):[...this.data.keys()]).map(t=>(function(t,e){if(!e)return t;const n={};return e.forEach(e=>{n[e]=t[e]}),n})(JSON.parse(this.data.get(t)),n))}}global.collectionStorageInMemory||(global.collectionStorageInMemory=new Map);const s=global.collectionStorageInMemory;class a{static connect(t){const e=new r.URL(t),n=e.hostname;if(n&&s.has(n))return s.get(n);const i=e.searchParams,o=Number(i.get("simulatedLatency")),c=new a({simulatedLatency:o});return n&&s.set(n,c),c}constructor({simulatedLatency:t=0}={}){this.simulatedLatency=t,this.mapTables=new Map}getCollection(t,e){return this.mapTables.has(t)||this.mapTables.set(t,new o(e,this.simulatedLatency)),this.mapTables.get(t)}}const c="_id",l="id";function u(t){return t===l?c:t}function d(t){if(!t||void 0===t[l])return t;const{[l]:e,...n}=t;return{[c]:e,...n}}function h(t){if(!t||void 0===t[c])return t;const{[c]:e,...n}=t;return{[l]:e,...n}}function f(t){const e={};return t&&(e[c]=!1,t.forEach(t=>{e[u(t)]=!0})),e}class p{constructor(t,e={}){this.collection=t,Object.keys(e).forEach(n=>{e[n].unique?t.createIndex({[n]:1},{unique:!0}):t.createIndex({[n]:"hashed"})})}async add(t){await this.collection.insertOne(d(t))}async update(t,e,n,{upsert:r=!1}={}){await this.collection.updateOne({[u(t)]:e},{$set:d(n)},{upsert:r})}async get(t,e,n=null){return h(await this.collection.findOne({[u(t)]:e},{projection:f(n)}))}async getAll(t,e,n=null){const r=[];let i;const o=f(n);return i=t?await this.collection.find({[u(t)]:e},{projection:o}):await this.collection.find({},{projection:o}),await i.forEach(t=>r.push(h(t))),r}}class y{static async connect(t){const{MongoClient:e}=await Promise.resolve().then(()=>n(2)),r=await e.connect(t,{useNewUrlParser:!0});return new y(r.db())}constructor(t){this.db=t}getCollection(t,e){const n=this.db.collection(t);return new p(n,e)}}n.d(e,"MemoryDb",function(){return a}),n.d(e,"MongoDb",function(){return y});e.default=class{static async connect(t){let e;if(t.startsWith("memory"))e=a;else{if(!t.startsWith("mongodb"))throw new Error(`Unsupported database connection string: ${t}`);e=y}try{return await e.connect(t)}catch(e){throw new Error(`Failed to connect to database "${t}": ${e.message}`)}}}}])});
//# sourceMappingURL=index.js.map