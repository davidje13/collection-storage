!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("websocket-express",[],t):"object"==typeof exports?exports["websocket-express"]=t():e["websocket-express"]=t()}(global,function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=3)}([function(e,t){e.exports=require("crypto")},function(e,t){e.exports=require("mongodb")},function(e,t){e.exports=require("url")},function(e,t,r){e.exports=r(7)},function(e,t){},function(e,t){},function(e,t){},function(e,t,r){"use strict";r.r(t);var n=r(2);function i(e){return e instanceof Buffer?`B${e.toString("base64")}`:`J${JSON.stringify(e)}`}function a(e){const t=e[0],r=e.substr(1);if("B"===t)return Buffer.from(r,"base64");if("J"===t)return JSON.parse(r);throw new Error("Unknown data type")}function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e){return e?new Promise(t=>setTimeout(t,e)):null}function c(e){const t={};return Object.keys(e).forEach(r=>{t[r]=i(e[r])}),t}function l(e){const t={};return Object.keys(e).forEach(r=>{t[r]=a(e[r])}),t}class u{constructor(e={},t=0){this.simulatedLatency=t,o(this,"data",void 0),o(this,"keys",{}),this.data=new Map,Object.keys(e).forEach(t=>{const r=t;this.keys[r]={map:new Map,options:e[r]}})}async add(e){await s(this.simulatedLatency);const t=c(e);this.internalCheckDuplicates(t,!0),this.data.set(t.id,t),this.internalPopulateIndices(t)}async update(e,t,r,{upsert:n=!1}={}){await s(this.simulatedLatency);const i=this.internalGetSerialisedIds(e,t)[0];if(void 0===i)return void(n&&await this.add(Object.assign({[e]:t},r)));const a=this.data.get(i),o=l(a),u=Object.assign({},o,r);if(u.id!==o.id)throw new Error("Cannot update id");const p=c(u);this.internalRemoveIndices(a);try{this.internalCheckDuplicates(p,!1)}catch(e){throw this.internalPopulateIndices(a),e}this.data.set(p.id,p),this.internalPopulateIndices(p)}async get(e,t,r){const n=await this.getAll(e,t,r);return n.length?n[0]:null}async getAll(e,t,r){let n;return await s(this.simulatedLatency),(n=e?this.internalGetSerialisedIds(e,t):[...this.data.keys()]).map(e=>(function(e,t){if(!t)return e;const r={};return t.forEach(t=>{r[t]=e[t]}),r})(l(this.data.get(e)),r))}async remove(e,t){await s(this.simulatedLatency);const r=this.internalGetSerialisedIds(e,t);return r.forEach(e=>{const t=this.data.get(e);this.internalRemoveIndices(t),this.data.delete(e)}),r.length}internalGetSerialisedIds(e,t){const r=i(t);if("id"===e)return this.data.has(r)?[r]:[];const n=this.keys[e];if(!n)throw new Error(`Requested key ${e} not indexed`);const a=n.map.get(r);return a?[...a]:[]}internalCheckDuplicates(e,t){if(t&&this.data.has(e.id))throw new Error("duplicate");Object.entries(this.keys).forEach(([t,r])=>{const{map:n,options:i}=r;if(i.unique&&n.has(e[t]))throw new Error("duplicate")})}internalPopulateIndices(e){Object.entries(this.keys).forEach(([t,r])=>{const{map:n}=r,i=e[t];let a=n.get(i);a||(a=new Set,n.set(i,a)),a.add(e.id)})}internalRemoveIndices(e){Object.entries(this.keys).forEach(([t,r])=>{const{map:n}=r,i=e[t],a=n.get(i);a.delete(e.id),a.size||n.delete(i)})}}function p(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}const d=function(e,t){const r=global[e];return r||(global[e]=t,t)}("collectionStorageInMemory",new Map);class f{constructor({simulatedLatency:e=0}={}){p(this,"simulatedLatency",void 0),p(this,"mapTables",new Map),this.simulatedLatency=e}static connect(e){const t=new n.URL(e),r=t.hostname;if(r&&d.has(r))return d.get(r);const i=t.searchParams,a=Number(i.get("simulatedLatency")),o=new f({simulatedLatency:a});return r&&d.set(r,o),o}getCollection(e,t){return this.mapTables.has(e)||this.mapTables.set(e,new u(t,this.simulatedLatency)),this.mapTables.get(e)}}var h=r(1);function y(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),r.push.apply(r,n)}return r}function w(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?y(r,!0).forEach(function(t){b(e,t,r[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):y(r).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))})}return e}function b(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function g(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}function m(e){var t=function(e,t){if("object"!=typeof e||null===e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||"default");if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==typeof t?t:String(t)}const v="_id",O="id";function j(e){let t;if(void 0===e[O])t=Object.assign({},e);else{const{[O]:r}=e,n=g(e,[O].map(m));t=w({[v]:r},n)}return Object.keys(t).forEach(e=>{const r=t[e];if(r instanceof Buffer&&(t[e]=new h.Binary(r)),"object"==typeof r&&r._bsontype)throw new Error("Must use Buffer to provide binary data")}),t}function P(e){if(!e)return null;let t;if(void 0===e[v])t=Object.assign({},e);else{const{[v]:r}=e,n=g(e,[v].map(m));t=w({[O]:r},n)}return Object.keys(t).forEach(e=>{const r=t[e];"object"==typeof r&&"Binary"===r._bsontype&&(t[e]=r.buffer)}),t}function E(e){const t={};return e&&(t[v]=!1,e.forEach(e=>{t[function(e){return e===O?v:e}(e)]=!0})),t}class k{constructor(e,t={}){this.collection=e,Object.keys(t).forEach(r=>{const n=r,i=t[n];i&&i.unique?e.createIndex({[n]:1},{unique:!0}):e.createIndex({[n]:"hashed"})})}async add(e){await this.collection.insertOne(j(e))}async update(e,t,r,{upsert:n=!1}={}){await this.collection.updateOne(j({[e]:t}),{$set:j(r)},{upsert:n})}async get(e,t,r){return P(await this.collection.findOne(j({[e]:t}),{projection:E(r)}))}async getAll(e,t,r){const n=[];let i;const a=E(r);return i=e?this.collection.find(j({[e]:t}),{projection:a}):this.collection.find({},{projection:a}),await i.forEach(e=>n.push(P(e))),n}async remove(e,t){return(await this.collection.deleteMany(j({[e]:t}))).deletedCount||0}}class S{constructor(e){this.db=e}static async connect(e){const{MongoClient:t}=await Promise.resolve().then(()=>r(1)),n=await t.connect(e,{useNewUrlParser:!0,useUnifiedTopology:!0});return new S(n.db())}getCollection(e,t){const r=this.db.collection(e);return new k(r,t)}}function x(e,t){return t.some(t=>Object.prototype.hasOwnProperty.call(e,t))}class C{constructor(e,t,r){this.baseCollection=e,this.fields=t,this.wrapper=r}async add(e){return this.baseCollection.add(await this.wrapAll(e))}async get(e,t,r){if(this.fields.includes(e))throw new Error("Cannot get by encrypted value");const n=await this.baseCollection.get(e,t,r);return n?this.unwrapAll(n,{[e]:t}):null}async getAll(e,t,r){if(void 0!==e&&this.fields.includes(e))throw new Error("Cannot get by encrypted value");const n=await this.baseCollection.getAll(e,t,r),i=void 0!==e?{[e]:t}:void 0;return Promise.all(n.map(e=>this.unwrapAll(e,i)))}async update(e,t,r,n){if(this.fields.includes(e))throw new Error("Cannot update by encrypted value");const i=await this.wrapAll(r,{[e]:t});return this.baseCollection.update(e,t,i,n)}async remove(e,t){if(this.fields.includes(e))throw new Error("Cannot remove by encrypted value");if(!this.wrapper.preRemove)return this.baseCollection.remove(e,t);const r=await this.baseCollection.getAll(e,t,["id"]);return await Promise.all(r.map(async e=>{await this.wrapper.preRemove(e),await this.baseCollection.remove("id",e.id)})),r.length}async wrapAll(e,t){let r;if(this.wrapper.preWrap&&x(e,this.fields)){const n=t?Object.assign({},t,e):e;r=await this.wrapper.preWrap(n)}const n=Object.assign({},e);return await Promise.all(this.fields.map(async t=>{Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=await this.wrapper.wrap(t,e[t],r))})),n}async unwrapAll(e,t){let r;if(this.wrapper.preUnwrap&&x(e,this.fields)){const n=t?Object.assign({},t,e):e;r=await this.wrapper.preUnwrap(n)}const n=Object.assign({},e);return await Promise.all(this.fields.map(async t=>{Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=await this.wrapper.unwrap(t,e[t],r))})),n}}r(4);class M{constructor(e){var t,r,n;this.capacity=e,t=this,r="storage",n=new Map,r in t?Object.defineProperty(t,r,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[r]=n}set(e,t){this.storage.delete(e),this.storage.set(e,t),this.flush()}get(e){const t=this.storage.get(e);return this.storage.delete(e)&&this.storage.set(e,t),t}remove(e){this.storage.delete(e)}flush(){for(;this.storage.size>this.capacity;)this.storage.delete(this.storage.keys().next().value)}}var B=r(0),I=r.n(B);const L="aes-256-cbc",A=Buffer.from(L,"utf8");var D={encrypt:(e,t)=>{const r=I.a.randomBytes(16),n=I.a.createCipheriv(L,e,r),i=n.update(t,"utf8"),a=n.final();return Buffer.concat([A,r,i,a])},decrypt:(e,t)=>{if(!t.slice(0,A.length).equals(A))throw new Error("Unknown encryption algorithm");const r=t.slice(A.length,A.length+16),n=t.slice(A.length+16),i=I.a.createDecipheriv(L,e,r);let a=i.update(n,void 0,"utf8");return a+=i.final("utf8")},generateKey:()=>I.a.createSecretKey(I.a.randomBytes(32)),serialiseKey:e=>e.export().toString("base64"),deserialiseKey:e=>I.a.createSecretKey(Buffer.from(e,"base64"))};const K=(e,t=D)=>(r,n)=>{const o=t.deserialiseKey(e);return new C(n,r,{wrap:(e,r)=>t.encrypt(o,i(r)),unwrap:async(e,r)=>a(await t.decrypt(o,r))})},R=(e,t=0,r=D)=>(n,i)=>{const a=new M(t),o=async(t,n)=>{const{id:i}=n;if(void 0===i)throw new Error("Must provide ID for encryption");const o=a.get(i);if(o)return o;let s;const c=await e.get("id",i,["key"]);if(c)s=r.deserialiseKey(c.key);else{if(!t)throw new Error("No encryption key found for record");s=await r.generateKey(),await e.add({id:i,key:r.serialiseKey(s)})}return a.set(i,s),s};return new C(i,n,{wrap:(e,t,n)=>r.encrypt(n,JSON.stringify(t)),unwrap:async(e,t,n)=>JSON.parse(await r.decrypt(n,t)),preWrap:o.bind(null,!0),preUnwrap:o.bind(null,!1),preRemove:async({id:t})=>{await e.remove("id",t),a.remove(t)}})},T=(e,t,r=0,n=D)=>(i,a)=>R(K(e,n)(["key"],t),r,n)(i,a);r(5),r(6);r.d(t,"MemoryDb",function(){return f}),r.d(t,"MongoDb",function(){return S}),r.d(t,"LruCache",function(){return M}),r.d(t,"WrappedCollection",function(){return C}),r.d(t,"encryptByKey",function(){return K}),r.d(t,"encryptByRecord",function(){return R}),r.d(t,"encryptByRecordWithMasterKey",function(){return T}),r.d(t,"nodeEncryptionSync",function(){return D});t.default=class{static async connect(e){let t;if(e.startsWith("memory"))t=f;else{if(!e.startsWith("mongodb"))throw new Error(`Unsupported database connection string: ${e}`);t=S}try{return await t.connect(e)}catch(t){throw new Error(`Failed to connect to database "${e}": ${t.message}`)}}}}])});
//# sourceMappingURL=index.js.map