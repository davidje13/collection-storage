!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("websocket-express",[],t):"object"==typeof exports?exports["websocket-express"]=t():e["websocket-express"]=t()}(global,(function(){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var i=t[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(r,i,function(t){return e[t]}.bind(null,i));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=3)}([function(e,t){e.exports=require("crypto")},function(e,t){e.exports=require("mongodb")},function(e,t){e.exports=require("url")},function(e,t,n){e.exports=n(8)},function(e,t){e.exports=require("ioredis")},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){"use strict";n.r(t);var r=n(2);function i(e){return e instanceof Buffer?`B${e.toString("base64")}`:`J${JSON.stringify(e)}`}function s(e){const t=e[0],n=e.substr(1);if("B"===t)return Buffer.from(n,"base64");if("J"===t)return JSON.parse(n);throw new Error("Unknown data type")}function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e){return e?new Promise(t=>setTimeout(t,e)):null}function c(e){const t={};return Object.keys(e).forEach(n=>{t[n]=i(e[n])}),t}function l(e){const t={};return Object.keys(e).forEach(n=>{t[n]=s(e[n])}),t}class u{constructor(e={},t=0){this.simulatedLatency=t,a(this,"data",void 0),a(this,"keys",{}),this.data=new Map,Object.keys(e).forEach(t=>{const n=t;this.keys[n]={map:new Map,options:e[n]}})}async add(e){await o(this.simulatedLatency);const t=c(e);this.internalCheckDuplicates(t,!0),this.data.set(t.id,t),this.internalPopulateIndices(t)}async update(e,t,n,{upsert:r=!1}={}){await o(this.simulatedLatency);const i=this.internalGetSerialisedIds(e,t)[0];if(void 0===i)return void(r&&await this.add(Object.assign({[e]:t},n)));const s=this.data.get(i),a=l(s),u=Object.assign({},a,n);if(u.id!==a.id)throw new Error("Cannot update id");const d=c(u);this.internalRemoveIndices(s);try{this.internalCheckDuplicates(d,!1)}catch(e){throw this.internalPopulateIndices(s),e}this.data.set(d.id,d),this.internalPopulateIndices(d)}async get(e,t,n){const r=await this.getAll(e,t,n);return r.length?r[0]:null}async getAll(e,t,n){let r;return await o(this.simulatedLatency),(r=e?this.internalGetSerialisedIds(e,t):[...this.data.keys()]).map(e=>(function(e,t){if(!t)return e;const n={};return t.forEach(t=>{n[t]=e[t]}),n})(l(this.data.get(e)),n))}async remove(e,t){await o(this.simulatedLatency);const n=this.internalGetSerialisedIds(e,t);return n.forEach(e=>{const t=this.data.get(e);this.internalRemoveIndices(t),this.data.delete(e)}),n.length}internalGetSerialisedIds(e,t){const n=i(t);if("id"===e)return this.data.has(n)?[n]:[];const r=this.keys[e];if(!r)throw new Error(`Requested key ${e} not indexed`);const s=r.map.get(n);return s?[...s]:[]}internalCheckDuplicates(e,t){if(t&&this.data.has(e.id))throw new Error("duplicate");Object.entries(this.keys).forEach(([t,n])=>{const{map:r,options:i}=n;if(i.unique&&r.has(e[t]))throw new Error("duplicate")})}internalPopulateIndices(e){Object.entries(this.keys).forEach(([t,n])=>{const{map:r}=n,i=e[t];let s=r.get(i);s||(s=new Set,r.set(i,s)),s.add(e.id)})}internalRemoveIndices(e){Object.entries(this.keys).forEach(([t,n])=>{const{map:r}=n,i=e[t],s=r.get(i);s.delete(e.id),s.size||r.delete(i)})}}function d(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}const h=function(e,t){const n=global[e];return n||(global[e]=t,t)}("collectionStorageInMemory",new Map);class f{constructor({simulatedLatency:e=0}={}){d(this,"simulatedLatency",void 0),d(this,"mapTables",new Map),this.simulatedLatency=e}static connect(e){const t=new r.URL(e),n=t.hostname;if(n&&h.has(n))return h.get(n);const i=t.searchParams,s=Number(i.get("simulatedLatency")),a=new f({simulatedLatency:s});return n&&h.set(n,a),a}getCollection(e,t){return this.mapTables.has(e)||this.mapTables.set(e,new u(t,this.simulatedLatency)),this.mapTables.get(e)}}var y=n(1);function p(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function w(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?p(n,!0).forEach((function(t){b(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):p(n).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function b(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function m(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}function g(e){var t=function(e,t){if("object"!=typeof e||null===e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var r=n.call(e,t||"default");if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==typeof t?t:String(t)}const v="_id",O="id";function j(e){let t;if(void 0===e[O])t=Object.assign({},e);else{const{[O]:n}=e,r=m(e,[O].map(g));t=w({[v]:n},r)}return Object.keys(t).forEach(e=>{const n=t[e];if(n instanceof Buffer&&(t[e]=new y.Binary(n)),"object"==typeof n&&n._bsontype)throw new Error("Must use Buffer to provide binary data")}),t}function k(e){if(!e)return null;let t;if(void 0===e[v])t=Object.assign({},e);else{const{[v]:n}=e,r=m(e,[v].map(g));t=w({[O]:n},r)}return Object.keys(t).forEach(e=>{const n=t[e];"object"==typeof n&&"Binary"===n._bsontype&&(t[e]=n.buffer)}),t}function P(e){const t={};return e&&(t[v]=!1,e.forEach(e=>{t[function(e){return e===O?v:e}(e)]=!0})),t}class E{constructor(e,t={}){this.collection=e,Object.keys(t).forEach(n=>{const r=n,i=t[r];i&&i.unique?e.createIndex({[r]:1},{unique:!0}):e.createIndex({[r]:"hashed"})})}async add(e){await this.collection.insertOne(j(e))}async update(e,t,n,{upsert:r=!1}={}){await this.collection.updateOne(j({[e]:t}),{$set:j(n)},{upsert:r})}async get(e,t,n){return k(await this.collection.findOne(j({[e]:t}),{projection:P(n)}))}async getAll(e,t,n){const r=[];let i;const s=P(n);return i=e?this.collection.find(j({[e]:t}),{projection:s}):this.collection.find({},{projection:s}),await i.forEach(e=>r.push(k(e))),r}async remove(e,t){return(await this.collection.deleteMany(j({[e]:t}))).deletedCount||0}}class x{constructor(e){this.db=e}static async connect(e){const{MongoClient:t}=await Promise.resolve().then(()=>n(1)),r=await t.connect(e,{useNewUrlParser:!0,useUnifiedTopology:!0});return new x(r.db())}getCollection(e,t){const n=this.db.collection(e);return new E(n,t)}}function K(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function S(e){const t={};return Object.keys(e).forEach(n=>{t[n]=i(e[n])}),t}function C(e){const t={};return Object.keys(e).forEach(n=>{t[n]=s(e[n])}),t}class M{constructor(e,t,n={}){this.client=e,this.prefix=t,K(this,"keyPrefixes",{}),K(this,"keys",[]),K(this,"uniqueKeys",[]),Object.keys(n).forEach(e=>{const r=e,i=`${t}-${r}`;this.keyPrefixes[r]=i;const s={key:r,prefix:i};this.keys.push(s),n[r].unique&&this.uniqueKeys.push(s)})}async add(e){const t=S(e);if(await this.client.exists(this.makeKey(t.id)))throw new Error("duplicate");await this.internalCheckKeyDuplicates(t.id,t),await this.runMulti([this.setByKey(t.id,t),...this.internalMigrateIndices(t.id,{},t)])}async update(e,t,n,{upsert:r=!1}={}){const i=S(n),s=(await this.internalGetPossibleSerialisedIds(e,t))[0];if(i.id&&i.id!==s)throw new Error("Cannot update id");const a=await this.readByKey(s,Object.keys(n));a?(await this.internalCheckKeyDuplicates(s,i),await this.runMulti([this.setByKey(s,i),...this.internalMigrateIndices(s,a,i)])):r&&await this.add(Object.assign({[e]:t},n))}async get(e,t,n){const r=(await this.internalGetPossibleSerialisedIds(e,t))[0],i=await this.readByKey(r,n);return i?C(i):null}async getAll(e,t,n){let r;if(e)r=await this.internalGetPossibleSerialisedIds(e,t);else{r=await this.client.keys(this.makeKey("*"));const e=this.prefix.length+1;r=r.map(t=>t.substr(e))}return(await this.readByKeys(r,n)).map(C)}async remove(e,t){const n=Object.keys(this.keyPrefixes);n.push("id");const r=await this.internalGetPossibleSerialisedIds(e,t),i=await this.readByKeys(r,n);return 0===i.length?0:(await this.runMulti([["del",...i.map(e=>this.makeKey(e.id))],...i.flatMap(e=>this.internalMigrateIndices(e.id,e,{}))]),i.length)}makeKey(e){return`${this.prefix}:${e}`}setByKey(e,t){return["hmset",this.makeKey(e),...Object.entries(t).flat()]}getByKey(e,t){const n=this.makeKey(e);return t?["hmget",n,...t]:["hgetall",n]}async readByKey(e,t){if(void 0===e)return;return(await this.readByKeys([e],t))[0]}async readByKeys(e,t){const n=await this.runMulti(e.map(e=>this.getByKey(e,t)));let r;return(r=t?n.map(([,e])=>{const n={};for(let r=0;r<t.length;r+=1)n[t[r]]=e[r];return n}):n.map(([,e])=>e)).filter(e=>Object.values(e).some(e=>null!==e))}async internalGetPossibleSerialisedIds(e,t){const n=i(t);if("id"===e)return[n];const r=this.keyPrefixes[e];if(!r)throw new Error(`Requested key ${e} not indexed`);return this.client.smembers(`${r}:${n}`)}async internalCheckKeyDuplicates(e,t){if((await this.runMulti(this.uniqueKeys.filter(({key:e})=>t[e]).map(({key:e,prefix:n})=>["smembers",`${n}:${t[e]}`]))).some(([,t])=>t.length>0&&t[0]!==e))throw new Error("duplicate")}internalMigrateIndices(e,t,n){return this.keys.map(({key:r,prefix:i})=>n[r]?t[r]?["smove",`${i}:${t[r]}`,`${i}:${n[r]}`,e]:["sadd",`${i}:${n[r]}`,e]:t[r]?["srem",`${i}:${t[r]}`,e]:null)}async runMulti(e){const t=e.filter(e=>null!==e);return t.length?this.client.multi(t).exec():[]}}class B{constructor(e){this.client=e}static async connect(e){const{default:t}=await Promise.resolve().then(()=>n(4)),r=new t(e,{lazyConnect:!0});return await r.connect(),new B(r)}getCollection(e,t){return new M(this.client,e,t)}}function I(e,t){return t.some(t=>Object.prototype.hasOwnProperty.call(e,t))}class ${constructor(e,t,n){this.baseCollection=e,this.fields=t,this.wrapper=n}async add(e){return this.baseCollection.add(await this.wrapAll(e))}async get(e,t,n){if(this.fields.includes(e))throw new Error("Cannot get by encrypted value");const r=await this.baseCollection.get(e,t,n);return r?this.unwrapAll(r,{[e]:t}):null}async getAll(e,t,n){if(void 0!==e&&this.fields.includes(e))throw new Error("Cannot get by encrypted value");const r=await this.baseCollection.getAll(e,t,n),i=void 0!==e?{[e]:t}:void 0;return Promise.all(r.map(e=>this.unwrapAll(e,i)))}async update(e,t,n,r){if(this.fields.includes(e))throw new Error("Cannot update by encrypted value");const i=await this.wrapAll(n,{[e]:t});return this.baseCollection.update(e,t,i,r)}async remove(e,t){if(this.fields.includes(e))throw new Error("Cannot remove by encrypted value");if(!this.wrapper.preRemove)return this.baseCollection.remove(e,t);const n=await this.baseCollection.getAll(e,t,["id"]);return await Promise.all(n.map(async e=>{await this.wrapper.preRemove(e),await this.baseCollection.remove("id",e.id)})),n.length}async wrapAll(e,t){let n;if(this.wrapper.preWrap&&I(e,this.fields)){const r=t?Object.assign({},t,e):e;n=await this.wrapper.preWrap(r)}const r=Object.assign({},e);return await Promise.all(this.fields.map(async t=>{Object.prototype.hasOwnProperty.call(e,t)&&(r[t]=await this.wrapper.wrap(t,e[t],n))})),r}async unwrapAll(e,t){let n;if(this.wrapper.preUnwrap&&I(e,this.fields)){const r=t?Object.assign({},t,e):e;n=await this.wrapper.preUnwrap(r)}const r=Object.assign({},e);return await Promise.all(this.fields.map(async t=>{Object.prototype.hasOwnProperty.call(e,t)&&(r[t]=await this.wrapper.unwrap(t,e[t],n))})),r}}n(5);class D{constructor(e){var t,n,r;this.capacity=e,t=this,n="storage",r=new Map,n in t?Object.defineProperty(t,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[n]=r}set(e,t){this.storage.delete(e),this.storage.set(e,t),this.flush()}get(e){const t=this.storage.get(e);return this.storage.delete(e)&&this.storage.set(e,t),t}remove(e){this.storage.delete(e)}flush(){for(;this.storage.size>this.capacity;)this.storage.delete(this.storage.keys().next().value)}}var q=n(0),A=n.n(q);const L="aes-256-cbc",R=Buffer.from(`${L}:`,"utf8");var G={encrypt:(e,t)=>{const n=A.a.randomBytes(16),r=A.a.createCipheriv(L,e,n),i=r.update(t,"utf8"),s=r.final();return Buffer.concat([R,n,i,s])},decrypt:(e,t)=>{if(!t.slice(0,R.length).equals(R))throw new Error("Unknown encryption algorithm");const n=t.slice(R.length,R.length+16),r=t.slice(R.length+16),i=A.a.createDecipheriv(L,e,n);let s=i.update(r,void 0,"utf8");return s+=i.final("utf8")},generateKey:()=>A.a.createSecretKey(A.a.randomBytes(32)),serialiseKey:e=>e.export(),deserialiseKey:e=>A.a.createSecretKey(e)};function T(e){return(t,n)=>t&&n?e(t,n):e}function U(e,t=G){const n=t.deserialiseKey(e);return T((e,r)=>new $(r,e,{wrap:(e,r)=>t.encrypt(n,i(r)),unwrap:async(e,r)=>s(await t.decrypt(n,r))}))}function _(e,t=0,n=G){const r=new D(t),i=async(t,i)=>{const{id:s}=i;if(void 0===s)throw new Error("Must provide ID for encryption");const a=r.get(s);if(a)return a;let o;const c=await e.get("id",s,["key"]);if(c)o=n.deserialiseKey(c.key);else{if(!t)throw new Error("No encryption key found for record");o=await n.generateKey(),await e.add({id:s,key:n.serialiseKey(o)})}return r.set(s,o),o},s=async({id:t})=>{await e.remove("id",t),r.remove(t)};return T((e,t)=>new $(t,e,{wrap:(e,t,r)=>n.encrypt(r,JSON.stringify(t)),unwrap:async(e,t,r)=>JSON.parse(await n.decrypt(r,t)),preWrap:i.bind(null,!0),preUnwrap:i.bind(null,!1),preRemove:s}))}function N(e,t,n=0,r=G){return _(U(e,r)()(["key"],t),n,r)}n(6),n(7);n.d(t,"MemoryDb",(function(){return f})),n.d(t,"MongoDb",(function(){return x})),n.d(t,"RedisDb",(function(){return B})),n.d(t,"LruCache",(function(){return D})),n.d(t,"WrappedCollection",(function(){return $})),n.d(t,"encryptByKey",(function(){return U})),n.d(t,"encryptByRecord",(function(){return _})),n.d(t,"encryptByRecordWithMasterKey",(function(){return N})),n.d(t,"nodeEncryptionSync",(function(){return G}));t.default=class{static async connect(e){let t;if(e.startsWith("memory"))t=f;else if(e.startsWith("mongodb"))t=x;else{if(!e.startsWith("redis"))throw new Error(`Unsupported database connection string: ${e}`);t=B}try{return await t.connect(e)}catch(t){throw new Error(`Failed to connect to database "${e}": ${t.message}`)}}}}])}));
//# sourceMappingURL=index.js.map