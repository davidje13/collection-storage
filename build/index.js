!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("collection-storage",[],t):"object"==typeof exports?exports["collection-storage"]=t():e["collection-storage"]=t()}(global,(function(){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var i=t[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(r,i,function(t){return e[t]}.bind(null,i));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=5)}([function(e,t,n){"use strict";function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}n.d(t,"a",(function(){return s}));class s{constructor(e){this.keys=e}async add(e){return await this.preAct(),this.internalAdd(e)}async get(e,t,n){if(!this.isIndexed(e))throw new Error("No index for "+e);return await this.preAct(),this.internalGet(e,t,n)}async getAll(e,t,n){if(e&&!this.isIndexed(e))throw new Error("No index for "+e);return await this.preAct(),this.internalGetAll(e,t,n)}async update(e,t,n,s={}){if("id"===e&&void 0!==n.id&&n.id!==t)throw new Error("Cannot update ID");if(s.upsert){if("id"!==e)throw new Error("Can only upsert by ID, not "+e);let o=n;return Object.prototype.hasOwnProperty.call(n,"id")&&(o=function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({},n),delete o.id),await this.preAct(),this.internalUpsert(t,o,s)}if(!this.isIndexed(e))throw new Error("No index for "+e);if(!this.isIndexUnique(e)&&Object.keys(n).some(e=>this.isIndexUnique(e)))throw new Error("duplicate");return await this.preAct(),this.internalUpdate(e,t,n,s)}async remove(e,t){if(!this.isIndexed(e))throw new Error("No index for "+e);return await this.preAct(),this.internalRemove(e,t)}isIndexed(e){return"id"===e||void 0!==this.keys[e]}isIndexUnique(e){const t=this.keys[e];return"id"===e||Boolean(t&&t.unique)}preAct(){}async internalGet(e,t,n){var r;return null!==(r=(await this.internalGetAll(e,t,n))[0])&&void 0!==r?r:null}internalUpsert(e,t,n){return this.internalUpdate("id",e,t,n)}}},function(e,t){e.exports=require("crypto")},function(e,t,n){"use strict";function r(e){return new Promise(t=>setTimeout(t,e))}t.a=(e,t=5,n=20,i=200,s=200)=>async o=>{for(let a=1;;a+=1){try{return await o()}catch(n){if(!e(n))throw n;if(a>=t)throw n.message+=` (attempted ${a} times)`,n}await r(n+a*i+Math.random()*s)}}},function(e,t){e.exports=require("mongodb")},function(e,t){e.exports=require("url")},function(e,t,n){e.exports=n(9)},function(e,t,n){"use strict";n.r(t),n.d(t,"default",(function(){return h}));var r=n(3),i=n(0),s=n(2);const o=/\./g;function a(e){return"id"===e?"_id":encodeURIComponent(e).replace(o,"%2E")}const c=Object(s.a)(e=>"object"==typeof e&&e.message.includes("E11000"));function l(e){const t={};return Object.keys(e).forEach(n=>{let i=e[n];if(i instanceof Buffer)i=new r.Binary(i);else if("object"==typeof i&&i._bsontype)throw new Error("Must use Buffer to provide binary data");t[a(n)]=i}),t}function u(e){if(!e)return null;const t={};return Object.keys(e).forEach(n=>{let r=e[n];var i;"object"==typeof r&&"Binary"===r._bsontype&&(r=r.buffer),t[(i=n,"_id"===i?"id":decodeURIComponent(i))]=r}),t}function d(e){const t={};return e&&(t._id=!1,e.forEach(e=>{t[a(e)]=!0})),t}class h extends i.a{constructor(e,t={},n={closed:!1}){super(t),this.collection=e,this.stateRef=n,Object.keys(t).forEach(n=>{const r=n,i=t[r],s=a(r);(null==i?void 0:i.unique)?e.createIndex({[s]:1},{unique:!0}):e.createIndex({[s]:"hashed"})})}async internalAdd(e){await this.getCollection().insertOne(l(e))}async internalUpsert(e,t){await c(()=>this.getCollection().updateOne(l({id:e}),{$set:l(t)},{upsert:!0}))}async internalUpdate(e,t,n){const r=l({[e]:t}),i={$set:l(n)};this.isIndexUnique(e)?await this.getCollection().updateOne(r,i):await this.getCollection().updateMany(r,i)}async internalGet(e,t,n){return u(await this.getCollection().findOne(l({[e]:t}),{projection:d(n)}))}async internalGetAll(e,t,n){const r=this.getCollection().find(e?l({[e]:t}):{},{projection:d(n)}),i=[];return await r.forEach(e=>i.push(u(e))),i}async internalRemove(e,t){return(await this.getCollection().deleteMany(l({[e]:t}))).deletedCount||0}getCollection(){if(this.stateRef.closed)throw new Error("Connection closed");return this.collection}}},function(e,t){e.exports=require("ioredis")},function(e,t){e.exports=require("pg")},function(e,t,n){"use strict";n.r(t),n.d(t,"MemoryDb",(function(){return m})),n.d(t,"MongoDb",(function(){return O})),n.d(t,"RedisDb",(function(){return G})),n.d(t,"LruCache",(function(){return ue})),n.d(t,"WrappedCollection",(function(){return le})),n.d(t,"encryptByKey",(function(){return be})),n.d(t,"encryptByRecord",(function(){return ge})),n.d(t,"encryptByRecordWithMasterKey",(function(){return Ee})),n.d(t,"migrate",(function(){return je})),n.d(t,"nodeEncryptionSync",(function(){return ye}));var r=n(4),i=n(0);const s="b".charCodeAt(0),o="s".charCodeAt(0),a=Uint8Array.of(s);function c(e){return e instanceof Buffer?"B"+e.toString("base64"):"string"==typeof e?"s"+e:"boolean"==typeof e?e?"t":"f":null===e?"n":"J"+JSON.stringify(e)}function l(e){const t=e[0],n=e.substr(1);switch(t){case"B":return Buffer.from(n,"base64");case"s":return n;case"t":return!0;case"f":return!1;case"n":return null;case"J":return JSON.parse(n);default:if('{["0123456789-'.includes(t))return JSON.parse(e);throw new Error("Unknown data type "+t)}}function u(e){return e instanceof Buffer?Buffer.concat([a,e]):Buffer.from(c(e),"utf8")}function d(e){if("string"==typeof e)return l(e);const t=e[0];return t===s?e.subarray(1):t===o?e.subarray(1).toString("utf8"):l(e.toString("utf8"))}function h(e){const t={};return Object.keys(e).forEach(n=>{t[n]=c(e[n])}),t}function f(e){const t={};return Object.keys(e).forEach(n=>{const r=e[n];r&&(t[n]=l(r))}),t}function p(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function y(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?p(Object(n),!0).forEach((function(t){w(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):p(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function w(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class b extends i.a{constructor(e={},t=0,n={closed:!1}){super(e),this.simulatedLatency=t,this.stateRef=n,w(this,"data",void 0),w(this,"indices",{}),this.data=new Map,Object.keys(e).forEach(e=>{this.indices[e]=new Map})}preAct(){if(this.stateRef.closed)throw new Error("Connection closed");return function(e){if(e)return new Promise(t=>setTimeout(t,e))}(this.simulatedLatency)}async internalAdd(e){const t=h(e);this.internalCheckDuplicates(t,!0),this.data.set(t.id,t),this.internalPopulateIndices(t)}async internalUpsert(e,t){this.data.has(c(e))?await this.internalUpdate("id",e,t):await this.internalAdd(y({id:e},t))}async internalUpdate(e,t,n){const r=this.internalGetSerialisedIds(e,t).map(e=>{const t=this.data.get(e),r=f(t),i=y(y({},r),n);if(i.id!==r.id)throw new Error("Cannot update ID");return{oldSerialised:t,newSerialised:h(i)}});r.forEach(({oldSerialised:e})=>this.internalRemoveIndices(e));try{r.forEach(({newSerialised:e})=>this.internalCheckDuplicates(e,!1))}catch(e){throw r.forEach(({oldSerialised:e})=>this.internalPopulateIndices(e)),e}r.forEach(({newSerialised:e})=>{this.data.set(e.id,e),this.internalPopulateIndices(e)})}async internalGetAll(e,t,n){let r;return r=e?this.internalGetSerialisedIds(e,t):[...this.data.keys()],r.map(e=>function(e,t){if(!t)return e;const n={};return t.forEach(t=>{n[t]=e[t]}),n}(f(this.data.get(e)),n))}async internalRemove(e,t){const n=this.internalGetSerialisedIds(e,t);return n.forEach(e=>{const t=this.data.get(e);this.internalRemoveIndices(t),this.data.delete(e)}),n.length}internalGetSerialisedIds(e,t){const n=c(t);if("id"===e)return this.data.has(n)?[n]:[];const r=this.indices[e];if(!r)throw new Error(`Requested key ${e} not indexed`);const i=r.get(n);return i?[...i]:[]}internalCheckDuplicates(e,t){if(t&&this.data.has(e.id))throw new Error("duplicate");Object.keys(this.keys).forEach(t=>{const n=this.indices[t];if(this.isIndexUnique(t)&&n.has(e[t]))throw new Error("duplicate")})}internalPopulateIndices(e){Object.keys(this.keys).forEach(t=>{const n=this.indices[t],r=e[t];let i=n.get(r);i||(i=new Set,n.set(r,i)),i.add(e.id)})}internalRemoveIndices(e){Object.keys(this.keys).forEach(t=>{const n=this.indices[t],r=e[t],i=n.get(r);i.delete(e.id),i.size||n.delete(r)})}}function g(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}const E=function(e,t){const n=global[e];return n||(global[e]=t,t)}("collectionStorageInMemory",new Map);class m{constructor({simulatedLatency:e=0}={}){g(this,"simulatedLatency",void 0),g(this,"mapTables",new Map),g(this,"stateRef",{closed:!1}),this.simulatedLatency=e}static connect(e){const t=new r.URL(e),n=t.hostname;if(n&&E.has(n))return E.get(n);const i=t.searchParams,s=Number(i.get("simulatedLatency")),o=new m({simulatedLatency:s});return n&&E.set(n,o),o}getCollection(e,t){return this.mapTables.has(e)||this.mapTables.set(e,new b(t,this.simulatedLatency,this.stateRef)),this.mapTables.get(e)}close(){this.stateRef.closed=!0}}class O{constructor(e,t){var n,r,i;this.client=e,this.MongoCollection=t,i={closed:!1},(r="stateRef")in(n=this)?Object.defineProperty(n,r,{value:i,enumerable:!0,configurable:!0,writable:!0}):n[r]=i}static async connect(e){const{MongoClient:t}=await Promise.resolve().then(()=>n(3)),{default:r}=await Promise.resolve().then(()=>n(6)),i=await t.connect(e,{useNewUrlParser:!0,useUnifiedTopology:!0});return new O(i,r)}getCollection(e,t){const n=this.client.db().collection(function(e){return encodeURIComponent(e)}(e));return new this.MongoCollection(n,t,this.stateRef)}async close(){return this.stateRef.closed=!0,this.client.close()}getDb(){return this.client.db()}}function v(e,...t){let n=e.map(e=>e.trim()).join(" ");return t.forEach((e,t)=>{n=n.replace(new RegExp(`\\$${e}\\b`,"g"),`ARGV[${t+1}]`)}),n}function j(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}function C(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function P(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?C(Object(n),!0).forEach((function(t){T(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):C(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function T(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}const S=e=>void 0!==e;function k(e,t){return e.filter(({key:e})=>t[e]).map(({key:e,prefix:n})=>`${n}:${t[e]}`)}function I(e,t){if(!t)return e;const n={};for(let r=0;r<t.length;r+=1)n[t[r]]=e[r];return n}function A(e){return Object.values(e).some(e=>null!==e)}async function R(e){await e.unwatch()}async function $(e,t){const n=[];for(let r=0;r<e.length;r+=1)n.push(await t(e[r]));return n}class U extends i.a{constructor(e,t,n={}){super(n),this.pool=e,this.prefix=t,T(this,"keyPrefixes",{}),T(this,"uniqueKeys",[]),T(this,"nonUniqueKeys",[]),Object.keys(n).forEach(e=>{const r=e,i=`${t}-${r}`;this.keyPrefixes[r]=i;const s={key:r,prefix:i};n[r].unique?this.uniqueKeys.push(s):this.nonUniqueKeys.push(s)})}internalAdd(e){const t=h(e);return this.pool.withConnection(async e=>{if(!await this.runAdd(e,t,!1))throw new Error("duplicate")})}internalUpdate(e,t,n,{upsert:r}){const i=h(n),s=c(t);return"id"===e?this.pool.retryWithConnection(async e=>{const t=await this.getUpdatePatch(e,s,i);if(t)await this.runUpdates(e,[t]);else if(r){const t=P(P({},i),{},{id:s});if(!await this.runAdd(e,t,!0))throw new Error("duplicate")}},R):this.pool.retryWithConnection(async t=>{const n=await this.getAndWatchBySerialisedKey(t,e,s),r=(await $(n,e=>this.getUpdatePatch(t,e,i))).filter(S);await this.runUpdates(t,r)},R)}internalGet(e,t,n){const r=c(t);return this.pool.retryWithConnection(async t=>{var i;const s=(await this.getAndWatchBySerialisedKey(t,e,r))[0];if(void 0===s)return null;return null!==(i=(await this.getByKeysKeepWatches(t,[s],n))[0])&&void 0!==i?i:null},R)}internalGetAll(e,t,n){return this.pool.retryWithConnection(async r=>{let i;if(e){const n=c(t);i=await this.getAndWatchBySerialisedKey(r,e,n)}else{i=await r.keys(this.makeKey("*"));const e=this.prefix.length+1;i=i.map(t=>t.substr(e))}return this.getByKeysKeepWatches(r,i,n)},R)}internalRemove(e,t){const n=c(t),r=Object.keys(this.keys);return r.push("id"),this.pool.retryWithConnection(async t=>{const i=await this.getAndWatchBySerialisedKey(t,e,n),s=(await $(i,e=>this.rawByKeyKeepWatches(t,e,r))).filter(S);if(0===s.length)return 0;const o=t.multi();return s.forEach(e=>{const t=k(this.uniqueKeys,e),n=k(this.nonUniqueKeys,e);o.remove(1+t.length+n.length,this.makeKey(e.id),...t,...n,e.id)}),await o.exec(),s.length},R)}makeKey(e){return`${this.prefix}:${e}`}async runAdd(e,t,n){let{id:r}=t,i=j(t,["id"]);const s=k(this.uniqueKeys,i),o=k(this.nonUniqueKeys,i),a=1+s.length+o.length,c=[this.makeKey(r),...s,...o,s.length,"id",r,...Object.entries(i).flat()];if(!n)return Boolean(await e.add(a,...c));const l=await e.multi().add(a,...c).exec();if(!l)throw new Error("transient error");return Boolean(l[0][1])}async getUpdatePatch(e,t,n){await e.watch(this.makeKey(t));const r=await this.rawByKeyKeepWatches(e,t,Object.keys(this.keys).filter(e=>n[e]));if(!r)return;const i=P({},n);return Object.keys(i).forEach(e=>{r[e]===i[e]&&(delete i[e],delete r[e])}),{sId:t,newSerialised:i,oldSerialised:r}}async runUpdates(e,t){const n=t.map(e=>this.makeUpdateArgs(e)).filter(S);if(!n.length)return;if(1===n.length){const t=await e.multi().update(n[0][0],n[0][1]).exec();if(!t)throw new Error("transient error");if(!t[0][1])throw new Error("duplicate");return}if((await $(n,t=>e.checkUpdate(t[0],t[1]))).some(e=>!e))throw new Error("duplicate");let r=e.multi();n.forEach(e=>{r=r.updateWithoutCheck(e[0],e[1])});if(!await r.exec())throw new Error("transient error")}makeUpdateArgs({sId:e,oldSerialised:t,newSerialised:n}){const r=Object.entries(n).flat();if(!r.length)return;const i=k(this.uniqueKeys,n),s=k(this.nonUniqueKeys,n),o=k(this.uniqueKeys,t),a=k(this.nonUniqueKeys,t);if(o.length!==i.length||a.length!==s.length)throw new Error("unexpected key mismatch with old value");return[1+2*(i.length+s.length),[this.makeKey(e),...i,...s,...o,...a,i.length,i.length+s.length,e,...r]]}async getByKeysKeepWatches(e,t,n){const r=await async function(e,t){return t.length?e.multi(t).exec():[]}(e,t.map(e=>this.makeKey(e)).map(e=>n?["hmget",e,...n]:["hgetall",e]));if(!r)throw new Error("transient error");return r.map(([,e])=>I(e,n)).filter(A).map(f)}async rawByKeyKeepWatches(e,t,n){const r=this.makeKey(t);let i;if(n){if(!n.length){return await e.exists(r)?{}:void 0}i=await e.hmget(r,...n)}else i=await e.hgetall(r);const s=I(i,n);return A(s)?s:void 0}async getAndWatchBySerialisedKey(e,t,n){if("id"===t)return[n];const r=this.keyPrefixes[t];if(!r)throw new Error(`Requested key ${t} not indexed`);const i=`${r}:${n}`;return await e.watch(i),e.smembers(i)}}const x=v(['if redis.call("exists",KEYS[1])==1 then',"  return 0","end","for k=2,1+tonumber($uniqueKeyCount) do",'  if redis.call("exists",KEYS[k])==1 then',"    return 0","  end","end",'redis.call("hset",KEYS[1],unpack(ARGV, 2))',"for k=2,#KEYS do",'  redis.call("sadd",KEYS[k],ARGV[3])',"end","return 1"],"uniqueKeyCount"),K=["for k=2,1+tonumber($uniqueKeyCount) do",'  if redis.call("exists",KEYS[k])==1 then',"    return 0","  end","end"],D=["local tkc=tonumber($totalKeyCount)",'redis.call("hset",KEYS[1],unpack(ARGV, 4))',"for k=1,tkc do",'  redis.call("smove",KEYS[1+tkc+k],KEYS[1+k],$id)',"end"],N=v([...K,"return 1"],"uniqueKeyCount","totalKeyCount","id"),L=v([...D],"uniqueKeyCount","totalKeyCount","id"),q=v([...K,...D,"return 1"],"uniqueKeyCount","totalKeyCount","id"),_=v(['redis.call("del",KEYS[1])',"for k=2,#KEYS do",'  redis.call("srem",KEYS[k],$id)',"end"],"id");var B=n(2);function W(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}const M=Object(B.a)(e=>"object"==typeof e&&"transient error"===e.message);class F{constructor(e,t,n,r){this.RedisStatic=e,this.url=t,this.options=n,this.maxConnections=r,W(this,"connections",[]),W(this,"inUse",0),W(this,"queue",[]),W(this,"closingFn",void 0),W(this,"closed",!1)}async withConnection(e,t){const n=await this.getConnection();try{return await e(n)}finally{await(null==t?void 0:t(n)),this.returnConnection(n)}}async retryWithConnection(e,t){return M(()=>this.withConnection(e,t))}close(){return this.closed?Promise.resolve():(this.closed=!0,0===this.inUse?(this.doClose(),Promise.resolve()):new Promise(e=>{this.closingFn=()=>{this.doClose(),e()}}))}doClose(){this.connections.forEach(e=>e.disconnect()),this.connections.length=0}async getConnection(){if(this.closed)throw new Error("Connection closed");const e=this.connections.pop();if(e)return this.inUse+=1,e;if(this.inUse<this.maxConnections){this.inUse+=1;const e=new this.RedisStatic(this.url,this.options);return await e.connect(),function(e){return e.defineCommand("add",{lua:x}),e.defineCommand("update",{lua:q}),e.defineCommand("checkUpdate",{lua:N}),e.defineCommand("updateWithoutCheck",{lua:L}),e.defineCommand("remove",{lua:_}),e}(e)}return new Promise(e=>{this.queue.push(e)})}returnConnection(e){const t=this.queue.shift();var n;t?t(e):(this.inUse-=1,this.connections.push(e),0===this.inUse&&(null===(n=this.closingFn)||void 0===n||n.call(this)))}}class G{constructor(e){this.pool=e}static async connect(e){const{default:t}=await Promise.resolve().then(()=>n(7));return new G(new F(t,e,{lazyConnect:!0},5))}getCollection(e,t){return new U(this.pool,e,t)}close(){return this.pool.close()}getConnectionPool(){return this.pool}}function Q(e){return`"${e.replace(/(["\\])/g,"\\$1")}"`}const X=/"/g;const Y=/'/g;function H(e){return`'${e.replace(Y,"''")}'`}const V=/\$[A-Z]/g;function J(e,t){return e.replace(V,e=>`"${t[e.substr(1)].replace(X,'""')}"`)}function z(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}function Z(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}const ee={CREATE_TABLE:["CREATE TABLE IF NOT EXISTS $T (","id TEXT NOT NULL PRIMARY KEY,","data HSTORE NOT NULL",")"].join(""),CREATE_INDEX:"CREATE INDEX IF NOT EXISTS $I ON $T USING HASH ((data->$1))",CREATE_UNIQUE_INDEX:"CREATE UNIQUE INDEX IF NOT EXISTS $I ON $T ((data->$1))",DROP_INDEX:"DROP INDEX IF EXISTS $I",INSERT:"INSERT INTO $T (id, data) VALUES ($1, $2::hstore)",UPDATE:"UPDATE $T SET data=data||$1::hstore WHERE data->$2=$3 RETURNING id",UPDATE_ID:"UPDATE $T SET data=data||$1::hstore WHERE id=$2",UPSERT_ID:"INSERT INTO $T (id, data) VALUES ($1, $2::hstore) ON CONFLICT (id) DO UPDATE SET data=$T.data||$2::hstore",SELECT_ONE:"SELECT id, data FROM $T WHERE data->$1=$2 LIMIT 1",SELECT_ALL:"SELECT id, data FROM $T",SELECT_ALL_BY:"SELECT id, data FROM $T WHERE data->$1=$2",SELECT_ID:"SELECT id, data FROM $T WHERE id=$1",DELETE:"DELETE FROM $T WHERE data->$1=$2",DELETE_ID:"DELETE FROM $T WHERE id=$1"};function te(e){return function(e){const t=[];return Object.keys(e).forEach(n=>{t.push(`${Q(n)}=>${Q(e[n])}`)}),t.join(",")}(h(e))}function ne([e,t],n){const r=function(e){const t={};let n="",r="",i=!1;for(let s=0;s<e.length;){const o=e[s];switch(o){case" ":case"\r":case"\n":case"\t":i&&(n+=o);break;case"\\":n+=e[s+1],s+=1;break;case'"':i=!i;break;case"=":i?n+=o:">"===e[s+1]&&(r=n,n="",s+=1);break;case",":i?n+=o:(t[r]=n,r="",n="");break;default:n+=o}s+=1}return r&&(t[r]=n),t}(t);r.id=e;const i={};return n?(n.forEach(e=>{i[e]=l(r[e])}),i):(Object.entries(r).forEach(([e,t])=>{i[e]=l(t)}),i)}class re extends i.a{constructor(e,t,n={},r={closed:!1}){super(n),this.pool=e,this.stateRef=r,Z(this,"tableName",void 0),Z(this,"cachedQueries",{}),Z(this,"pending",[]),this.tableName=t,async function(e,t,n={}){const r=await e.connect();try{await r.query(J(ee.CREATE_TABLE,{T:t}));const e=Object.entries(n);for(let n=0;n<e.length;n+=1){const[i,s]=e[n];s&&s.unique?(await r.query(J(ee.DROP_INDEX,{T:t,I:`${t}_i${i}`})),await r.query(J(ee.CREATE_UNIQUE_INDEX,{T:t,I:`${t}_u${i}`}).replace(/\$1/g,H(i)))):(await r.query(J(ee.DROP_INDEX,{T:t,I:`${t}_u${i}`})),await r.query(J(ee.CREATE_INDEX,{T:t,I:`${t}_i${i}`}).replace(/\$1/g,H(i))))}}finally{r.release()}}(e,this.tableName,n).then(()=>{this.pending&&(this.pending.forEach(e=>e()),this.pending=void 0)}).catch(e=>{process.stderr.write(`Failed to prepare table ${t}: ${e}`)})}preAct(){if(this.stateRef.closed)throw new Error("Connection closed")}async internalAdd(e){let{id:t}=e,n=z(e,["id"]);await this.runTableQuery("INSERT",c(t),te(n))}async internalUpsert(e,t){await this.runTableQuery("UPSERT_ID",c(e),te(t))}async internalUpdate(e,t,n){let{id:r}=n,i=z(n,["id"]);const s=c(t),o=te(i);if("id"===e)await this.runTableQuery("UPDATE_ID",o,s);else{const t=await this.runTableQuery("UPDATE",o,e,s);if(void 0!==r&&t.rowCount>0&&t.rows[0][0]!==r)throw new Error("Cannot update ID")}}async internalGet(e,t,n){let r;return r="id"===e?await this.runTableQuery("SELECT_ID",c(t)):await this.runTableQuery("SELECT_ONE",e,c(t)),r.rowCount?ne(r.rows[0],n):null}async internalGetAll(e,t,n){let r;return r=e?"id"===e?await this.runTableQuery("SELECT_ID",c(t)):await this.runTableQuery("SELECT_ALL_BY",e,c(t)):await this.runTableQuery("SELECT_ALL"),r.rows.map(e=>ne(e,n))}async internalRemove(e,t){let n;return n="id"===e?await this.runTableQuery("DELETE_ID",c(t)):await this.runTableQuery("DELETE",e,c(t)),n.rowCount}async runTableQuery(e,...t){this.pending&&await new Promise(e=>{this.pending.push(e)});let n=this.cachedQueries[e];return n||(n=J(ee[e],{T:this.tableName}),this.cachedQueries[e]=n),this.pool.query({name:`${this.tableName}_${e}`,rowMode:"array",text:n,values:t})}}class ie{constructor(e){var t,n,r;this.pool=e,r={closed:!1},(n="stateRef")in(t=this)?Object.defineProperty(t,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[n]=r}static async connect(e){const{Pool:t}=await Promise.resolve().then(()=>n(8)),r=new t({connectionString:e});return await r.query("CREATE EXTENSION IF NOT EXISTS hstore"),new ie(r)}getCollection(e,t){return new re(this.pool,e,t,this.stateRef)}close(){return this.stateRef.closed?Promise.resolve():(this.stateRef.closed=!0,this.pool.end())}getConnectionPool(){return this.pool}}function se(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function oe(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?se(Object(n),!0).forEach((function(t){ae(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):se(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function ae(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function ce(e,t){return t.some(t=>Object.prototype.hasOwnProperty.call(e,t))}class le{constructor(e,t,n){this.baseCollection=e,this.fields=t,this.wrapper=n}async add(e){return this.baseCollection.add(await this.wrapAll(e))}async get(e,t,n){if(this.fields.includes(e))throw new Error("Cannot get by wrapped value");const r=await this.baseCollection.get(e,t,n);return r?this.unwrapAll(r,{[e]:t}):null}async getAll(e,t,n){if(void 0!==e&&this.fields.includes(e))throw new Error("Cannot get by wrapped value");const r=await this.baseCollection.getAll(e,t,n),i=void 0!==e?{[e]:t}:void 0;return Promise.all(r.map(e=>this.unwrapAll(e,i)))}async update(e,t,n,r){if(this.fields.includes(e))throw new Error("Cannot update by wrapped value");const i=await this.wrapAll(n,{[e]:t});return this.baseCollection.update(e,t,i,r)}async remove(e,t){if(this.fields.includes(e))throw new Error("Cannot remove by wrapped value");if(!this.wrapper.preRemove)return this.baseCollection.remove(e,t);const n=await this.baseCollection.getAll(e,t,["id"]);return await Promise.all(n.map(async e=>{await this.wrapper.preRemove(e),await this.baseCollection.remove("id",e.id)})),n.length}async wrapAll(e,t){let n;if(this.wrapper.preWrap&&ce(e,this.fields)){const r=t?oe(oe({},t),e):e;n=await this.wrapper.preWrap(r)}const r=oe({},e);return await Promise.all(this.fields.map(async t=>{Object.prototype.hasOwnProperty.call(e,t)&&(r[t]=await this.wrapper.wrap(t,e[t],n))})),r}async unwrapAll(e,t){let n;if(this.wrapper.preUnwrap&&ce(e,this.fields)){const r=t?oe(oe({},t),e):e;n=await this.wrapper.preUnwrap(r)}const r=oe({},e);return await Promise.all(this.fields.map(async t=>{Object.prototype.hasOwnProperty.call(e,t)&&(r[t]=await this.wrapper.unwrap(t,e[t],n))})),r}}class ue{constructor(e){var t,n,r;this.capacity=e,t=this,n="storage",r=new Map,n in t?Object.defineProperty(t,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[n]=r}set(e,t){this.storage.delete(e),this.storage.set(e,t),this.flush()}get(e){const t=this.storage.get(e);return this.storage.delete(e)&&this.storage.set(e,t),t}remove(e){this.storage.delete(e)}flush(){for(;this.storage.size>this.capacity;)this.storage.delete(this.storage.keys().next().value)}}var de=n(1),he=n.n(de);const fe="aes-256-cbc",pe=Buffer.from(fe+":","utf8");var ye={encrypt:(e,t)=>{const n=he.a.randomBytes(16),r=he.a.createCipheriv(fe,e,n),i=r.update(t),s=r.final();return Buffer.concat([pe,n,i,s])},decrypt:(e,t)=>{if(!t.slice(0,pe.length).equals(pe))throw new Error("Unknown encryption algorithm");const n=t.slice(pe.length,pe.length+16),r=t.slice(pe.length+16),i=he.a.createDecipheriv(fe,e,n),s=i.update(r),o=i.final();return Buffer.concat([s,o])},generateKey:()=>he.a.createSecretKey(he.a.randomBytes(32)),serialiseKey:e=>e.export(),deserialiseKey:e=>he.a.createSecretKey(e)};function we(e){return(t,n)=>t&&n?e(t,n):e}function be(e,t=ye){const n=t.deserialiseKey(e);return we((e,r)=>new le(r,e,{wrap:(e,r)=>t.encrypt(n,u(r)),unwrap:async(e,r)=>d(await t.decrypt(n,r))}))}function ge(e,t=0,n=ye){const r=new ue(t),i=async(t,i)=>{const{id:s}=i;if(void 0===s)throw new Error("Must provide ID for encryption");const o=r.get(s);if(o)return o;let a;const c=await e.get("id",s,["key"]);if(c)a=n.deserialiseKey(c.key);else{if(!t)throw new Error("No encryption key found for record");a=await n.generateKey(),await e.add({id:s,key:n.serialiseKey(a)})}return r.set(s,a),a},s=async({id:t})=>{await e.remove("id",t),r.remove(t)};return we((e,t)=>new le(t,e,{wrap:(e,t,r)=>n.encrypt(r,u(t)),unwrap:async(e,t,r)=>d(await n.decrypt(r,t)),preWrap:i.bind(null,!0),preUnwrap:i.bind(null,!1),preRemove:s}))}function Ee(e,t,n=0,r=ye){return ge(be(e,r)()(["key"],t),n,r)}function me(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Oe(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class ve{constructor(e,t,n){this.baseCollection=e,this.migrations=t,this.extraFetchFields=n}async add(e){return this.baseCollection.add(e)}async get(e,t,n){const r=await this.baseCollection.get(e,t,this.extendAttributes(n));return r?this.applyMigration(r,n):null}async getAll(e,t,n){return(await this.baseCollection.getAll(e,t,this.extendAttributes(n))).map(e=>this.applyMigration(e,n))}async update(e,t,n,r){return this.baseCollection.update(e,t,n,r)}async remove(e,t){return this.baseCollection.remove(e,t)}extendAttributes(e){return e&&this.extraFetchFields?[...e,...this.extraFetchFields]:e}applyMigration(e,t){if(t&&!t.some(e=>this.migrations[e]))return e;const n=function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?me(Object(n),!0).forEach((function(t){Oe(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):me(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({},e);return(t||Object.keys(this.migrations)).forEach(t=>{const r=t,i=this.migrations[r];i&&(n[r]=i(e[r],e))}),n}}var je=function(e,t,n){return n?new ve(n,t,e):new ve(t,e)};t.default=class{static async connect(e){let t;if(e.startsWith("memory"))t=m;else if(e.startsWith("mongodb"))t=O;else if(e.startsWith("redis"))t=G;else{if(!e.startsWith("postgres"))throw new Error("Unsupported database connection string: "+e);t=ie}try{return await t.connect(e)}catch(t){throw new Error(`Failed to connect to database "${e}": ${t.message}`)}}}}])}));
//# sourceMappingURL=index.js.map